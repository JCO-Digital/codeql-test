var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj, member, value, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
(function() {
  "use strict";
  var _focused, _cleanup, _setup, _a, _online, _cleanup2, _setup2, _b, _gcTimeout, _c, _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _d, _queries, _e, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _f, _mutations, _scopes, _mutationId, _g, _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _h, _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _i;
  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = `.add-border[data-v-cb07adac] {
  border-bottom: 1px solid #707070;
}/* HubSpot Form Styling, do not look to closely, it is mostly AI generated */
[data-v-6f37a646] .hs-form-html {
  width: 100%;
}
[data-v-6f37a646] .hs-form-html form {
  display: flex;
  flex-direction: column;
}
[data-v-6f37a646] .hs-form-html .hs-form-field {
  margin-bottom: 0;
}
[data-v-6f37a646] .hs-form-html .hs-form-field-group {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 0;
}
[data-v-6f37a646] .hs-form-html .hs-form-field-group .hs-form-field {
  margin-bottom: 0;
}

/* Input wrapper divs */
[data-v-6f37a646] .hs-form-html .input {
  width: 100%;
  display: block;
}

/* Input fields */
[data-v-6f37a646] .hs-form-html input[type="text"],[data-v-6f37a646] .hs-form-html input[type="email"],[data-v-6f37a646] .hs-form-html input[type="tel"],[data-v-6f37a646] .hs-form-html input[type="number"],[data-v-6f37a646] .hs-form-html select,[data-v-6f37a646] .hs-form-html textarea {
  width: 100% !important;
  box-sizing: border-box;
  padding: 0.75rem;
  border: 1px solid #d1d5db;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  line-height: 1.5;
  color: #1f2937;
  background-color: #ffffff;
  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
}
[data-v-6f37a646] .hs-form-html input[type="text"]:focus,[data-v-6f37a646] .hs-form-html input[type="email"]:focus,[data-v-6f37a646] .hs-form-html input[type="tel"]:focus,[data-v-6f37a646] .hs-form-html input[type="number"]:focus,[data-v-6f37a646] .hs-form-html select:focus,[data-v-6f37a646] .hs-form-html textarea:focus {
  outline: none;
  border-color: #3b82f6;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
}
[data-v-6f37a646] .hs-form-html input::-moz-placeholder,[data-v-6f37a646] .hs-form-html textarea::-moz-placeholder {
  color: #9ca3af;
  opacity: 1;
}
[data-v-6f37a646] .hs-form-html input::placeholder,[data-v-6f37a646] .hs-form-html textarea::placeholder {
  color: #9ca3af;
  opacity: 1;
}

/* Labels */
[data-v-6f37a646] .hs-form-html label {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  font-weight: 500;
  color: #374151;
}
[data-v-6f37a646] .hs-form-html .hs-form-required {
  color: #ef4444;
  margin-left: 0.25rem;
}

/* Select dropdown */
[data-v-6f37a646] .hs-form-html select {
  -webkit-appearance: none;
     -moz-appearance: none;
          appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23374151' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.75rem center;
  background-size: 12px;
  padding-right: 2.5rem;
  cursor: pointer;
}

/* Textarea */
[data-v-6f37a646] .hs-form-html textarea {
  min-height: 100px;
  resize: vertical;
}

/* Checkbox styling */
[data-v-6f37a646] .hs-form-html input[type="checkbox"] {
  width: 1rem;
  height: 1rem;
  margin-right: 0.5rem;
  cursor: pointer;
  accent-color: #3b82f6;
}
[data-v-6f37a646] .hs-form-html .hs-form-booleancheckbox-display {
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
}
[data-v-6f37a646] .hs-form-html .hs-form-booleancheckbox-display label {
  margin-bottom: 0;
  font-weight: 400;
  font-size: 0.875rem;
  line-height: 1.5;
  color: #4b5563;
  cursor: pointer;
}

/* Submit button */
[data-v-6f37a646] .hs-form-html input[type="submit"],[data-v-6f37a646] .hs-form-html .hs-button {
  width: 100%;
  padding: 0.75rem 1.5rem;
  margin-top: 0.5rem;
  background: linear-gradient(102deg, #0565ff 0%, #8c43ff 100%);
  color: #ffffff;
  border: none;
  border-radius: 0.375rem;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}
[data-v-6f37a646] .hs-form-html input[type="submit"]:hover,[data-v-6f37a646] .hs-form-html .hs-button:hover {
  background: linear-gradient(102deg, #0565ff 0%, #8c43ff 100%);
  transform: translateY(-1px);
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
}
[data-v-6f37a646] .hs-form-html input[type="submit"]:active,[data-v-6f37a646] .hs-form-html .hs-button:active {
  transform: translateY(0);
}

/* Form field descriptions */
[data-v-6f37a646] .hs-form-html .hs-field-desc {
  margin-top: 0.25rem;
  font-size: 0.75rem;
  color: #6b7280;
}

/* Field wrappers */
[data-v-6f37a646] .hs-form-html .hs-form-field {
  margin-bottom: 0;
}

/* Error messages and alerts - simplified, subtle styling */
[data-v-6f37a646] .hs-form-html .hs-error-msgs,[data-v-6f37a646] .hs-form-html ul.hs-error-msgs,[data-v-6f37a646] .hs-form-html .no-list.hs-error-msgs {
  margin-top: 0.25rem;
  margin-bottom: 0;
  padding: 0;
  background-color: transparent;
  border: none;
  list-style: none;
}
[data-v-6f37a646] .hs-form-html .hs-error-msgs li {
  margin: 0;
  padding: 0;
  list-style: none;
}
[data-v-6f37a646] .hs-form-html .hs-error-msgs label,[data-v-6f37a646] .hs-form-html .hs-error-msg {
  color: #dc2626;
  font-size: 0.75rem;
  margin: 0;
  padding: 0;
  display: block;
  font-weight: 400;
}

/* Error state for inputs */
[data-v-6f37a646] .hs-form-html input.error,[data-v-6f37a646] .hs-form-html select.error,[data-v-6f37a646] .hs-form-html textarea.error {
  border-color: #ef4444;
  background-color: #fef2f2;
}

/* Success messages */
[data-v-6f37a646] .hs-form-html .hs-main-font-element {
  color: #059669;
  font-size: 0.875rem;
  margin-top: 0.5rem;
}

/* Form layout adjustments - FIELDSET elements */
[data-v-6f37a646] .hs-form-html fieldset.form-columns-2 {
  margin-bottom: 0;
  border: none;
  padding: 0;
  display: flex;
  gap: 0.5rem;
}
[data-v-6f37a646] .hs-form-html fieldset.form-columns-1 {
  margin-bottom: 0;
  border: none;
  padding: 0;
}
[data-v-6f37a646] .hs-form-html .hs-form-field {
  padding: 0.5rem 0;
}

/* Remove extra spacing from field wrappers */
[data-v-6f37a646] .hs-form-html .hs-form-field-group {
  margin: 0;
  padding: 0;
}
@media (max-width: 768px) {
[data-v-6f37a646] .hs-form-html fieldset.form-columns-2 {
    grid-template-columns: 1fr;
}
}
/* Submit button wrapper */
[data-v-6f37a646] .hs-form-html .hs_submit,[data-v-6f37a646] .hs-form-html .hs-submit {
  margin-top: 1rem;
  padding: 0;
}

/* Remove default HubSpot styling and fix spacing */
[data-v-6f37a646] .hs-form-html form {
  margin: 0;
  padding: 0;
}

/* Ensure labels don't have excessive spacing */
[data-v-6f37a646] .hs-form-html .hs-form-field > label:first-child {
  margin-bottom: 0.5rem;
  margin-top: 0;
}
[data-v-6f37a646] .hs-form-html .hs-fieldtype-booleancheckbox ul {
  list-style: none;
  padding-left: 0;
}
[data-v-6f37a646] .hs-form-html .hs-fieldtype-booleancheckbox ul li {
  margin-bottom: 0;
}
[data-v-6f37a646] .hs-form-html .hs-fieldtype-booleancheckbox ul li span {
  margin-left: 0;
}.multi-select-item[data-v-f6a0e96b]:hover {
  cursor: pointer;
}
.multi-select-item[data-state=checked] .indicator[data-v-f6a0e96b] {
  --tw-bg-opacity: 1;
  background-color: rgb(35 35 35 / var(--tw-bg-opacity, 1));
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1));
}
.multi-select-item[data-state=checked] .indicator i[data-v-f6a0e96b] {
  color: var(--bs-light) !important;
}
.multi-select-item[data-disabled][data-v-f6a0e96b]:not([data-state=checked]) {
  opacity: 0.5;
  cursor: not-allowed;
}
.multi-select-trigger[data-state=open] i[data-v-f6a0e96b] {
  --tw-rotate: 180deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
  --tw-contain-size:  ;
  --tw-contain-layout:  ;
  --tw-contain-paint:  ;
  --tw-contain-style:  ;
}
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}
.pointer-events-none {
  pointer-events: none;
}
.fixed {
  position: fixed;
}
.absolute {
  position: absolute;
}
.relative {
  position: relative;
}
.sticky {
  position: sticky;
}
.inset-0 {
  inset: 0px;
}
.left-1 {
  left: 0.25rem;
}
.left-1\\/2 {
  left: 50%;
}
.right-1\\.5 {
  right: 0.375rem;
}
.right-4 {
  right: 1rem;
}
.top-0 {
  top: 0px;
}
.top-1\\.5 {
  top: 0.375rem;
}
.top-1\\/2 {
  top: 50%;
}
.top-4 {
  top: 1rem;
}
.top-\\[-150px\\] {
  top: -150px;
}
.top-\\[50\\%\\] {
  top: 50%;
}
.z-\\[15\\] {
  z-index: 15;
}
.z-\\[1\\] {
  z-index: 1;
}
.z-\\[2\\] {
  z-index: 2;
}
.z-\\[8\\] {
  z-index: 8;
}
.z-\\[9999\\] {
  z-index: 9999;
}
.col-span-1 {
  grid-column: span 1 / span 1;
}
.col-span-12 {
  grid-column: span 12 / span 12;
}
.col-span-2 {
  grid-column: span 2 / span 2;
}
.col-span-4 {
  grid-column: span 4 / span 4;
}
.row-span-3 {
  grid-row: span 3 / span 3;
}
.\\!m-3 {
  margin: 0.75rem !important;
}
.m-0 {
  margin: 0px;
}
.\\!my-0 {
  margin-top: 0px !important;
  margin-bottom: 0px !important;
}
.my-0 {
  margin-top: 0px;
  margin-bottom: 0px;
}
.my-auto {
  margin-top: auto;
  margin-bottom: auto;
}
.\\!mb-0 {
  margin-bottom: 0px !important;
}
.-mb-2 {
  margin-bottom: -0.5rem;
}
.-mb-4 {
  margin-bottom: -1rem;
}
.mb-0 {
  margin-bottom: 0px;
}
.mb-12 {
  margin-bottom: 3rem;
}
.mb-4 {
  margin-bottom: 1rem;
}
.mb-8 {
  margin-bottom: 2rem;
}
.ml-1 {
  margin-left: 0.25rem;
}
.ml-8 {
  margin-left: 2rem;
}
.ml-auto {
  margin-left: auto;
}
.ms-4 {
  margin-inline-start: 1rem;
}
.mt-0 {
  margin-top: 0px;
}
.mt-3 {
  margin-top: 0.75rem;
}
.mt-auto {
  margin-top: auto;
}
.box-border {
  box-sizing: border-box;
}
.block {
  display: block;
}
.inline-block {
  display: inline-block;
}
.flex {
  display: flex;
}
.inline-flex {
  display: inline-flex;
}
.grid {
  display: grid;
}
.\\!hidden {
  display: none !important;
}
.hidden {
  display: none;
}
.h-\\[120px\\] {
  height: 120px;
}
.h-\\[20px\\] {
  height: 20px;
}
.h-\\[75px\\] {
  height: 75px;
}
.h-auto {
  height: auto;
}
.h-full {
  height: 100%;
}
.max-h-6 {
  max-height: 1.5rem;
}
.max-h-\\[200px\\] {
  max-height: 200px;
}
.max-h-\\[600px\\] {
  max-height: 600px;
}
.max-h-\\[90vh\\] {
  max-height: 90vh;
}
.min-h-10 {
  min-height: 2.5rem;
}
.min-h-\\[50px\\] {
  min-height: 50px;
}
.\\!w-full {
  width: 100% !important;
}
.w-\\[120px\\] {
  width: 120px;
}
.w-\\[200px\\] {
  width: 200px;
}
.w-\\[20px\\] {
  width: 20px;
}
.w-fit {
  width: -moz-fit-content;
  width: fit-content;
}
.w-full {
  width: 100%;
}
.w-max {
  width: -moz-max-content;
  width: max-content;
}
.min-w-\\[140px\\] {
  min-width: 140px;
}
.min-w-\\[160px\\] {
  min-width: 160px;
}
.min-w-\\[240px\\] {
  min-width: 240px;
}
.max-w-24 {
  max-width: 6rem;
}
.max-w-32 {
  max-width: 8rem;
}
.max-w-\\[100vw\\] {
  max-width: 100vw;
}
.max-w-\\[90vw\\] {
  max-width: 90vw;
}
.max-w-full {
  max-width: 100%;
}
.shrink {
  flex-shrink: 1;
}
.flex-grow {
  flex-grow: 1;
}
.grow {
  flex-grow: 1;
}
.-translate-x-1\\/2 {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.-translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.-translate-y-\\[50\\%\\] {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.rotate-180 {
  --tw-rotate: 180deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.scale-\\[1\\.002\\] {
  --tw-scale-x: 1.002;
  --tw-scale-y: 1.002;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.cursor-pointer {
  cursor: pointer;
}
.cursor-text {
  cursor: text;
}
.resize {
  resize: both;
}
.list-none {
  list-style-type: none;
}
.grid-cols-2 {
  grid-template-columns: repeat(2, minmax(0, 1fr));
}
.grid-cols-\\[auto_1fr\\] {
  grid-template-columns: auto 1fr;
}
.grid-rows-\\[auto_1fr\\] {
  grid-template-rows: auto 1fr;
}
.flex-row {
  flex-direction: row;
}
.flex-col {
  flex-direction: column;
}
.\\!flex-wrap {
  flex-wrap: wrap !important;
}
.flex-wrap {
  flex-wrap: wrap;
}
.items-start {
  align-items: flex-start;
}
.items-center {
  align-items: center;
}
.justify-start {
  justify-content: flex-start;
}
.justify-end {
  justify-content: flex-end;
}
.justify-center {
  justify-content: center;
}
.justify-between {
  justify-content: space-between;
}
.gap-0\\.5 {
  gap: 0.125rem;
}
.gap-2 {
  gap: 0.5rem;
}
.gap-3 {
  gap: 0.75rem;
}
.gap-4 {
  gap: 1rem;
}
.gap-6 {
  gap: 1.5rem;
}
.gap-x-40 {
  -moz-column-gap: 10rem;
       column-gap: 10rem;
}
.gap-y-2 {
  row-gap: 0.5rem;
}
.gap-y-4 {
  row-gap: 1rem;
}
.overflow-auto {
  overflow: auto;
}
.overflow-hidden {
  overflow: hidden;
}
.overflow-y-auto {
  overflow-y: auto;
}
.truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.rounded-\\[4px\\] {
  border-radius: 4px;
}
.rounded-\\[8px\\] {
  border-radius: 8px;
}
.rounded-full {
  border-radius: 9999px;
}
.rounded-lg {
  border-radius: 0.5rem;
}
.rounded-md {
  border-radius: 0.375rem;
}
.rounded-sm {
  border-radius: 0.125rem;
}
.\\!border {
  border-width: 1px !important;
}
.\\!border-0 {
  border-width: 0px !important;
}
.border {
  border-width: 1px;
}
.border-0 {
  border-width: 0px;
}
.\\!border-solid {
  border-style: solid !important;
}
.border-solid {
  border-style: solid;
}
.\\!border-\\[\\#0565FF\\] {
  --tw-border-opacity: 1 !important;
  border-color: rgb(5 101 255 / var(--tw-border-opacity, 1)) !important;
}
.\\!border-gray-light {
  --tw-border-opacity: 1 !important;
  border-color: rgb(222 222 237 / var(--tw-border-opacity, 1)) !important;
}
.\\!border-primary {
  --tw-border-opacity: 1 !important;
  border-color: rgb(35 35 35 / var(--tw-border-opacity, 1)) !important;
}
.border-\\[\\#0565FF\\] {
  --tw-border-opacity: 1;
  border-color: rgb(5 101 255 / var(--tw-border-opacity, 1));
}
.\\!bg-light-blue {
  --tw-bg-opacity: 1 !important;
  background-color: rgb(0 211 255 / var(--tw-bg-opacity, 1)) !important;
}
.\\!bg-primary {
  --tw-bg-opacity: 1 !important;
  background-color: rgb(35 35 35 / var(--tw-bg-opacity, 1)) !important;
}
.\\!bg-secondary {
  --tw-bg-opacity: 1 !important;
  background-color: rgb(5 101 255 / var(--tw-bg-opacity, 1)) !important;
}
.bg-\\[\\#0565FF\\]\\/10 {
  background-color: rgb(5 101 255 / 0.1);
}
.bg-\\[\\#CFE8FF\\] {
  --tw-bg-opacity: 1;
  background-color: rgb(207 232 255 / var(--tw-bg-opacity, 1));
}
.bg-black {
  --tw-bg-opacity: 1;
  background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1));
}
.bg-gray-light {
  --tw-bg-opacity: 1;
  background-color: rgb(222 222 237 / var(--tw-bg-opacity, 1));
}
.bg-light {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));
}
.bg-primary {
  --tw-bg-opacity: 1;
  background-color: rgb(35 35 35 / var(--tw-bg-opacity, 1));
}
.bg-secondary {
  --tw-bg-opacity: 1;
  background-color: rgb(5 101 255 / var(--tw-bg-opacity, 1));
}
.bg-transparent {
  background-color: transparent;
}
.bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1));
}
.bg-opacity-50 {
  --tw-bg-opacity: 0.5;
}
.\\!bg-gradient {
  background-image: linear-gradient(134deg, #0565FF 0%, #8C43FF 100%) !important;
}
.\\!bg-gradient-secondary {
  background-image: linear-gradient(102deg, #0565FF 0%, #8C43FF 100%) !important;
}
.bg-gradient-tertiary {
  background-image: linear-gradient(91deg, #F432FF 0%, #0565FF 28%, #002D67 73%, #8C43FF 100%);
}
.object-contain {
  -o-object-fit: contain;
     object-fit: contain;
}
.\\!p-0 {
  padding: 0px !important;
}
.\\!p-2 {
  padding: 0.5rem !important;
}
.\\!p-4 {
  padding: 1rem !important;
}
.\\!p-5 {
  padding: 1.25rem !important;
}
.p-1 {
  padding: 0.25rem;
}
.p-2 {
  padding: 0.5rem;
}
.p-3 {
  padding: 0.75rem;
}
.p-4 {
  padding: 1rem;
}
.p-5 {
  padding: 1.25rem;
}
.p-6 {
  padding: 1.5rem;
}
.\\!px-6 {
  padding-left: 1.5rem !important;
  padding-right: 1.5rem !important;
}
.\\!py-3 {
  padding-top: 0.75rem !important;
  padding-bottom: 0.75rem !important;
}
.px-10 {
  padding-left: 2.5rem;
  padding-right: 2.5rem;
}
.px-2 {
  padding-left: 0.5rem;
  padding-right: 0.5rem;
}
.px-3 {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.px-4 {
  padding-left: 1rem;
  padding-right: 1rem;
}
.px-5 {
  padding-left: 1.25rem;
  padding-right: 1.25rem;
}
.py-2 {
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
}
.py-3 {
  padding-top: 0.75rem;
  padding-bottom: 0.75rem;
}
.py-4 {
  padding-top: 1rem;
  padding-bottom: 1rem;
}
.\\!pl-0 {
  padding-left: 0px !important;
}
.\\!pl-2 {
  padding-left: 0.5rem !important;
}
.pb-4 {
  padding-bottom: 1rem;
}
.pl-2 {
  padding-left: 0.5rem;
}
.pl-3 {
  padding-left: 0.75rem;
}
.pt-2 {
  padding-top: 0.5rem;
}
.pt-3 {
  padding-top: 0.75rem;
}
.pt-5 {
  padding-top: 1.25rem;
}
.text-center {
  text-align: center;
}
.text-right {
  text-align: right;
}
.font-sans {
  font-family: Lato, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.text-\\[12px\\] {
  font-size: 12px;
}
.text-\\[15px\\] {
  font-size: 15px;
}
.text-\\[22px\\] {
  font-size: 22px;
}
.text-lg {
  font-size: 24px;
}
.text-md {
  font-size: 20px;
}
.text-sm {
  font-size: 18px;
}
.text-xl {
  font-size: 28px;
}
.text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}
.font-bold {
  font-weight: 700;
}
.font-normal {
  font-weight: 400;
}
.font-semibold {
  font-weight: 600;
}
.uppercase {
  text-transform: uppercase;
}
.\\!text-light {
  --tw-text-opacity: 1 !important;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1)) !important;
}
.\\!text-primary {
  --tw-text-opacity: 1 !important;
  color: rgb(35 35 35 / var(--tw-text-opacity, 1)) !important;
}
.\\!text-secondary {
  --tw-text-opacity: 1 !important;
  color: rgb(5 101 255 / var(--tw-text-opacity, 1)) !important;
}
.\\!text-white {
  --tw-text-opacity: 1 !important;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1)) !important;
}
.text-danger {
  --tw-text-opacity: 1;
  color: rgb(255 71 59 / var(--tw-text-opacity, 1));
}
.text-gray-900 {
  --tw-text-opacity: 1;
  color: rgb(17 24 39 / var(--tw-text-opacity, 1));
}
.text-secondary {
  --tw-text-opacity: 1;
  color: rgb(5 101 255 / var(--tw-text-opacity, 1));
}
.text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1));
}
.underline {
  text-decoration-line: underline;
}
.no-underline {
  text-decoration-line: none;
}
.shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.shadow-md {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.outline {
  outline-style: solid;
}
.filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.transition-transform {
  transition-property: transform;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.duration-100 {
  transition-duration: 100ms;
}
.duration-200 {
  transition-duration: 200ms;
}
.duration-300 {
  transition-duration: 300ms;
}
#main-app,
#download-page,
#search-bar {
  box-sizing: border-box;
}
#main-app button,
#download-page button,
#search-bar button {
  cursor: pointer;
}
#main-app .country-profile h2,
#download-page .country-profile h2,
#search-bar .country-profile h2 {
  font-size: 3.125rem;
  margin-bottom: 0;
}
#main-app .country-profile h3,
#download-page .country-profile h3,
#search-bar .country-profile h3 {
  font-size: 1rem;
  font-weight: 700;
  margin-bottom: 1rem;
}
#main-app .country-profile p,
#download-page .country-profile p,
#search-bar .country-profile p {
  font-size: 1.1rem;
  font-weight: 400;
  color: #000;
}
#main-app .country-profile li,
#download-page .country-profile li,
#search-bar .country-profile li {
  font-size: 1.1rem;
  font-weight: 400;
}
#main-app .country-profile.image-frame,
#download-page .country-profile.image-frame,
#search-bar .country-profile.image-frame {
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 0 0 0 160px;
}
#main-app .country-profile.image-frame img,
#download-page .country-profile.image-frame img,
#search-bar .country-profile.image-frame img {
  -o-object-fit: cover;
     object-fit: cover;
  width: 100%;
  height: 100%;
  border-radius: 0 0 0 110px;
}
#main-app .country-profile .date,
#download-page .country-profile .date,
#search-bar .country-profile .date {
  font-size: 1rem;
  min-width: 100px;
}
#main-app .single-column,
#download-page .single-column,
#search-bar .single-column {
  display: grid;
  grid-template-columns: repeat(12, minmax(0, 1fr));
  grid-auto-rows: max-content;
}
@media screen and (min-width: 768px) {
  #main-app .single-column > *,
  #download-page .single-column > *,
  #search-bar .single-column > * {
    border: 1px solid rgb(222, 222, 237);
  }
}
#main-app .compare-columns,
#download-page .compare-columns,
#search-bar .compare-columns {
  display: grid;
  grid-template-rows: repeat(5, auto);
  grid-auto-flow: column;
}
@media screen and (max-width: 640px) {
  #main-app .compare-columns,
  #download-page .compare-columns,
  #search-bar .compare-columns {
    grid-template-columns: repeat(2, 100vw);
  }
}
@media screen and (min-width: 768px) {
  #main-app .compare-columns > *,
  #download-page .compare-columns > *,
  #search-bar .compare-columns > * {
    border: 1px solid rgb(222, 222, 237);
  }
}
@media (max-width: 640px) {
  #main-app .country-profile h2,
  #download-page .country-profile h2,
  #search-bar .country-profile h2 {
    font-size: 2.5rem;
  }
  #main-app .compare-columns,
  #download-page .compare-columns,
  #search-bar .compare-columns {
    transition: transform 0.3s;
  }
  #main-app .compare-columns .country-profile,
  #download-page .compare-columns .country-profile,
  #search-bar .compare-columns .country-profile {
    width: 100vw;
    padding-right: 2rem !important;
  }
  #main-app .page-0,
  #download-page .page-0,
  #search-bar .page-0 {
    transform: translate(0);
  }
  #main-app .page-1,
  #download-page .page-1,
  #search-bar .page-1 {
    transform: translate(-100vw);
  }
  #main-app .page-2,
  #download-page .page-2,
  #search-bar .page-2 {
    transform: translate(-200vw);
  }
  #main-app .mobile-filter-trigger,
  #download-page .mobile-filter-trigger,
  #search-bar .mobile-filter-trigger {
    border: none !important;
    position: relative;
  }
  #main-app .mobile-filter-trigger:after,
  #download-page .mobile-filter-trigger:after,
  #search-bar .mobile-filter-trigger:after {
    content: "";
    display: block;
    position: absolute;
    bottom: 0;
    left: 1rem;
    right: 1rem;
    height: 2px;
    background-color: var(--bs-gray-light);
  }
  #main-app .mobile-filter-trigger[data-state=open]:after,
  #download-page .mobile-filter-trigger[data-state=open]:after,
  #search-bar .mobile-filter-trigger[data-state=open]:after {
    display: none;
  }
  #main-app .mobile-content,
  #download-page .mobile-content,
  #search-bar .mobile-content {
    padding-top: 0 !important;
    position: relative;
  }
  #main-app .mobile-content > div,
  #download-page .mobile-content > div,
  #search-bar .mobile-content > div {
    padding: 0 1rem !important;
    padding-bottom: 1rem !important;
    border: none !important;
    box-shadow: none !important;
  }
  #main-app .mobile-content > div:after,
  #download-page .mobile-content > div:after,
  #search-bar .mobile-content > div:after {
    content: "";
    display: block;
    position: absolute;
    bottom: 0;
    left: 1rem;
    right: 1rem;
    height: 2px;
    background-color: var(--bs-gray-light);
  }
  #main-app .mobile-content > div .multi-select-item:hover,
  #download-page .mobile-content > div .multi-select-item:hover,
  #search-bar .mobile-content > div .multi-select-item:hover {
    background-color: transparent !important;
  }
}
.\\*\\:\\!px-3 > * {
  padding-left: 0.75rem !important;
  padding-right: 0.75rem !important;
}
.\\*\\:px-3 > * {
  padding-left: 0.75rem;
  padding-right: 0.75rem;
}
.\\*\\:text-2xl > * {
  font-size: 36px;
}
.hover\\:bg-gray-100:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1));
}
.hover\\:\\!bg-gradient:hover {
  background-image: linear-gradient(134deg, #0565FF 0%, #8C43FF 100%) !important;
}
.hover\\:\\!bg-gradient-secondary:hover {
  background-image: linear-gradient(102deg, #0565FF 0%, #8C43FF 100%) !important;
}
.hover\\:bg-gradient:hover {
  background-image: linear-gradient(134deg, #0565FF 0%, #8C43FF 100%);
}
.hover\\:bg-gradient-secondary:hover {
  background-image: linear-gradient(102deg, #0565FF 0%, #8C43FF 100%);
}
.hover\\:\\!text-white:hover {
  --tw-text-opacity: 1 !important;
  color: rgb(255 255 255 / var(--tw-text-opacity, 1)) !important;
}
.hover\\:underline:hover {
  text-decoration-line: underline;
}
@media not all and (min-width: 768px) {
  .max-md\\:\\!flex {
    display: flex !important;
  }
  .max-md\\:py-4 {
    padding-top: 1rem;
    padding-bottom: 1rem;
  }
  .max-md\\:\\*\\:\\!pr-5 > * {
    padding-right: 1.25rem !important;
  }
  .max-md\\:\\*\\:pr-5 > * {
    padding-right: 1.25rem;
  }
}
@media not all and (min-width: 640px) {
  .max-sm\\:right-0 {
    right: 0px;
  }
  .max-sm\\:top-40 {
    top: 10rem;
  }
  .max-sm\\:col-span-1 {
    grid-column: span 1 / span 1;
  }
  .max-sm\\:flex {
    display: flex;
  }
  .max-sm\\:hidden {
    display: none;
  }
  .max-sm\\:max-h-\\[400px\\] {
    max-height: 400px;
  }
  .max-sm\\:w-full {
    width: 100%;
  }
  .max-sm\\:flex-col {
    flex-direction: column;
  }
  .max-sm\\:\\!gap-0 {
    gap: 0px !important;
  }
  .max-sm\\:gap-4 {
    gap: 1rem;
  }
  .max-sm\\:px-4 {
    padding-left: 1rem;
    padding-right: 1rem;
  }
  .max-sm\\:text-md {
    font-size: 20px;
  }
}
@media (min-width: 640px) {
  .sm\\:absolute {
    position: absolute;
  }
  .sm\\:left-\\[20px\\] {
    left: 20px;
  }
  .sm\\:col-span-3 {
    grid-column: span 3 / span 3;
  }
  .sm\\:\\!block {
    display: block !important;
  }
  .sm\\:hidden {
    display: none;
  }
  .sm\\:h-\\[50px\\] {
    height: 50px;
  }
  .sm\\:min-w-\\[295px\\] {
    min-width: 295px;
  }
  .sm\\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .sm\\:gap-x-4 {
    -moz-column-gap: 1rem;
         column-gap: 1rem;
  }
  .sm\\:\\!pl-16 {
    padding-left: 4rem !important;
  }
  .sm\\:text-xl {
    font-size: 28px;
  }
}
@media (min-width: 768px) {
  .md\\:col-span-2 {
    grid-column: span 2 / span 2;
  }
  .md\\:w-0 {
    width: 0px;
  }
  .md\\:w-max {
    width: -moz-max-content;
    width: max-content;
  }
  .md\\:max-w-\\[50\\%\\] {
    max-width: 50%;
  }
  .md\\:grid-cols-3 {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
  .md\\:grid-cols-5 {
    grid-template-columns: repeat(5, minmax(0, 1fr));
  }
  .md\\:flex-row {
    flex-direction: row;
  }
  .md\\:\\!flex-nowrap {
    flex-wrap: nowrap !important;
  }
  @media (min-width: 768px) {
    .md\\:md\\:rounded-t-lg {
      border-top-left-radius: 0.5rem;
      border-top-right-radius: 0.5rem;
    }
  }
  .md\\:rounded-t-lg {
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
  }
}
@media (min-width: 1024px) {
  .lg\\:col-span-4 {
    grid-column: span 4 / span 4;
  }
  .lg\\:col-span-8 {
    grid-column: span 8 / span 8;
  }
  .lg\\:\\!block {
    display: block !important;
  }
  .lg\\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .lg\\:grid-cols-5 {
    grid-template-columns: repeat(5, minmax(0, 1fr));
  }
  .lg\\:\\!p-10 {
    padding: 2.5rem !important;
  }
  .lg\\:\\!p-\\[3\\.25rem\\] {
    padding: 3.25rem !important;
  }
}
@media (min-width: 1280px) {
  .xl\\:grid-cols-5 {
    grid-template-columns: repeat(5, minmax(0, 1fr));
  }
  .xl\\:grid-cols-6 {
    grid-template-columns: repeat(6, minmax(0, 1fr));
  }
}/*$vite$:1*/`;
  document.head.appendChild(__vite_style__);
  var _documentCurrentScript = typeof document !== "undefined" ? document.currentScript : null;
  /**
  * @vue/shared v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map[key] = 1;
    return (val) => val in map;
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove$1 = (arr, el) => {
    const i2 = arr.indexOf(el);
    if (i2 > -1) {
      arr.splice(i2, 1);
    }
  };
  const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  const hasOwn$1 = (val, key) => hasOwnProperty$1.call(val, key);
  const isArray$1 = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isDate = (val) => toTypeString(val) === "[object Date]";
  const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString$1 = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject$3 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$3(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString = Object.prototype.toString;
  const toTypeString = (value) => objectToString.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$4 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction(
    (str) => {
      return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction(
    (str) => {
      const s2 = str ? `on${capitalize(str)}` : ``;
      return s2;
    }
  );
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i2 = 0; i2 < fns.length; i2++) {
      fns[i2](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber = (val) => {
    const n2 = parseFloat(val);
    return isNaN(n2) ? val : n2;
  };
  const toNumber = (val) => {
    const n2 = isString$1(val) ? Number(val) : NaN;
    return isNaN(n2) ? val : n2;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };
  const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
  const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
  function normalizeStyle(value) {
    if (isArray$1(value)) {
      const res = {};
      for (let i2 = 0; i2 < value.length; i2++) {
        const item = value[i2];
        const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString$1(value) || isObject$3(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString$1(value)) {
      res = value;
    } else if (isArray$1(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        const normalized = normalizeClass(value[i2]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$3(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props) {
    if (!props) return null;
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (style) {
      props.style = normalizeStyle(style);
    }
    return props;
  }
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  function looseCompareArrays(a2, b2) {
    if (a2.length !== b2.length) return false;
    let equal = true;
    for (let i2 = 0; equal && i2 < a2.length; i2++) {
      equal = looseEqual(a2[i2], b2[i2]);
    }
    return equal;
  }
  function looseEqual(a2, b2) {
    if (a2 === b2) return true;
    let aValidType = isDate(a2);
    let bValidType = isDate(b2);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
    }
    aValidType = isSymbol(a2);
    bValidType = isSymbol(b2);
    if (aValidType || bValidType) {
      return a2 === b2;
    }
    aValidType = isArray$1(a2);
    bValidType = isArray$1(b2);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
    }
    aValidType = isObject$3(a2);
    bValidType = isObject$3(b2);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a2).length;
      const bKeysCount = Object.keys(b2).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a2) {
        const aHasKey = a2.hasOwnProperty(key);
        const bHasKey = b2.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
          return false;
        }
      }
    }
    return String(a2) === String(b2);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  const isRef$1 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString = (val) => {
    return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$3(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef$1(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i2) => {
            entries[stringifySymbol(key, i2) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject$3(val) && !isArray$1(val) && !isPlainObject$4(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v2, i2 = "") => {
    var _a2;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v2) ? `Symbol(${(_a2 = v2.description) != null ? _a2 : i2})` : v2
    );
  };
  /**
  * @vue/reactivity v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      this._active = true;
      this.effects = [];
      this.cleanups = [];
      this._isPaused = false;
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = true;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].pause();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].pause();
        }
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active) {
        if (this._isPaused) {
          this._isPaused = false;
          let i2, l2;
          if (this.scopes) {
            for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
              this.scopes[i2].resume();
            }
          }
          for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
            this.effects[i2].resume();
          }
        }
      }
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        this._active = false;
        let i2, l2;
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].stop();
        }
        this.effects.length = 0;
        for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
          this.cleanups[i2]();
        }
        this.cleanups.length = 0;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].stop(true);
          }
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
      }
    }
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn, failSilently = false) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    }
  }
  let activeSub;
  const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
  class ReactiveEffect {
    constructor(fn) {
      this.fn = fn;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 1 | 4;
      this.next = void 0;
      this.cleanup = void 0;
      this.scheduler = void 0;
      if (activeEffectScope && activeEffectScope.active) {
        activeEffectScope.effects.push(this);
      }
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      if (this.flags & 64) {
        this.flags &= -65;
        if (pausedQueueEffects.has(this)) {
          pausedQueueEffects.delete(this);
          this.trigger();
        }
      }
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags & 2 && !(this.flags & 32)) {
        return;
      }
      if (!(this.flags & 8)) {
        batch(this);
      }
    }
    run() {
      if (!(this.flags & 1)) {
        return this.fn();
      }
      this.flags |= 2;
      cleanupEffect(this);
      prepareDeps(this);
      const prevEffect = activeSub;
      const prevShouldTrack = shouldTrack;
      activeSub = this;
      shouldTrack = true;
      try {
        return this.fn();
      } finally {
        cleanupDeps(this);
        activeSub = prevEffect;
        shouldTrack = prevShouldTrack;
        this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let link = this.deps; link; link = link.nextDep) {
          removeSub(link);
        }
        this.deps = this.depsTail = void 0;
        cleanupEffect(this);
        this.onStop && this.onStop();
        this.flags &= -2;
      }
    }
    trigger() {
      if (this.flags & 64) {
        pausedQueueEffects.add(this);
      } else if (this.scheduler) {
        this.scheduler();
      } else {
        this.runIfDirty();
      }
    }
    /**
     * @internal
     */
    runIfDirty() {
      if (isDirty(this)) {
        this.run();
      }
    }
    get dirty() {
      return isDirty(this);
    }
  }
  let batchDepth = 0;
  let batchedSub;
  let batchedComputed;
  function batch(sub, isComputed2 = false) {
    sub.flags |= 8;
    if (isComputed2) {
      sub.next = batchedComputed;
      batchedComputed = sub;
      return;
    }
    sub.next = batchedSub;
    batchedSub = sub;
  }
  function startBatch() {
    batchDepth++;
  }
  function endBatch() {
    if (--batchDepth > 0) {
      return;
    }
    if (batchedComputed) {
      let e2 = batchedComputed;
      batchedComputed = void 0;
      while (e2) {
        const next = e2.next;
        e2.next = void 0;
        e2.flags &= -9;
        e2 = next;
      }
    }
    let error;
    while (batchedSub) {
      let e2 = batchedSub;
      batchedSub = void 0;
      while (e2) {
        const next = e2.next;
        e2.next = void 0;
        e2.flags &= -9;
        if (e2.flags & 1) {
          try {
            ;
            e2.trigger();
          } catch (err) {
            if (!error) error = err;
          }
        }
        e2 = next;
      }
    }
    if (error) throw error;
  }
  function prepareDeps(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      link.version = -1;
      link.prevActiveLink = link.dep.activeLink;
      link.dep.activeLink = link;
    }
  }
  function cleanupDeps(sub) {
    let head;
    let tail = sub.depsTail;
    let link = tail;
    while (link) {
      const prev = link.prevDep;
      if (link.version === -1) {
        if (link === tail) tail = prev;
        removeSub(link);
        removeDep(link);
      } else {
        head = link;
      }
      link.dep.activeLink = link.prevActiveLink;
      link.prevActiveLink = void 0;
      link = prev;
    }
    sub.deps = head;
    sub.depsTail = tail;
  }
  function isDirty(sub) {
    for (let link = sub.deps; link; link = link.nextDep) {
      if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
        return true;
      }
    }
    if (sub._dirty) {
      return true;
    }
    return false;
  }
  function refreshComputed(computed2) {
    if (computed2.flags & 4 && !(computed2.flags & 16)) {
      return;
    }
    computed2.flags &= -17;
    if (computed2.globalVersion === globalVersion) {
      return;
    }
    computed2.globalVersion = globalVersion;
    const dep = computed2.dep;
    computed2.flags |= 2;
    if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
      computed2.flags &= -3;
      return;
    }
    const prevSub = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = computed2;
    shouldTrack = true;
    try {
      prepareDeps(computed2);
      const value = computed2.fn(computed2._value);
      if (dep.version === 0 || hasChanged(value, computed2._value)) {
        computed2._value = value;
        dep.version++;
      }
    } catch (err) {
      dep.version++;
      throw err;
    } finally {
      activeSub = prevSub;
      shouldTrack = prevShouldTrack;
      cleanupDeps(computed2);
      computed2.flags &= -3;
    }
  }
  function removeSub(link, soft = false) {
    const { dep, prevSub, nextSub } = link;
    if (prevSub) {
      prevSub.nextSub = nextSub;
      link.prevSub = void 0;
    }
    if (nextSub) {
      nextSub.prevSub = prevSub;
      link.nextSub = void 0;
    }
    if (dep.subs === link) {
      dep.subs = prevSub;
      if (!prevSub && dep.computed) {
        dep.computed.flags &= -5;
        for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
          removeSub(l2, true);
        }
      }
    }
    if (!soft && !--dep.sc && dep.map) {
      dep.map.delete(dep.key);
    }
  }
  function removeDep(link) {
    const { prevDep, nextDep } = link;
    if (prevDep) {
      prevDep.nextDep = nextDep;
      link.prevDep = void 0;
    }
    if (nextDep) {
      nextDep.prevDep = prevDep;
      link.nextDep = void 0;
    }
  }
  function effect(fn, options2) {
    if (fn.effect instanceof ReactiveEffect) {
      fn = fn.effect.fn;
    }
    const e2 = new ReactiveEffect(fn);
    if (options2) {
      extend(e2, options2);
    }
    try {
      e2.run();
    } catch (err) {
      e2.stop();
      throw err;
    }
    const runner = e2.run.bind(e2);
    runner.effect = e2;
    return runner;
  }
  function stop(runner) {
    runner.effect.stop();
  }
  let shouldTrack = true;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function cleanupEffect(e2) {
    const { cleanup } = e2;
    e2.cleanup = void 0;
    if (cleanup) {
      const prevSub = activeSub;
      activeSub = void 0;
      try {
        cleanup();
      } finally {
        activeSub = prevSub;
      }
    }
  }
  let globalVersion = 0;
  class Link {
    constructor(sub, dep) {
      this.sub = sub;
      this.dep = dep;
      this.version = dep.version;
      this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  }
  class Dep {
    constructor(computed2) {
      this.computed = computed2;
      this.version = 0;
      this.activeLink = void 0;
      this.subs = void 0;
      this.map = void 0;
      this.key = void 0;
      this.sc = 0;
    }
    track(debugInfo) {
      if (!activeSub || !shouldTrack || activeSub === this.computed) {
        return;
      }
      let link = this.activeLink;
      if (link === void 0 || link.sub !== activeSub) {
        link = this.activeLink = new Link(activeSub, this);
        if (!activeSub.deps) {
          activeSub.deps = activeSub.depsTail = link;
        } else {
          link.prevDep = activeSub.depsTail;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
        }
        addSub(link);
      } else if (link.version === -1) {
        link.version = this.version;
        if (link.nextDep) {
          const next = link.nextDep;
          next.prevDep = link.prevDep;
          if (link.prevDep) {
            link.prevDep.nextDep = next;
          }
          link.prevDep = activeSub.depsTail;
          link.nextDep = void 0;
          activeSub.depsTail.nextDep = link;
          activeSub.depsTail = link;
          if (activeSub.deps === link) {
            activeSub.deps = next;
          }
        }
      }
      return link;
    }
    trigger(debugInfo) {
      this.version++;
      globalVersion++;
      this.notify(debugInfo);
    }
    notify(debugInfo) {
      startBatch();
      try {
        if (false) ;
        for (let link = this.subs; link; link = link.prevSub) {
          if (link.sub.notify()) {
            ;
            link.sub.dep.notify();
          }
        }
      } finally {
        endBatch();
      }
    }
  }
  function addSub(link) {
    link.dep.sc++;
    if (link.sub.flags & 4) {
      const computed2 = link.dep.computed;
      if (computed2 && !link.dep.subs) {
        computed2.flags |= 4 | 16;
        for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
          addSub(l2);
        }
      }
      const currentTail = link.dep.subs;
      if (currentTail !== link) {
        link.prevSub = currentTail;
        if (currentTail) currentTail.nextSub = link;
      }
      link.dep.subs = link;
    }
  }
  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol(
    ""
  );
  const MAP_KEY_ITERATE_KEY = Symbol(
    ""
  );
  const ARRAY_ITERATE_KEY = Symbol(
    ""
  );
  function track(target2, type, key) {
    if (shouldTrack && activeSub) {
      let depsMap = targetMap.get(target2);
      if (!depsMap) {
        targetMap.set(target2, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = new Dep());
        dep.map = depsMap;
        dep.key = key;
      }
      {
        dep.track();
      }
    }
  }
  function trigger(target2, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target2);
    if (!depsMap) {
      globalVersion++;
      return;
    }
    const run = (dep) => {
      if (dep) {
        {
          dep.trigger();
        }
      }
    };
    startBatch();
    if (type === "clear") {
      depsMap.forEach(run);
    } else {
      const targetIsArray = isArray$1(target2);
      const isArrayIndex = targetIsArray && isIntegerKey(key);
      if (targetIsArray && key === "length") {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
            run(dep);
          }
        });
      } else {
        if (key !== void 0 || depsMap.has(void 0)) {
          run(depsMap.get(key));
        }
        if (isArrayIndex) {
          run(depsMap.get(ARRAY_ITERATE_KEY));
        }
        switch (type) {
          case "add":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target2)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isArrayIndex) {
              run(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!targetIsArray) {
              run(depsMap.get(ITERATE_KEY));
              if (isMap(target2)) {
                run(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target2)) {
              run(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
    }
    endBatch();
  }
  function getDepFromReactive(object, key) {
    const depMap = targetMap.get(object);
    return depMap && depMap.get(key);
  }
  function reactiveReadArray(array) {
    const raw2 = toRaw(array);
    if (raw2 === array) return raw2;
    track(raw2, "iterate", ARRAY_ITERATE_KEY);
    return isShallow(array) ? raw2 : raw2.map(toReactive);
  }
  function shallowReadArray(arr) {
    track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
    return arr;
  }
  const arrayInstrumentations = {
    __proto__: null,
    [Symbol.iterator]() {
      return iterator(this, Symbol.iterator, toReactive);
    },
    concat(...args) {
      return reactiveReadArray(this).concat(
        ...args.map((x2) => isArray$1(x2) ? reactiveReadArray(x2) : x2)
      );
    },
    entries() {
      return iterator(this, "entries", (value) => {
        value[1] = toReactive(value[1]);
        return value;
      });
    },
    every(fn, thisArg) {
      return apply(this, "every", fn, thisArg, void 0, arguments);
    },
    filter(fn, thisArg) {
      return apply(this, "filter", fn, thisArg, (v2) => v2.map(toReactive), arguments);
    },
    find(fn, thisArg) {
      return apply(this, "find", fn, thisArg, toReactive, arguments);
    },
    findIndex(fn, thisArg) {
      return apply(this, "findIndex", fn, thisArg, void 0, arguments);
    },
    findLast(fn, thisArg) {
      return apply(this, "findLast", fn, thisArg, toReactive, arguments);
    },
    findLastIndex(fn, thisArg) {
      return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(fn, thisArg) {
      return apply(this, "forEach", fn, thisArg, void 0, arguments);
    },
    includes(...args) {
      return searchProxy(this, "includes", args);
    },
    indexOf(...args) {
      return searchProxy(this, "indexOf", args);
    },
    join(separator) {
      return reactiveReadArray(this).join(separator);
    },
    // keys() iterator only reads `length`, no optimisation required
    lastIndexOf(...args) {
      return searchProxy(this, "lastIndexOf", args);
    },
    map(fn, thisArg) {
      return apply(this, "map", fn, thisArg, void 0, arguments);
    },
    pop() {
      return noTracking(this, "pop");
    },
    push(...args) {
      return noTracking(this, "push", args);
    },
    reduce(fn, ...args) {
      return reduce$1(this, "reduce", fn, args);
    },
    reduceRight(fn, ...args) {
      return reduce$1(this, "reduceRight", fn, args);
    },
    shift() {
      return noTracking(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(fn, thisArg) {
      return apply(this, "some", fn, thisArg, void 0, arguments);
    },
    splice(...args) {
      return noTracking(this, "splice", args);
    },
    toReversed() {
      return reactiveReadArray(this).toReversed();
    },
    toSorted(comparer) {
      return reactiveReadArray(this).toSorted(comparer);
    },
    toSpliced(...args) {
      return reactiveReadArray(this).toSpliced(...args);
    },
    unshift(...args) {
      return noTracking(this, "unshift", args);
    },
    values() {
      return iterator(this, "values", toReactive);
    }
  };
  function iterator(self2, method, wrapValue) {
    const arr = shallowReadArray(self2);
    const iter = arr[method]();
    if (arr !== self2 && !isShallow(self2)) {
      iter._next = iter.next;
      iter.next = () => {
        const result = iter._next();
        if (result.value) {
          result.value = wrapValue(result.value);
        }
        return result;
      };
    }
    return iter;
  }
  const arrayProto = Array.prototype;
  function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
    const arr = shallowReadArray(self2);
    const needsWrap = arr !== self2 && !isShallow(self2);
    const methodFn = arr[method];
    if (methodFn !== arrayProto[method]) {
      const result2 = methodFn.apply(self2, args);
      return needsWrap ? toReactive(result2) : result2;
    }
    let wrappedFn = fn;
    if (arr !== self2) {
      if (needsWrap) {
        wrappedFn = function(item, index) {
          return fn.call(this, toReactive(item), index, self2);
        };
      } else if (fn.length > 2) {
        wrappedFn = function(item, index) {
          return fn.call(this, item, index, self2);
        };
      }
    }
    const result = methodFn.call(arr, wrappedFn, thisArg);
    return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
  }
  function reduce$1(self2, method, fn, args) {
    const arr = shallowReadArray(self2);
    let wrappedFn = fn;
    if (arr !== self2) {
      if (!isShallow(self2)) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, toReactive(item), index, self2);
        };
      } else if (fn.length > 3) {
        wrappedFn = function(acc, item, index) {
          return fn.call(this, acc, item, index, self2);
        };
      }
    }
    return arr[method](wrappedFn, ...args);
  }
  function searchProxy(self2, method, args) {
    const arr = toRaw(self2);
    track(arr, "iterate", ARRAY_ITERATE_KEY);
    const res = arr[method](...args);
    if ((res === -1 || res === false) && isProxy(args[0])) {
      args[0] = toRaw(args[0]);
      return arr[method](...args);
    }
    return res;
  }
  function noTracking(self2, method, args = []) {
    pauseTracking();
    startBatch();
    const res = toRaw(self2)[method].apply(self2, args);
    endBatch();
    resetTracking();
    return res;
  }
  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
  );
  function hasOwnProperty(key) {
    if (!isSymbol(key)) key = String(key);
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _isShallow = false) {
      this._isReadonly = _isReadonly;
      this._isShallow = _isShallow;
    }
    get(target2, key, receiver) {
      if (key === "__v_skip") return target2["__v_skip"];
      const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return isShallow2;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target2) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(target2) === Object.getPrototypeOf(receiver)) {
          return target2;
        }
        return;
      }
      const targetIsArray = isArray$1(target2);
      if (!isReadonly2) {
        let fn;
        if (targetIsArray && (fn = arrayInstrumentations[key])) {
          return fn;
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty;
        }
      }
      const res = Reflect.get(
        target2,
        key,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        isRef(target2) ? target2 : receiver
      );
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target2, "get", key);
      }
      if (isShallow2) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$3(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(false, isShallow2);
    }
    set(target2, key, value, receiver) {
      let oldValue = target2[key];
      if (!this._isShallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$1(target2) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$1(target2) && isIntegerKey(key) ? Number(key) < target2.length : hasOwn$1(target2, key);
      const result = Reflect.set(
        target2,
        key,
        value,
        isRef(target2) ? target2 : receiver
      );
      if (target2 === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target2, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target2, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target2, key) {
      const hadKey = hasOwn$1(target2, key);
      target2[key];
      const result = Reflect.deleteProperty(target2, key);
      if (result && hadKey) {
        trigger(target2, "delete", key, void 0);
      }
      return result;
    }
    has(target2, key) {
      const result = Reflect.has(target2, key);
      if (!isSymbol(key) || !builtInSymbols.has(key)) {
        track(target2, "has", key);
      }
      return result;
    }
    ownKeys(target2) {
      track(
        target2,
        "iterate",
        isArray$1(target2) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target2);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(isShallow2 = false) {
      super(true, isShallow2);
    }
    set(target2, key) {
      return true;
    }
    deleteProperty(target2, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
  const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
  const toShallow = (value) => value;
  const getProto = (v2) => Reflect.getPrototypeOf(v2);
  function createIterableMethod(method, isReadonly2, isShallow2) {
    return function(...args) {
      const target2 = this["__v_raw"];
      const rawTarget = toRaw(target2);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target2[method](...args);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations(readonly2, shallow) {
    const instrumentations = {
      get(key) {
        const target2 = this["__v_raw"];
        const rawTarget = toRaw(target2);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "get", key);
          }
          track(rawTarget, "get", rawKey);
        }
        const { has } = getProto(rawTarget);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        if (has.call(rawTarget, key)) {
          return wrap(target2.get(key));
        } else if (has.call(rawTarget, rawKey)) {
          return wrap(target2.get(rawKey));
        } else if (target2 !== rawTarget) {
          target2.get(key);
        }
      },
      get size() {
        const target2 = this["__v_raw"];
        !readonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
        return Reflect.get(target2, "size", target2);
      },
      has(key) {
        const target2 = this["__v_raw"];
        const rawTarget = toRaw(target2);
        const rawKey = toRaw(key);
        if (!readonly2) {
          if (hasChanged(key, rawKey)) {
            track(rawTarget, "has", key);
          }
          track(rawTarget, "has", rawKey);
        }
        return key === rawKey ? target2.has(key) : target2.has(key) || target2.has(rawKey);
      },
      forEach(callback, thisArg) {
        const observed = this;
        const target2 = observed["__v_raw"];
        const rawTarget = toRaw(target2);
        const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
        !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target2.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      }
    };
    extend(
      instrumentations,
      readonly2 ? {
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear")
      } : {
        add(value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target2 = toRaw(this);
          const proto = getProto(target2);
          const hadKey = proto.has.call(target2, value);
          if (!hadKey) {
            target2.add(value);
            trigger(target2, "add", value, value);
          }
          return this;
        },
        set(key, value) {
          if (!shallow && !isShallow(value) && !isReadonly(value)) {
            value = toRaw(value);
          }
          const target2 = toRaw(this);
          const { has, get: get2 } = getProto(target2);
          let hadKey = has.call(target2, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target2, key);
          }
          const oldValue = get2.call(target2, key);
          target2.set(key, value);
          if (!hadKey) {
            trigger(target2, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target2, "set", key, value);
          }
          return this;
        },
        delete(key) {
          const target2 = toRaw(this);
          const { has, get: get2 } = getProto(target2);
          let hadKey = has.call(target2, key);
          if (!hadKey) {
            key = toRaw(key);
            hadKey = has.call(target2, key);
          }
          get2 ? get2.call(target2, key) : void 0;
          const result = target2.delete(key);
          if (hadKey) {
            trigger(target2, "delete", key, void 0);
          }
          return result;
        },
        clear() {
          const target2 = toRaw(this);
          const hadItems = target2.size !== 0;
          const result = target2.clear();
          if (hadItems) {
            trigger(
              target2,
              "clear",
              void 0,
              void 0
            );
          }
          return result;
        }
      }
    );
    const iteratorMethods = [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ];
    iteratorMethods.forEach((method) => {
      instrumentations[method] = createIterableMethod(method, readonly2, shallow);
    });
    return instrumentations;
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = createInstrumentations(isReadonly2, shallow);
    return (target2, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_raw") {
        return target2;
      }
      return Reflect.get(
        hasOwn$1(instrumentations, key) && key in target2 ? instrumentations : target2,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  const shallowReadonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, true)
  };
  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive(target2) {
    if (isReadonly(target2)) {
      return target2;
    }
    return createReactiveObject(
      target2,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target2) {
    return createReactiveObject(
      target2,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target2) {
    return createReactiveObject(
      target2,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function shallowReadonly(target2) {
    return createReactiveObject(
      target2,
      true,
      shallowReadonlyHandlers,
      shallowReadonlyCollectionHandlers,
      shallowReadonlyMap
    );
  }
  function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$3(target2)) {
      return target2;
    }
    if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
      return target2;
    }
    const existingProxy = proxyMap.get(target2);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target2);
    if (targetType === 0) {
      return target2;
    }
    const proxy = new Proxy(
      target2,
      targetType === 2 ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target2, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return value ? !!value["__v_raw"] : false;
  }
  function toRaw(observed) {
    const raw2 = observed && observed["__v_raw"];
    return raw2 ? toRaw(raw2) : observed;
  }
  function markRaw(value) {
    if (!hasOwn$1(value, "__v_skip") && Object.isExtensible(value)) {
      def(value, "__v_skip", true);
    }
    return value;
  }
  const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
  function isRef(r2) {
    return r2 ? r2["__v_isRef"] === true : false;
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, isShallow2) {
      this.dep = new Dep();
      this["__v_isRef"] = true;
      this["__v_isShallow"] = false;
      this._rawValue = isShallow2 ? value : toRaw(value);
      this._value = isShallow2 ? value : toReactive(value);
      this["__v_isShallow"] = isShallow2;
    }
    get value() {
      {
        this.dep.track();
      }
      return this._value;
    }
    set value(newValue) {
      const oldValue = this._rawValue;
      const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
      newValue = useDirectValue ? newValue : toRaw(newValue);
      if (hasChanged(newValue, oldValue)) {
        this._rawValue = newValue;
        this._value = useDirectValue ? newValue : toReactive(newValue);
        {
          this.dep.trigger();
        }
      }
    }
  }
  function triggerRef(ref2) {
    if (ref2.dep) {
      {
        ref2.dep.trigger();
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  function toValue$3(source) {
    return isFunction$1(source) ? source() : unref(source);
  }
  const shallowUnwrapHandlers = {
    get: (target2, key, receiver) => key === "__v_raw" ? target2 : unref(Reflect.get(target2, key, receiver)),
    set: (target2, key, value, receiver) => {
      const oldValue = target2[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target2, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class CustomRefImpl {
    constructor(factory) {
      this["__v_isRef"] = true;
      this._value = void 0;
      const dep = this.dep = new Dep();
      const { get: get2, set } = factory(dep.track.bind(dep), dep.trigger.bind(dep));
      this._get = get2;
      this._set = set;
    }
    get value() {
      return this._value = this._get();
    }
    set value(newVal) {
      this._set(newVal);
    }
  }
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    const ret = isArray$1(object) ? new Array(object.length) : {};
    for (const key in object) {
      ret[key] = propertyToRef(object, key);
    }
    return ret;
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this["__v_isRef"] = true;
      this._value = void 0;
    }
    get value() {
      const val = this._object[this._key];
      return this._value = val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this["__v_isRef"] = true;
      this["__v_isReadonly"] = true;
      this._value = void 0;
    }
    get value() {
      return this._value = this._getter();
    }
  }
  function toRef(source, key, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$1(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$3(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }
  class ComputedRefImpl {
    constructor(fn, setter, isSSR) {
      this.fn = fn;
      this.setter = setter;
      this._value = void 0;
      this.dep = new Dep(this);
      this.__v_isRef = true;
      this.deps = void 0;
      this.depsTail = void 0;
      this.flags = 16;
      this.globalVersion = globalVersion - 1;
      this.next = void 0;
      this.effect = this;
      this["__v_isReadonly"] = !setter;
      this.isSSR = isSSR;
    }
    /**
     * @internal
     */
    notify() {
      this.flags |= 16;
      if (!(this.flags & 8) && // avoid infinite self recursion
      activeSub !== this) {
        batch(this, true);
        return true;
      }
    }
    get value() {
      const link = this.dep.track();
      refreshComputed(this);
      if (link) {
        link.version = this.dep.version;
      }
      return this._value;
    }
    set value(newValue) {
      if (this.setter) {
        this.setter(newValue);
      }
    }
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    if (isFunction$1(getterOrOptions)) {
      getter = getterOrOptions;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isSSR);
    return cRef;
  }
  const TrackOpTypes = {
    "GET": "get",
    "HAS": "has",
    "ITERATE": "iterate"
  };
  const TriggerOpTypes = {
    "SET": "set",
    "ADD": "add",
    "DELETE": "delete",
    "CLEAR": "clear"
  };
  const INITIAL_WATCHER_VALUE = {};
  const cleanupMap = /* @__PURE__ */ new WeakMap();
  let activeWatcher = void 0;
  function getCurrentWatcher() {
    return activeWatcher;
  }
  function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
    if (owner) {
      let cleanups = cleanupMap.get(owner);
      if (!cleanups) cleanupMap.set(owner, cleanups = []);
      cleanups.push(cleanupFn);
    }
  }
  function watch$1(source, cb, options2 = EMPTY_OBJ) {
    const { immediate, deep, once, scheduler, augmentJob, call } = options2;
    const reactiveGetter = (source2) => {
      if (deep) return source2;
      if (isShallow(source2) || deep === false || deep === 0)
        return traverse(source2, 1);
      return traverse(source2);
    };
    let effect2;
    let getter;
    let cleanup;
    let boundCleanup;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => reactiveGetter(source);
      forceTrigger = true;
    } else if (isArray$1(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
      getter = () => source.map((s2) => {
        if (isRef(s2)) {
          return s2.value;
        } else if (isReactive(s2)) {
          return reactiveGetter(s2);
        } else if (isFunction$1(s2)) {
          return call ? call(s2, 2) : s2();
        } else ;
      });
    } else if (isFunction$1(source)) {
      if (cb) {
        getter = call ? () => call(source, 2) : source;
      } else {
        getter = () => {
          if (cleanup) {
            pauseTracking();
            try {
              cleanup();
            } finally {
              resetTracking();
            }
          }
          const currentEffect = activeWatcher;
          activeWatcher = effect2;
          try {
            return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
          } finally {
            activeWatcher = currentEffect;
          }
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      const depth = deep === true ? Infinity : deep;
      getter = () => traverse(baseGetter(), depth);
    }
    const scope = getCurrentScope();
    const watchHandle = () => {
      effect2.stop();
      if (scope && scope.active) {
        remove$1(scope.effects, effect2);
      }
    };
    if (once && cb) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        watchHandle();
      };
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = (immediateFirstRun) => {
      if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
          if (cleanup) {
            cleanup();
          }
          const currentWatcher = activeWatcher;
          activeWatcher = effect2;
          try {
            const args = [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              boundCleanup
            ];
            call ? call(cb, 3, args) : (
              // @ts-expect-error
              cb(...args)
            );
            oldValue = newValue;
          } finally {
            activeWatcher = currentWatcher;
          }
        }
      } else {
        effect2.run();
      }
    };
    if (augmentJob) {
      augmentJob(job);
    }
    effect2 = new ReactiveEffect(getter);
    effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
    boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
    cleanup = effect2.onStop = () => {
      const cleanups = cleanupMap.get(effect2);
      if (cleanups) {
        if (call) {
          call(cleanups, 4);
        } else {
          for (const cleanup2 of cleanups) cleanup2();
        }
        cleanupMap.delete(effect2);
      }
    };
    if (cb) {
      if (immediate) {
        job(true);
      } else {
        oldValue = effect2.run();
      }
    } else if (scheduler) {
      scheduler(job.bind(null, true), true);
    } else {
      effect2.run();
    }
    watchHandle.pause = effect2.pause.bind(effect2);
    watchHandle.resume = effect2.resume.bind(effect2);
    watchHandle.stop = watchHandle;
    return watchHandle;
  }
  function traverse(value, depth = Infinity, seen) {
    if (depth <= 0 || !isObject$3(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    depth--;
    if (isRef(value)) {
      traverse(value.value, depth, seen);
    } else if (isArray$1(value)) {
      for (let i2 = 0; i2 < value.length; i2++) {
        traverse(value[i2], depth, seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v2) => {
        traverse(v2, depth, seen);
      });
    } else if (isPlainObject$4(value)) {
      for (const key in value) {
        traverse(value[key], depth, seen);
      }
      for (const key of Object.getOwnPropertySymbols(value)) {
        if (Object.prototype.propertyIsEnumerable.call(value, key)) {
          traverse(value[key], depth, seen);
        }
      }
    }
    return value;
  }
  /**
  * @vue/runtime-core v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const stack = [];
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  let isWarning = false;
  function warn$1(msg, ...args) {
    if (isWarning) return;
    isWarning = true;
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          msg + args.map((a2) => {
            var _a2, _b2;
            return (_b2 = (_a2 = a2.toString) == null ? void 0 : _a2.call(a2)) != null ? _b2 : JSON.stringify(a2);
          }).join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
    isWarning = false;
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i2) => {
      logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
      vnode.component,
      vnode.type,
      isRoot
    )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw2) {
    if (isString$1(value)) {
      value = JSON.stringify(value);
      return raw2 ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw2 ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw2 ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw2 ? value : [`${key}=`, value];
    }
  }
  function assertNumber(val, type) {
    return;
  }
  const ErrorCodes = {
    "SETUP_FUNCTION": 0,
    "0": "SETUP_FUNCTION",
    "RENDER_FUNCTION": 1,
    "1": "RENDER_FUNCTION",
    "NATIVE_EVENT_HANDLER": 5,
    "5": "NATIVE_EVENT_HANDLER",
    "COMPONENT_EVENT_HANDLER": 6,
    "6": "COMPONENT_EVENT_HANDLER",
    "VNODE_HOOK": 7,
    "7": "VNODE_HOOK",
    "DIRECTIVE_HOOK": 8,
    "8": "DIRECTIVE_HOOK",
    "TRANSITION_HOOK": 9,
    "9": "TRANSITION_HOOK",
    "APP_ERROR_HANDLER": 10,
    "10": "APP_ERROR_HANDLER",
    "APP_WARN_HANDLER": 11,
    "11": "APP_WARN_HANDLER",
    "FUNCTION_REF": 12,
    "12": "FUNCTION_REF",
    "ASYNC_COMPONENT_LOADER": 13,
    "13": "ASYNC_COMPONENT_LOADER",
    "SCHEDULER": 14,
    "14": "SCHEDULER",
    "COMPONENT_UPDATE": 15,
    "15": "COMPONENT_UPDATE",
    "APP_UNMOUNT_CLEANUP": 16,
    "16": "APP_UNMOUNT_CLEANUP"
  };
  const ErrorTypeStrings$1 = {
    ["sp"]: "serverPrefetch hook",
    ["bc"]: "beforeCreate hook",
    ["c"]: "created hook",
    ["bm"]: "beforeMount hook",
    ["m"]: "mounted hook",
    ["bu"]: "beforeUpdate hook",
    ["u"]: "updated",
    ["bum"]: "beforeUnmount hook",
    ["um"]: "unmounted hook",
    ["a"]: "activated hook",
    ["da"]: "deactivated hook",
    ["ec"]: "errorCaptured hook",
    ["rtc"]: "renderTracked hook",
    ["rtg"]: "renderTriggered hook",
    [0]: "setup function",
    [1]: "render function",
    [2]: "watcher getter",
    [3]: "watcher callback",
    [4]: "watcher cleanup function",
    [5]: "native event handler",
    [6]: "component event handler",
    [7]: "vnode hook",
    [8]: "directive hook",
    [9]: "transition hook",
    [10]: "app errorHandler",
    [11]: "app warnHandler",
    [12]: "ref function",
    [13]: "async component loader",
    [14]: "scheduler flush",
    [15]: "component update",
    [16]: "app unmount cleanup function"
  };
  function callWithErrorHandling(fn, instance, type, args) {
    try {
      return args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$1(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    if (isArray$1(fn)) {
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
      }
      return values;
    }
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
            if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      if (errorHandler) {
        pauseTracking();
        callWithErrorHandling(errorHandler, null, 10, [
          err,
          exposedInstance,
          errorInfo
        ]);
        resetTracking();
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
  }
  function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
    if (throwInProd) {
      throw err;
    } else {
      console.error(err);
    }
  }
  const queue = [];
  let flushIndex = -1;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end2 = queue.length;
    while (start < end2) {
      const middle = start + end2 >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
        start = middle + 1;
      } else {
        end2 = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!(job.flags & 1)) {
      const jobId = getId(job);
      const lastJob = queue[queue.length - 1];
      if (!lastJob || // fast path when the job id is larger than the tail
      !(job.flags & 2) && jobId >= getId(lastJob)) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(jobId), 0, job);
      }
      job.flags |= 1;
      queueFlush();
    }
  }
  function queueFlush() {
    if (!currentFlushPromise) {
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$1(cb)) {
      if (activePostFlushCbs && cb.id === -1) {
        activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
      } else if (!(cb.flags & 1)) {
        pendingPostFlushCbs.push(cb);
        cb.flags |= 1;
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i2 = flushIndex + 1) {
    for (; i2 < queue.length; i2++) {
      const cb = queue[i2];
      if (cb && cb.flags & 2) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i2, 1);
        i2--;
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        cb();
        if (!(cb.flags & 4)) {
          cb.flags &= -2;
        }
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)].sort(
        (a2, b2) => getId(a2) - getId(b2)
      );
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        const cb = activePostFlushCbs[postFlushIndex];
        if (cb.flags & 4) {
          cb.flags &= -2;
        }
        if (!(cb.flags & 8)) cb();
        cb.flags &= -2;
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
  function flushJobs(seen) {
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && !(job.flags & 8)) {
          if (false) ;
          if (job.flags & 4) {
            job.flags &= ~1;
          }
          callWithErrorHandling(
            job,
            job.i,
            job.i ? 15 : 14
          );
          if (!(job.flags & 4)) {
            job.flags &= ~1;
          }
        }
      }
    } finally {
      for (; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job) {
          job.flags &= -2;
        }
      }
      flushIndex = -1;
      queue.length = 0;
      flushPostFlushCbs();
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }
  let devtools$1;
  let buffer = [];
  function setDevtoolsHook$1(hook, target2) {
    var _a2, _b2;
    devtools$1 = hook;
    if (devtools$1) {
      devtools$1.enabled = true;
      buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));
      buffer = [];
    } else if (
      // handle late devtools injection - only do this if we are in an actual
      // browser environment to avoid the timer handle stalling test runner exit
      // (#4815)
      typeof window !== "undefined" && // some envs mock window but not fully
      window.HTMLElement && // also exclude jsdom
      // eslint-disable-next-line no-restricted-syntax
      !((_b2 = (_a2 = window.navigator) == null ? void 0 : _a2.userAgent) == null ? void 0 : _b2.includes("jsdom"))
    ) {
      const replay = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = target2.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
      replay.push((newHook) => {
        setDevtoolsHook$1(newHook, target2);
      });
      setTimeout(() => {
        if (!devtools$1) {
          target2.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
          buffer = [];
        }
      }, 3e3);
    } else {
      buffer = [];
    }
  }
  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id) {
    currentScopeId = id;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  const withScopeId = (_id) => withCtx;
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx) return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function withDirectives(vnode, directives) {
    if (currentRenderingInstance === null) {
      return vnode;
    }
    const instance = getComponentPublicInstance(currentRenderingInstance);
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i2 = 0; i2 < directives.length; i2++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i2 = 0; i2 < bindings.length; i2++) {
      const binding = bindings[i2];
      if (oldBindings) {
        binding.oldValue = oldBindings[i2].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  const TeleportEndKey = Symbol("_vte");
  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
  const isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
  const isTargetMathML = (target2) => typeof MathMLElement === "function" && target2 instanceof MathMLElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString$1(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target2 = select(targetSelector);
        return target2;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled2 = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (n1 == null) {
        const placeholder = n2.el = createText("");
        const mainAnchor = n2.anchor = createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            if (parentComponent && parentComponent.isCE) {
              parentComponent.ce._teleportTarget = container2;
            }
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        };
        const mountToTarget = () => {
          const target2 = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = prepareAnchor(target2, n2, createText, insert);
          if (target2) {
            if (namespace2 !== "svg" && isTargetSVG(target2)) {
              namespace2 = "svg";
            } else if (namespace2 !== "mathml" && isTargetMathML(target2)) {
              namespace2 = "mathml";
            }
            if (!disabled2) {
              mount(target2, targetAnchor);
              updateCssVars(n2, false);
            }
          }
        };
        if (disabled2) {
          mount(container, mainAnchor);
          updateCssVars(n2, true);
        }
        if (isTeleportDeferred(n2.props)) {
          queuePostRenderEffect(() => {
            mountToTarget();
            n2.el.__isMounted = true;
          }, parentSuspense);
        } else {
          mountToTarget();
        }
      } else {
        if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
          queuePostRenderEffect(() => {
            TeleportImpl.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized,
              internals
            );
            delete n1.el.__isMounted;
          }, parentSuspense);
          return;
        }
        n2.el = n1.el;
        n2.targetStart = n1.targetStart;
        const mainAnchor = n2.anchor = n1.anchor;
        const target2 = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target2;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace2 === "svg" || isTargetSVG(target2)) {
          namespace2 = "svg";
        } else if (namespace2 === "mathml" || isTargetMathML(target2)) {
          namespace2 = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            false
          );
        }
        if (disabled2) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target2,
              targetAnchor,
              internals,
              1
            );
          }
        }
        updateCssVars(n2, disabled2);
      }
    },
    remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const {
        shapeFlag,
        children,
        anchor,
        targetStart,
        targetAnchor,
        target: target2,
        props
      } = vnode;
      if (target2) {
        hostRemove(targetStart);
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          move(
            children[i2],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector, insert, createText }
  }, hydrateChildren) {
    const target2 = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target2) {
      const disabled2 = isTeleportDisabled(vnode.props);
      const targetNode = target2._lpa || target2.firstChild;
      if (vnode.shapeFlag & 16) {
        if (disabled2) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetStart = targetNode;
          vnode.targetAnchor = targetNode && nextSibling(targetNode);
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            if (targetAnchor && targetAnchor.nodeType === 8) {
              if (targetAnchor.data === "teleport start anchor") {
                vnode.targetStart = targetAnchor;
              } else if (targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            targetAnchor = nextSibling(targetAnchor);
          }
          if (!vnode.targetAnchor) {
            prepareAnchor(target2, vnode, createText, insert);
          }
          hydrateChildren(
            targetNode && nextSibling(targetNode),
            vnode,
            target2,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode, disabled2);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode, isDisabled) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node, anchor;
      if (isDisabled) {
        node = vnode.el;
        anchor = vnode.anchor;
      } else {
        node = vnode.targetStart;
        anchor = vnode.targetAnchor;
      }
      while (node && node !== anchor) {
        if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }
  function prepareAnchor(target2, vnode, createText, insert) {
    const targetStart = vnode.targetStart = createText("");
    const targetAnchor = vnode.targetAnchor = createText("");
    targetStart[TeleportEndKey] = targetAnchor;
    if (target2) {
      insert(targetStart, target2);
      insert(targetAnchor, target2);
    }
    return targetAnchor;
  }
  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey$1 = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const recursiveGetSubtree = (instance) => {
    const subTree = instance.subTree;
    return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        const child = findNonCommentChild(children);
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getInnerChild$1(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        let enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance,
          // #11061, ensure enterHooks is fresh after clone
          (hooks) => enterHooks = hooks
        );
        if (innerChild.type !== Comment) {
          setTransitionHooks(innerChild, enterHooks);
        }
        let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
        if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
          let leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in" && innerChild.type !== Comment) {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (!(instance.job.flags & 8)) {
                instance.update();
              }
              delete leavingHooks.afterLeave;
              oldInnerChild = void 0;
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
              enterHooks.delayedLeave = () => {
                delayedLeave();
                delete enterHooks.delayedLeave;
                oldInnerChild = void 0;
              };
            };
          } else {
            oldInnerChild = void 0;
          }
        } else if (oldInnerChild) {
          oldInnerChild = void 0;
        }
        return child;
      };
    }
  };
  function findNonCommentChild(children) {
    let child = children[0];
    if (children.length > 1) {
      for (const c2 of children) {
        if (c2.type !== Comment) {
          child = c2;
          break;
        }
      }
    }
    return child;
  }
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance, postClone) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook2 = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook2(hook, args);
      if (isArray$1(hook)) {
        if (hook.every((hook2) => hook2.length <= 1)) done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook2(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey$1] = (cancelled) => {
          if (called) return;
          called = true;
          if (cancelled) {
            callHook2(cancelHook, [el]);
          } else {
            callHook2(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove2) {
        const key2 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove2();
        }
        callHook2(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called) return;
          called = true;
          remove2();
          if (cancelled) {
            callHook2(onLeaveCancelled, [el]);
          } else {
            callHook2(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        const hooks2 = resolveTransitionHooks(
          vnode2,
          props,
          state,
          instance,
          postClone
        );
        if (postClone) postClone(hooks2);
        return hooks2;
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getInnerChild$1(vnode) {
    if (!isKeepAlive(vnode)) {
      if (isTeleport(vnode.type) && vnode.children) {
        return findNonCommentChild(vnode.children);
      }
      return vnode;
    }
    const { shapeFlag, children } = vnode;
    if (children) {
      if (shapeFlag & 16) {
        return children[0];
      }
      if (shapeFlag & 32 && isFunction$1(children.default)) {
        return children.default();
      }
    }
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      vnode.transition = hooks;
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i2 = 0; i2 < children.length; i2++) {
      let child = children[i2];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
      if (child.type === Fragment) {
        if (child.patchFlag & 128) keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i2 = 0; i2 < ret.length; i2++) {
        ret[i2].patchFlag = -2;
      }
    }
    return ret;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options2, extraOptions) {
    return isFunction$1(options2) ? (
      // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend({ name: options2.name }, extraOptions, { setup: options2 }))()
    ) : options2;
  }
  function useId$1() {
    const i2 = getCurrentInstance();
    if (i2) {
      return (i2.appContext.config.idPrefix || "v") + "-" + i2.ids[0] + i2.ids[1]++;
    }
    return "";
  }
  function markAsyncBoundary(instance) {
    instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
  }
  function useTemplateRef(key) {
    const i2 = getCurrentInstance();
    const r2 = shallowRef(null);
    if (i2) {
      const refs = i2.refs === EMPTY_OBJ ? i2.refs = {} : i2.refs;
      {
        Object.defineProperty(refs, key, {
          enumerable: true,
          get: () => r2.value,
          set: (val) => r2.value = val
        });
      }
    }
    const ret = r2;
    return ret;
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$1(rawRef)) {
      rawRef.forEach(
        (r2, i2) => setRef(
          r2,
          oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
        setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
      }
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    const rawSetupState = toRaw(setupState);
    const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
      return hasOwn$1(rawSetupState, key);
    };
    if (oldRef != null && oldRef !== ref3) {
      if (isString$1(oldRef)) {
        refs[oldRef] = null;
        if (canSetSetupRef(oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value, refs]);
    } else {
      const _isString = isString$1(ref3);
      const _isRef = isRef(ref3);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
            if (isUnmount) {
              isArray$1(existing) && remove$1(existing, refValue);
            } else {
              if (!isArray$1(existing)) {
                if (_isString) {
                  refs[ref3] = [refValue];
                  if (canSetSetupRef(ref3)) {
                    setupState[ref3] = refs[ref3];
                  }
                } else {
                  ref3.value = [refValue];
                  if (rawRef.k) refs[rawRef.k] = ref3.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref3] = value;
            if (canSetSetupRef(ref3)) {
              setupState[ref3] = value;
            }
          } else if (_isRef) {
            ref3.value = value;
            if (rawRef.k) refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }
  let hasLoggedMismatchError = false;
  const logMismatchError = () => {
    if (hasLoggedMismatchError) {
      return;
    }
    console.error("Hydration completed but contains mismatches.");
    hasLoggedMismatchError = true;
  };
  const isSVGContainer = (container) => container.namespaceURI.includes("svg") && container.tagName !== "foreignObject";
  const isMathMLContainer = (container) => container.namespaceURI.includes("MathML");
  const getContainerType = (container) => {
    if (container.nodeType !== 1) return void 0;
    if (isSVGContainer(container)) return "svg";
    if (isMathMLContainer(container)) return "mathml";
    return void 0;
  };
  const isComment = (node) => node.nodeType === 8;
  function createHydrationFunctions(rendererInternals) {
    const {
      mt: mountComponent,
      p: patch,
      o: {
        patchProp: patchProp2,
        createText,
        nextSibling,
        parentNode,
        remove: remove2,
        insert,
        createComment
      }
    } = rendererInternals;
    const hydrate2 = (vnode, container) => {
      if (!container.hasChildNodes()) {
        patch(null, vnode, container);
        flushPostFlushCbs();
        container._vnode = vnode;
        return;
      }
      hydrateNode(container.firstChild, vnode, null, null, null);
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const isFragmentStart = isComment(node) && node.data === "[";
      const onMismatch = () => handleMismatch(
        node,
        vnode,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        isFragmentStart
      );
      const { type, ref: ref3, shapeFlag, patchFlag } = vnode;
      let domType = node.nodeType;
      vnode.el = node;
      if (patchFlag === -2) {
        optimized = false;
        vnode.dynamicChildren = null;
      }
      let nextNode = null;
      switch (type) {
        case Text:
          if (domType !== 3) {
            if (vnode.children === "") {
              insert(vnode.el = createText(""), parentNode(node), node);
              nextNode = node;
            } else {
              nextNode = onMismatch();
            }
          } else {
            if (node.data !== vnode.children) {
              logMismatchError();
              node.data = vnode.children;
            }
            nextNode = nextSibling(node);
          }
          break;
        case Comment:
          if (isTemplateNode(node)) {
            nextNode = nextSibling(node);
            replaceNode(
              vnode.el = node.content.firstChild,
              node,
              parentComponent
            );
          } else if (domType !== 8 || isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = nextSibling(node);
          }
          break;
        case Static:
          if (isFragmentStart) {
            node = nextSibling(node);
            domType = node.nodeType;
          }
          if (domType === 1 || domType === 3) {
            nextNode = node;
            const needToAdoptContent = !vnode.children.length;
            for (let i2 = 0; i2 < vnode.staticCount; i2++) {
              if (needToAdoptContent)
                vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
              if (i2 === vnode.staticCount - 1) {
                vnode.anchor = nextNode;
              }
              nextNode = nextSibling(nextNode);
            }
            return isFragmentStart ? nextSibling(nextNode) : nextNode;
          } else {
            onMismatch();
          }
          break;
        case Fragment:
          if (!isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateFragment(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
          break;
        default:
          if (shapeFlag & 1) {
            if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized
              );
            }
          } else if (shapeFlag & 6) {
            vnode.slotScopeIds = slotScopeIds;
            const container = parentNode(node);
            if (isFragmentStart) {
              nextNode = locateClosingAnchor(node);
            } else if (isComment(node) && node.data === "teleport start") {
              nextNode = locateClosingAnchor(node, node.data, "teleport end");
            } else {
              nextNode = nextSibling(node);
            }
            mountComponent(
              vnode,
              container,
              null,
              parentComponent,
              parentSuspense,
              getContainerType(container),
              optimized
            );
            if (isAsyncWrapper(vnode) && !vnode.type.__asyncResolved) {
              let subTree;
              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
              }
              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64) {
            if (domType !== 8) {
              nextNode = onMismatch();
            } else {
              nextNode = vnode.type.hydrate(
                node,
                vnode,
                parentComponent,
                parentSuspense,
                slotScopeIds,
                optimized,
                rendererInternals,
                hydrateChildren
              );
            }
          } else if (shapeFlag & 128) {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              getContainerType(parentNode(node)),
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateNode
            );
          } else ;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode);
      }
      return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;
      const forcePatch = type === "input" || type === "option";
      if (forcePatch || patchFlag !== -1) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        let needCallTransitionHooks = false;
        if (isTemplateNode(el)) {
          needCallTransitionHooks = needTransition(
            null,
            // no need check parentSuspense in hydration
            transition
          ) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
          const content = el.content.firstChild;
          if (needCallTransitionHooks) {
            transition.beforeEnter(content);
          }
          replaceNode(content, el, parentComponent);
          vnode.el = el = content;
        }
        if (shapeFlag & 16 && // skip if element has innerHTML / textContent
        !(props && (props.innerHTML || props.textContent))) {
          let next = hydrateChildren(
            el.firstChild,
            vnode,
            el,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          while (next) {
            if (!isMismatchAllowed(
              el,
              1
              /* CHILDREN */
            )) {
              logMismatchError();
            }
            const cur = next;
            next = next.nextSibling;
            remove2(cur);
          }
        } else if (shapeFlag & 8) {
          let clientText = vnode.children;
          if (clientText[0] === "\n" && (el.tagName === "PRE" || el.tagName === "TEXTAREA")) {
            clientText = clientText.slice(1);
          }
          if (el.textContent !== clientText) {
            if (!isMismatchAllowed(
              el,
              0
              /* TEXT */
            )) {
              logMismatchError();
            }
            el.textContent = vnode.children;
          }
        }
        if (props) {
          if (forcePatch || !optimized || patchFlag & (16 | 32)) {
            const isCustomElement = el.tagName.includes("-");
            for (const key in props) {
              if (forcePatch && (key.endsWith("value") || key === "indeterminate") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers
              key[0] === "." || isCustomElement) {
                patchProp2(el, key, null, props[key], void 0, parentComponent);
              }
            }
          } else if (props.onClick) {
            patchProp2(
              el,
              "onClick",
              null,
              props.onClick,
              void 0,
              parentComponent
            );
          } else if (patchFlag & 4 && isReactive(props.style)) {
            for (const key in props.style) props.style[key];
          }
        }
        let vnodeHooks;
        if (vnodeHooks = props && props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {
          queueEffectWithSuspense(() => {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      }
      return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!parentVNode.dynamicChildren;
      const children = parentVNode.children;
      const l2 = children.length;
      for (let i2 = 0; i2 < l2; i2++) {
        const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
        const isText = vnode.type === Text;
        if (node) {
          if (isText && !optimized) {
            if (i2 + 1 < l2 && normalizeVNode(children[i2 + 1]).type === Text) {
              insert(
                createText(
                  node.data.slice(vnode.children.length)
                ),
                container,
                nextSibling(node)
              );
              node.data = vnode.children;
            }
          }
          node = hydrateNode(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        } else if (isText && !vnode.children) {
          insert(vnode.el = createText(""), container);
        } else {
          if (!isMismatchAllowed(
            container,
            1
            /* CHILDREN */
          )) {
            logMismatchError();
          }
          patch(
            null,
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            getContainerType(container),
            slotScopeIds
          );
        }
      }
      return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      const { slotScopeIds: fragmentSlotScopeIds } = vnode;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      const container = parentNode(node);
      const next = hydrateChildren(
        nextSibling(node),
        vnode,
        container,
        parentComponent,
        parentSuspense,
        slotScopeIds,
        optimized
      );
      if (next && isComment(next) && next.data === "]") {
        return nextSibling(vnode.anchor = next);
      } else {
        logMismatchError();
        insert(vnode.anchor = createComment(`]`), container, next);
        return next;
      }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
      if (!isMismatchAllowed(
        node.parentElement,
        1
        /* CHILDREN */
      )) {
        logMismatchError();
      }
      vnode.el = null;
      if (isFragment) {
        const end2 = locateClosingAnchor(node);
        while (true) {
          const next2 = nextSibling(node);
          if (next2 && next2 !== end2) {
            remove2(next2);
          } else {
            break;
          }
        }
      }
      const next = nextSibling(node);
      const container = parentNode(node);
      remove2(node);
      patch(
        null,
        vnode,
        container,
        next,
        parentComponent,
        parentSuspense,
        getContainerType(container),
        slotScopeIds
      );
      if (parentComponent) {
        parentComponent.vnode.el = vnode.el;
        updateHOCHostEl(parentComponent, vnode.el);
      }
      return next;
    };
    const locateClosingAnchor = (node, open = "[", close = "]") => {
      let match = 0;
      while (node) {
        node = nextSibling(node);
        if (node && isComment(node)) {
          if (node.data === open) match++;
          if (node.data === close) {
            if (match === 0) {
              return nextSibling(node);
            } else {
              match--;
            }
          }
        }
      }
      return node;
    };
    const replaceNode = (newNode, oldNode, parentComponent) => {
      const parentNode2 = oldNode.parentNode;
      if (parentNode2) {
        parentNode2.replaceChild(newNode, oldNode);
      }
      let parent = parentComponent;
      while (parent) {
        if (parent.vnode.el === oldNode) {
          parent.vnode.el = parent.subTree.el = newNode;
        }
        parent = parent.parent;
      }
    };
    const isTemplateNode = (node) => {
      return node.nodeType === 1 && node.tagName === "TEMPLATE";
    };
    return [hydrate2, hydrateNode];
  }
  const allowMismatchAttr = "data-allow-mismatch";
  const MismatchTypeString = {
    [
      0
      /* TEXT */
    ]: "text",
    [
      1
      /* CHILDREN */
    ]: "children",
    [
      2
      /* CLASS */
    ]: "class",
    [
      3
      /* STYLE */
    ]: "style",
    [
      4
      /* ATTRIBUTE */
    ]: "attribute"
  };
  function isMismatchAllowed(el, allowedType) {
    if (allowedType === 0 || allowedType === 1) {
      while (el && !el.hasAttribute(allowMismatchAttr)) {
        el = el.parentElement;
      }
    }
    const allowedAttr = el && el.getAttribute(allowMismatchAttr);
    if (allowedAttr == null) {
      return false;
    } else if (allowedAttr === "") {
      return true;
    } else {
      const list = allowedAttr.split(",");
      if (allowedType === 0 && list.includes("children")) {
        return true;
      }
      return allowedAttr.split(",").includes(MismatchTypeString[allowedType]);
    }
  }
  const requestIdleCallback$1 = getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
  const cancelIdleCallback = getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
  const hydrateOnIdle = (timeout = 1e4) => (hydrate2) => {
    const id = requestIdleCallback$1(hydrate2, { timeout });
    return () => cancelIdleCallback(id);
  };
  function elementIsVisibleInViewport(el) {
    const { top, left, bottom, right } = el.getBoundingClientRect();
    const { innerHeight, innerWidth } = window;
    return (top > 0 && top < innerHeight || bottom > 0 && bottom < innerHeight) && (left > 0 && left < innerWidth || right > 0 && right < innerWidth);
  }
  const hydrateOnVisible = (opts) => (hydrate2, forEach2) => {
    const ob = new IntersectionObserver((entries) => {
      for (const e2 of entries) {
        if (!e2.isIntersecting) continue;
        ob.disconnect();
        hydrate2();
        break;
      }
    }, opts);
    forEach2((el) => {
      if (!(el instanceof Element)) return;
      if (elementIsVisibleInViewport(el)) {
        hydrate2();
        ob.disconnect();
        return false;
      }
      ob.observe(el);
    });
    return () => ob.disconnect();
  };
  const hydrateOnMediaQuery = (query) => (hydrate2) => {
    if (query) {
      const mql = matchMedia(query);
      if (mql.matches) {
        hydrate2();
      } else {
        mql.addEventListener("change", hydrate2, { once: true });
        return () => mql.removeEventListener("change", hydrate2);
      }
    }
  };
  const hydrateOnInteraction = (interactions = []) => (hydrate2, forEach2) => {
    if (isString$1(interactions)) interactions = [interactions];
    let hasHydrated = false;
    const doHydrate = (e2) => {
      if (!hasHydrated) {
        hasHydrated = true;
        teardown();
        hydrate2();
        e2.target.dispatchEvent(new e2.constructor(e2.type, e2));
      }
    };
    const teardown = () => {
      forEach2((el) => {
        for (const i2 of interactions) {
          el.removeEventListener(i2, doHydrate);
        }
      });
    };
    forEach2((el) => {
      for (const i2 of interactions) {
        el.addEventListener(i2, doHydrate, { once: true });
      }
    });
    return teardown;
  };
  function forEachElement(node, cb) {
    if (isComment(node) && node.data === "[") {
      let depth = 1;
      let next = node.nextSibling;
      while (next) {
        if (next.nodeType === 1) {
          const result = cb(next);
          if (result === false) {
            break;
          }
        } else if (isComment(next)) {
          if (next.data === "]") {
            if (--depth === 0) break;
          } else if (next.data === "[") {
            depth++;
          }
        }
        next = next.nextSibling;
      }
    } else {
      cb(node);
    }
  }
  const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineAsyncComponent(source) {
    if (isFunction$1(source)) {
      source = { loader: source };
    }
    const {
      loader,
      loadingComponent,
      errorComponent,
      delay = 200,
      hydrate: hydrateStrategy,
      timeout,
      // undefined = never times out
      suspensible = true,
      onError: userOnError
    } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
      retries++;
      pendingRequest = null;
      return load();
    };
    const load = () => {
      let thisRequest;
      return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
        err = err instanceof Error ? err : new Error(String(err));
        if (userOnError) {
          return new Promise((resolve2, reject) => {
            const userRetry = () => resolve2(retry());
            const userFail = () => reject(err);
            userOnError(err, userRetry, userFail, retries + 1);
          });
        } else {
          throw err;
        }
      }).then((comp) => {
        if (thisRequest !== pendingRequest && pendingRequest) {
          return pendingRequest;
        }
        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
          comp = comp.default;
        }
        resolvedComp = comp;
        return comp;
      }));
    };
    return /* @__PURE__ */ defineComponent({
      name: "AsyncComponentWrapper",
      __asyncLoader: load,
      __asyncHydrate(el, instance, hydrate2) {
        const doHydrate = hydrateStrategy ? () => {
          const teardown = hydrateStrategy(
            hydrate2,
            (cb) => forEachElement(el, cb)
          );
          if (teardown) {
            (instance.bum || (instance.bum = [])).push(teardown);
          }
        } : hydrate2;
        if (resolvedComp) {
          doHydrate();
        } else {
          load().then(() => !instance.isUnmounted && doHydrate());
        }
      },
      get __asyncResolved() {
        return resolvedComp;
      },
      setup() {
        const instance = currentInstance;
        markAsyncBoundary(instance);
        if (resolvedComp) {
          return () => createInnerComp(resolvedComp, instance);
        }
        const onError = (err) => {
          pendingRequest = null;
          handleError(
            err,
            instance,
            13,
            !errorComponent
          );
        };
        if (suspensible && instance.suspense || isInSSRComponentSetup) {
          return load().then((comp) => {
            return () => createInnerComp(comp, instance);
          }).catch((err) => {
            onError(err);
            return () => errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          });
        }
        const loaded2 = ref(false);
        const error = ref();
        const delayed = ref(!!delay);
        if (delay) {
          setTimeout(() => {
            delayed.value = false;
          }, delay);
        }
        if (timeout != null) {
          setTimeout(() => {
            if (!loaded2.value && !error.value) {
              const err = new Error(
                `Async component timed out after ${timeout}ms.`
              );
              onError(err);
              error.value = err;
            }
          }, timeout);
        }
        load().then(() => {
          loaded2.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            instance.parent.update();
          }
        }).catch((err) => {
          onError(err);
          error.value = err;
        });
        return () => {
          if (loaded2.value && resolvedComp) {
            return createInnerComp(resolvedComp, instance);
          } else if (error.value && errorComponent) {
            return createVNode(errorComponent, {
              error: error.value
            });
          } else if (loadingComponent && !delayed.value) {
            return createVNode(loadingComponent);
          }
        };
      }
    });
  }
  function createInnerComp(comp, parent) {
    const { ref: ref22, props, children, ce } = parent.vnode;
    const vnode = createVNode(comp, props, children);
    vnode.ref = ref22;
    vnode.ce = ce;
    delete parent.vnode.ce;
    return vnode;
  }
  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  const KeepAliveImpl = {
    name: `KeepAlive`,
    // Marker for special handling inside the renderer. We are not using a ===
    // check directly on KeepAlive in the renderer, because importing it directly
    // would prevent it from being tree-shaken.
    __isKeepAlive: true,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number]
    },
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const sharedContext = instance.ctx;
      if (!sharedContext.renderer) {
        return () => {
          const children = slots.default && slots.default();
          return children && children.length === 1 ? children[0] : children;
        };
      }
      const cache = /* @__PURE__ */ new Map();
      const keys = /* @__PURE__ */ new Set();
      let current = null;
      const parentSuspense = instance.suspense;
      const {
        renderer: {
          p: patch,
          m: move,
          um: _unmount,
          o: { createElement: createElement2 }
        }
      } = sharedContext;
      const storageContainer = createElement2("div");
      sharedContext.activate = (vnode, container, anchor, namespace2, optimized) => {
        const instance2 = vnode.component;
        move(vnode, container, anchor, 0, parentSuspense);
        patch(
          instance2.vnode,
          vnode,
          container,
          anchor,
          instance2,
          parentSuspense,
          namespace2,
          vnode.slotScopeIds,
          optimized
        );
        queuePostRenderEffect(() => {
          instance2.isDeactivated = false;
          if (instance2.a) {
            invokeArrayFns(instance2.a);
          }
          const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
          if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance2.parent, vnode);
          }
        }, parentSuspense);
      };
      sharedContext.deactivate = (vnode) => {
        const instance2 = vnode.component;
        invalidateMount(instance2.m);
        invalidateMount(instance2.a);
        move(vnode, storageContainer, null, 1, parentSuspense);
        queuePostRenderEffect(() => {
          if (instance2.da) {
            invokeArrayFns(instance2.da);
          }
          const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
          if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance2.parent, vnode);
          }
          instance2.isDeactivated = true;
        }, parentSuspense);
      };
      function unmount(vnode) {
        resetShapeFlag(vnode);
        _unmount(vnode, instance, parentSuspense, true);
      }
      function pruneCache(filter) {
        cache.forEach((vnode, key) => {
          const name = getComponentName(vnode.type);
          if (name && !filter(name)) {
            pruneCacheEntry(key);
          }
        });
      }
      function pruneCacheEntry(key) {
        const cached = cache.get(key);
        if (cached && (!current || !isSameVNodeType(cached, current))) {
          unmount(cached);
        } else if (current) {
          resetShapeFlag(current);
        }
        cache.delete(key);
        keys.delete(key);
      }
      watch(
        () => [props.include, props.exclude],
        ([include, exclude]) => {
          include && pruneCache((name) => matches(include, name));
          exclude && pruneCache((name) => !matches(exclude, name));
        },
        // prune post-render after `current` has been updated
        { flush: "post", deep: true }
      );
      let pendingCacheKey = null;
      const cacheSubtree = () => {
        if (pendingCacheKey != null) {
          if (isSuspense(instance.subTree.type)) {
            queuePostRenderEffect(() => {
              cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }, instance.subTree.suspense);
          } else {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree));
          }
        }
      };
      onMounted(cacheSubtree);
      onUpdated(cacheSubtree);
      onBeforeUnmount(() => {
        cache.forEach((cached) => {
          const { subTree, suspense } = instance;
          const vnode = getInnerChild(subTree);
          if (cached.type === vnode.type && cached.key === vnode.key) {
            resetShapeFlag(vnode);
            const da = vnode.component.da;
            da && queuePostRenderEffect(da, suspense);
            return;
          }
          unmount(cached);
        });
      });
      return () => {
        pendingCacheKey = null;
        if (!slots.default) {
          return current = null;
        }
        const children = slots.default();
        const rawVNode = children[0];
        if (children.length > 1) {
          current = null;
          return children;
        } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
          current = null;
          return rawVNode;
        }
        let vnode = getInnerChild(rawVNode);
        if (vnode.type === Comment) {
          current = null;
          return vnode;
        }
        const comp = vnode.type;
        const name = getComponentName(
          isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
        );
        const { include, exclude, max: max2 } = props;
        if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
          vnode.shapeFlag &= -257;
          current = vnode;
          return rawVNode;
        }
        const key = vnode.key == null ? comp : vnode.key;
        const cachedVNode = cache.get(key);
        if (vnode.el) {
          vnode = cloneVNode(vnode);
          if (rawVNode.shapeFlag & 128) {
            rawVNode.ssContent = vnode;
          }
        }
        pendingCacheKey = key;
        if (cachedVNode) {
          vnode.el = cachedVNode.el;
          vnode.component = cachedVNode.component;
          if (vnode.transition) {
            setTransitionHooks(vnode, vnode.transition);
          }
          vnode.shapeFlag |= 512;
          keys.delete(key);
          keys.add(key);
        } else {
          keys.add(key);
          if (max2 && keys.size > parseInt(max2, 10)) {
            pruneCacheEntry(keys.values().next().value);
          }
        }
        vnode.shapeFlag |= 256;
        current = vnode;
        return isSuspense(rawVNode.type) ? rawVNode : vnode;
      };
    }
  };
  const KeepAlive = KeepAliveImpl;
  function matches(pattern, name) {
    if (isArray$1(pattern)) {
      return pattern.some((p2) => matches(p2, name));
    } else if (isString$1(pattern)) {
      return pattern.split(",").includes(name);
    } else if (isRegExp(pattern)) {
      pattern.lastIndex = 0;
      return pattern.test(name);
    }
    return false;
  }
  function onActivated(hook, target2) {
    registerKeepAliveHook(hook, "a", target2);
  }
  function onDeactivated(hook, target2) {
    registerKeepAliveHook(hook, "da", target2);
  }
  function registerKeepAliveHook(hook, type, target2 = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target2;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target2);
    if (target2) {
      let current = target2.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target2, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target2, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove$1(keepAliveRoot[type], injected);
    }, target2);
  }
  function resetShapeFlag(vnode) {
    vnode.shapeFlag &= -257;
    vnode.shapeFlag &= -513;
  }
  function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
  }
  function injectHook(type, hook, target2 = currentInstance, prepend = false) {
    if (target2) {
      const hooks = target2[type] || (target2[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        pauseTracking();
        const reset = setCurrentInstance(target2);
        const res = callWithAsyncErrorHandling(hook, target2, type, args);
        reset();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target2 = currentInstance) => {
    if (!isInSSRComponentSetup || lifecycle === "sp") {
      injectHook(lifecycle, (...args) => hook(...args), target2);
    }
  };
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook(
    "bu"
  );
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook(
    "bum"
  );
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook(
    "sp"
  );
  const onRenderTriggered = createHook("rtg");
  const onRenderTracked = createHook("rtc");
  function onErrorCaptured(hook, target2 = currentInstance) {
    injectHook("ec", hook, target2);
  }
  const COMPONENTS = "components";
  const DIRECTIVES = "directives";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveDynamicComponent(component) {
    if (isString$1(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    const sourceIsArray = isArray$1(source);
    if (sourceIsArray || isString$1(source)) {
      const sourceIsReactiveArray = sourceIsArray && isReactive(source);
      let needsWrap = false;
      if (sourceIsReactiveArray) {
        needsWrap = !isShallow(source);
        source = shallowReadArray(source);
      }
      ret = new Array(source.length);
      for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
        ret[i2] = renderItem(
          needsWrap ? toReactive(source[i2]) : source[i2],
          i2,
          void 0,
          cached && cached[i2]
        );
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i2 = 0; i2 < source; i2++) {
        ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
      }
    } else if (isObject$3(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
        );
      } else {
        const keys = Object.keys(source);
        ret = new Array(keys.length);
        for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
          const key = keys[i2];
          ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index] = ret;
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
      const slot = dynamicSlots[i2];
      if (isArray$1(slot)) {
        for (let j2 = 0; j2 < slot.length; j2++) {
          slots[slot[j2].name] = slot[j2].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.key ? (...args) => {
          const res = slot.fn(...args);
          if (res) res.key = slot.key;
          return res;
        } : slot.fn;
      }
    }
    return slots;
  }
  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
      if (name !== "default") props.name = name;
      return openBlock(), createBlock(
        Fragment,
        null,
        [createVNode("slot", props, fallback && fallback())],
        64
      );
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props));
    const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    validSlotContent && validSlotContent.key;
    const rendered = createBlock(
      Fragment,
      {
        key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
        (!validSlotContent && fallback ? "_fb" : "")
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child)) return true;
      if (child.type === Comment) return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  function toHandlers(obj, preserveCaseIfNecessary) {
    const ret = {};
    for (const key in obj) {
      ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
    }
    return ret;
  }
  const getPublicInstance = (i2) => {
    if (!i2) return null;
    if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
    return getPublicInstance(i2.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i2) => i2,
      $el: (i2) => i2.vnode.el,
      $data: (i2) => i2.data,
      $props: (i2) => i2.props,
      $attrs: (i2) => i2.attrs,
      $slots: (i2) => i2.slots,
      $refs: (i2) => i2.refs,
      $parent: (i2) => getPublicInstance(i2.parent),
      $root: (i2) => getPublicInstance(i2.root),
      $host: (i2) => i2.ce,
      $emit: (i2) => i2.emit,
      $options: (i2) => resolveMergedOptions(i2),
      $forceUpdate: (i2) => i2.f || (i2.f = () => {
        queueJob(i2.update);
      }),
      $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
      $watch: (i2) => instanceWatch.bind(i2)
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      if (key === "__v_skip") {
        return true;
      }
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n2 = accessCache[key];
        if (n2 !== void 0) {
          switch (n2) {
            case 1:
              return setupState[key];
            case 2:
              return data[key];
            case 4:
              return ctx[key];
            case 3:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
          accessCache[key] = 2;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
        ) {
          accessCache[key] = 3;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (shouldCacheAccess) {
          accessCache[key] = 0;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance.attrs, "get", "");
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn$1(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
    },
    defineProperty(target2, key, descriptor) {
      if (descriptor.get != null) {
        target2._.accessCache[key] = 0;
      } else if (hasOwn$1(descriptor, "value")) {
        this.set(target2, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target2, key, descriptor);
    }
  };
  const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
    get(target2, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target2, key, target2);
    },
    has(_2, key) {
      const has = key[0] !== "_" && !isGloballyAllowed(key);
      return has;
    }
  });
  function defineProps() {
    return null;
  }
  function defineEmits() {
    return null;
  }
  function defineExpose(exposed) {
  }
  function defineOptions(options2) {
  }
  function defineSlots() {
    return null;
  }
  function defineModel() {
  }
  function withDefaults(props, defaults) {
    return null;
  }
  function useSlots() {
    return getContext().slots;
  }
  function useAttrs() {
    return getContext().attrs;
  }
  function getContext() {
    const i2 = getCurrentInstance();
    return i2.setupContext || (i2.setupContext = createSetupContext(i2));
  }
  function normalizePropsOrEmits(props) {
    return isArray$1(props) ? props.reduce(
      (normalized, p2) => (normalized[p2] = null, normalized),
      {}
    ) : props;
  }
  function mergeDefaults(raw2, defaults) {
    const props = normalizePropsOrEmits(raw2);
    for (const key in defaults) {
      if (key.startsWith("__skip")) continue;
      let opt = props[key];
      if (opt) {
        if (isArray$1(opt) || isFunction$1(opt)) {
          opt = props[key] = { type: opt, default: defaults[key] };
        } else {
          opt.default = defaults[key];
        }
      } else if (opt === null) {
        opt = props[key] = { default: defaults[key] };
      } else ;
      if (opt && defaults[`__skip_${key}`]) {
        opt.skipFactory = true;
      }
    }
    return props;
  }
  function mergeModels(a2, b2) {
    if (!a2 || !b2) return a2 || b2;
    if (isArray$1(a2) && isArray$1(b2)) return a2.concat(b2);
    return extend({}, normalizePropsOrEmits(a2), normalizePropsOrEmits(b2));
  }
  function createPropsRestProxy(props, excludedKeys) {
    const ret = {};
    for (const key in props) {
      if (!excludedKeys.includes(key)) {
        Object.defineProperty(ret, key, {
          enumerable: true,
          get: () => props[key]
        });
      }
    }
    return ret;
  }
  function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise(awaitable)) {
      awaitable = awaitable.catch((e2) => {
        setCurrentInstance(ctx);
        throw e2;
      });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options2 = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options2.beforeCreate) {
      callHook$1(options2.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render2,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options2;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$1(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$3(data)) ;
      else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c2 = computed({
          get: get2,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c2.value,
          set: (v2) => c2.value = v2
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register2, hook) {
      if (isArray$1(hook)) {
        hook.forEach((_hook) => register2(_hook.bind(publicThis)));
      } else if (hook) {
        register2(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$1(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render2 && instance.render === NOOP) {
      instance.render = render2;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components) instance.components = components;
    if (directives) instance.directives = directives;
    if (serverPrefetch) {
      markAsyncBoundary(instance);
    }
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$1(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$3(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw2, ctx, publicThis, key) {
    let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString$1(raw2)) {
      const handler = ctx[raw2];
      if (isFunction$1(handler)) {
        {
          watch(getter, handler);
        }
      }
    } else if (isFunction$1(raw2)) {
      {
        watch(getter, raw2.bind(publicThis));
      }
    } else if (isObject$3(raw2)) {
      if (isArray$1(raw2)) {
        raw2.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
      } else {
        const handler = isFunction$1(raw2.handler) ? raw2.handler.bind(publicThis) : ctx[raw2.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw2);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$3(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to2, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to2, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m2) => mergeOptions(to2, m2, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ;
      else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to2[key] = strat ? strat(to2[key], from[key]) : from[key];
      }
    }
    return to2;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to2, from) {
    if (!from) {
      return to2;
    }
    if (!to2) {
      return from;
    }
    return function mergedDataFn() {
      return extend(
        isFunction$1(to2) ? to2.call(this, this) : to2,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to2, from) {
    return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
  }
  function normalizeInject(raw2) {
    if (isArray$1(raw2)) {
      const res = {};
      for (let i2 = 0; i2 < raw2.length; i2++) {
        res[raw2[i2]] = raw2[i2];
      }
      return res;
    }
    return raw2;
  }
  function mergeAsArray(to2, from) {
    return to2 ? [...new Set([].concat(to2, from))] : from;
  }
  function mergeObjectOptions(to2, from) {
    return to2 ? extend(/* @__PURE__ */ Object.create(null), to2, from) : from;
  }
  function mergeEmitsOrPropsOptions(to2, from) {
    if (to2) {
      if (isArray$1(to2) && isArray$1(from)) {
        return [.../* @__PURE__ */ new Set([...to2, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to2),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to2, from) {
    if (!to2) return from;
    if (!from) return to2;
    const merged = extend(/* @__PURE__ */ Object.create(null), to2);
    for (const key in from) {
      merged[key] = mergeAsArray(to2[key], from[key]);
    }
    return merged;
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render2, hydrate2) {
    return function createApp2(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject$3(rootProps)) {
        rootProps = null;
      }
      const context2 = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      const pluginCleanupFns = [];
      let isMounted = false;
      const app = context2.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context2,
        _instance: null,
        version,
        get config() {
          return context2.config;
        },
        set config(v2) {
        },
        use(plugin, ...options2) {
          if (installedPlugins.has(plugin)) ;
          else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options2);
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options2);
          } else ;
          return app;
        },
        mixin(mixin) {
          {
            if (!context2.mixins.includes(mixin)) {
              context2.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context2.components[name];
          }
          context2.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context2.directives[name];
          }
          context2.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace2) {
          if (!isMounted) {
            const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
            vnode.appContext = context2;
            if (namespace2 === true) {
              namespace2 = "svg";
            } else if (namespace2 === false) {
              namespace2 = void 0;
            }
            if (isHydrate && hydrate2) {
              hydrate2(vnode, rootContainer);
            } else {
              render2(vnode, rootContainer, namespace2);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getComponentPublicInstance(vnode.component);
          }
        },
        onUnmount(cleanupFn) {
          pluginCleanupFns.push(cleanupFn);
        },
        unmount() {
          if (isMounted) {
            callWithAsyncErrorHandling(
              pluginCleanupFns,
              app._instance,
              16
            );
            render2(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context2.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          const lastApp = currentApp;
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = lastApp;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;
  function provide(key, value) {
    if (!currentInstance) ;
    else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }
  function hasInjectionContext() {
    return !!(currentInstance || currentRenderingInstance || currentApp);
  }
  const internalObjectProto = {};
  const createInternalObject = () => Object.create(internalObjectProto);
  const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs2 = createInternalObject();
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs2);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs2;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs2;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs: attrs2,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options2] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
          let key = propsToUpdate[i2];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options2) {
            if (hasOwn$1(attrs2, key)) {
              if (value !== attrs2[key]) {
                attrs2[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options2,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs2[key]) {
              attrs2[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs2)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
          if (options2) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options2,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs2 !== rawCurrentProps) {
        for (const key in attrs2) {
          if (!rawProps || !hasOwn$1(rawProps, key) && true) {
            delete attrs2[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance.attrs, "set", "");
    }
  }
  function setFullProps(instance, rawProps, props, attrs2) {
    const [options2, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options2 && hasOwn$1(options2, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs2) || value !== attrs2[key]) {
            attrs2[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i2 = 0; i2 < needCastKeys.length; i2++) {
        const key = needCastKeys[i2];
        props[key] = resolvePropValue(
          options2,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn$1(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options2, props, key, value, instance, isAbsent) {
    const opt = options2[key];
    if (opt != null) {
      const hasDefault = hasOwn$1(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            const reset = setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            reset();
          }
        } else {
          value = defaultValue;
        }
        if (instance.ce) {
          instance.ce._setProp(key, value);
        }
      }
      if (opt[
        0
        /* shouldCast */
      ]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[
          1
          /* shouldCastTrue */
        ] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  const mixinPropsCache = /* @__PURE__ */ new WeakMap();
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = asMixin ? mixinPropsCache : appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw2 = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendProps = (raw22) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw22, appContext, true);
        extend(normalized, props);
        if (keys) needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw2 && !hasExtends) {
      if (isObject$3(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$1(raw2)) {
      for (let i2 = 0; i2 < raw2.length; i2++) {
        const normalizedKey = camelize(raw2[i2]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw2) {
      for (const key in raw2) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw2[key];
          const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
          const propType = prop.type;
          let shouldCast = false;
          let shouldCastTrue = true;
          if (isArray$1(propType)) {
            for (let index = 0; index < propType.length; ++index) {
              const type = propType[index];
              const typeName = isFunction$1(type) && type.name;
              if (typeName === "Boolean") {
                shouldCast = true;
                break;
              } else if (typeName === "String") {
                shouldCastTrue = false;
              }
            }
          } else {
            shouldCast = isFunction$1(propType) && propType.name === "Boolean";
          }
          prop[
            0
            /* shouldCast */
          ] = shouldCast;
          prop[
            1
            /* shouldCastTrue */
          ] = shouldCastTrue;
          if (shouldCast || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$3(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$" && !isReservedProp(key)) {
      return true;
    }
    return false;
  }
  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (false) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key)) continue;
      const value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const assignSlots = (slots, children, optimized) => {
    for (const key in children) {
      if (optimized || key !== "_") {
        slots[key] = children[key];
      }
    }
  };
  const initSlots = (instance, children, optimized) => {
    const slots = instance.slots = createInternalObject();
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        assignSlots(slots, children, optimized);
        if (optimized) {
          def(slots, "_", type, true);
        }
      } else {
        normalizeObjectSlots(children, slots);
      }
    } else if (children) {
      normalizeVNodeSlots(instance, children);
    }
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          assignSlots(slots, children, optimized);
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };
  const queuePostRenderEffect = queueEffectWithSuspense;
  function createRenderer(options2) {
    return baseCreateRenderer(options2);
  }
  function createHydrationRenderer(options2) {
    return baseCreateRenderer(options2, createHydrationFunctions);
  }
  function baseCreateRenderer(options2, createHydrationFns) {
    const target2 = getGlobalThis();
    target2.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options2;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref: ref3, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace2);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace2) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace2,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace2 = "svg";
      } else if (n2.type === "math") {
        namespace2 = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace2,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace2),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], namespace2, parentComponent);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace2);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
          hostSetScopeId(el, slotScopeIds[i2]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
        hostSetElementText(el, "");
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace2),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace2),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, oldProps, newProps, parentComponent, namespace2);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace2);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
              const key = propsToUpdate[i2];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(el, key, prev, next, namespace2, parentComponent);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, oldProps, newProps, parentComponent, namespace2);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
      for (let i2 = 0; i2 < newChildren.length; i2++) {
        const oldVNode = oldChildren[i2];
        const newVNode = newChildren[i2];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, oldProps, newProps, parentComponent, namespace2) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace2,
                parentComponent
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key)) continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(el, key, prev, next, namespace2, parentComponent);
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          // #10007
          // such fragment like `<></>` will be compiled into
          // a fragment which doesn't have a children.
          // In this case fallback to an empty array
          n2.children || [],
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace2,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
      const instance = initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      );
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance, false, optimized);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace2,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m: m2, parent, root: root2, type } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
            };
            if (isAsyncWrapperVNode && type.__asyncHydrate) {
              type.__asyncHydrate(
                el,
                instance,
                hydrateSubTree
              );
            } else {
              hydrateSubTree();
            }
          } else {
            if (root2.ce) {
              root2.ce._injectChildStyle(type);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace2
            );
            initialVNode.el = subTree.el;
          }
          if (m2) {
            queuePostRenderEffect(m2, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u: u2, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace2
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u2) {
            queuePostRenderEffect(u2, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      instance.scope.on();
      const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
      instance.scope.off();
      const update = instance.update = effect2.run.bind(effect2);
      const job = instance.job = effect2.runIfDirty.bind(effect2);
      job.i = instance;
      job.id = instance.uid;
      effect2.scheduler = () => queueJob(job);
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i2;
      for (i2 = 0; i2 < commonLength; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        patch(
          c1[i2],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
      let i2 = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[i2];
        const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i2++;
      }
      while (i2 <= e1 && i2 <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i2 > e1) {
        if (i2 <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i2 <= e2) {
            patch(
              null,
              c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            i2++;
          }
        }
      } else if (i2 > e2) {
        while (i2 <= e1) {
          unmount(c1[i2], parentComponent, parentSuspense, true);
          i2++;
        }
      } else {
        const s1 = i2;
        const s2 = i2;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i2 = s2; i2 <= e2; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i2);
          }
        }
        let j2;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
        for (i2 = s1; i2 <= e1; i2++) {
          const prevChild = c1[i2];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j2 = s2; j2 <= e2; j2++) {
              if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
                newIndex = j2;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j2 = increasingNewIndexSequence.length - 1;
        for (i2 = toBePatched - 1; i2 >= 0; i2--) {
          const nextIndex = s2 + i2;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i2] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
              move(nextChild, container, anchor, 2);
            } else {
              j2--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i2 = 0; i2 < children.length; i2++) {
          move(children[i2], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove22 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove22();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove22, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref: ref3,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs,
        cacheIndex
      } = vnode;
      if (patchFlag === -2) {
        optimized = false;
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (cacheIndex != null) {
        parentComponent.renderCache[cacheIndex] = void 0;
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove2(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove2 = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end2) => {
      let next;
      while (cur !== end2) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end2);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, job, subTree, um, m: m2, a: a2 } = instance;
      invalidateMount(m2);
      invalidateMount(a2);
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (job) {
        job.flags |= 8;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i2 = start; i2 < children.length; i2++) {
        unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      const el = hostNextSibling(vnode.anchor || vnode.el);
      const teleportEnd = el && el[TeleportEndKey];
      return teleportEnd ? hostNextSibling(teleportEnd) : el;
    };
    let isFlushing = false;
    const render2 = (vnode, container, namespace2) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace2
        );
      }
      container._vnode = vnode;
      if (!isFlushing) {
        isFlushing = true;
        flushPreFlushCbs();
        flushPostFlushCbs();
        isFlushing = false;
      }
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove2,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options2
    };
    let hydrate2;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate2, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render: render2,
      hydrate: hydrate2,
      createApp: createAppAPI(render2, hydrate2)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect: effect2, job }, allowed) {
    if (allowed) {
      effect2.flags |= 32;
      job.flags |= 4;
    } else {
      effect2.flags &= -33;
      job.flags &= -5;
    }
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$1(ch1) && isArray$1(ch2)) {
      for (let i2 = 0; i2 < ch1.length; i2++) {
        const c1 = ch1[i2];
        let c2 = ch2[i2];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
            c2.el = c1.el;
          }
          if (!shallow && c2.patchFlag !== -2)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i2, j2, u2, v2, c2;
    const len = arr.length;
    for (i2 = 0; i2 < len; i2++) {
      const arrI = arr[i2];
      if (arrI !== 0) {
        j2 = result[result.length - 1];
        if (arr[j2] < arrI) {
          p2[i2] = j2;
          result.push(i2);
          continue;
        }
        u2 = 0;
        v2 = result.length - 1;
        while (u2 < v2) {
          c2 = u2 + v2 >> 1;
          if (arr[result[c2]] < arrI) {
            u2 = c2 + 1;
          } else {
            v2 = c2;
          }
        }
        if (arrI < arr[result[u2]]) {
          if (u2 > 0) {
            p2[i2] = result[u2 - 1];
          }
          result[u2] = i2;
        }
      }
    }
    u2 = result.length;
    v2 = result[u2 - 1];
    while (u2-- > 0) {
      result[u2] = v2;
      v2 = p2[v2];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }
  function invalidateMount(hooks) {
    if (hooks) {
      for (let i2 = 0; i2 < hooks.length; i2++)
        hooks[i2].flags |= 8;
    }
  }
  const ssrContextKey = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey);
      return ctx;
    }
  };
  function watchEffect(effect2, options2) {
    return doWatch(effect2, null, options2);
  }
  function watchPostEffect(effect2, options2) {
    return doWatch(
      effect2,
      null,
      { flush: "post" }
    );
  }
  function watchSyncEffect(effect2, options2) {
    return doWatch(
      effect2,
      null,
      { flush: "sync" }
    );
  }
  function watch(source, cb, options2) {
    return doWatch(source, cb, options2);
  }
  function doWatch(source, cb, options2 = EMPTY_OBJ) {
    const { immediate, deep, flush, once } = options2;
    const baseWatchOptions = extend({}, options2);
    const runsImmediately = cb && immediate || !cb && flush !== "post";
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else if (!runsImmediately) {
        const watchStopHandle = () => {
        };
        watchStopHandle.stop = NOOP;
        watchStopHandle.resume = NOOP;
        watchStopHandle.pause = NOOP;
        return watchStopHandle;
      }
    }
    const instance = currentInstance;
    baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
    let isPre = false;
    if (flush === "post") {
      baseWatchOptions.scheduler = (job) => {
        queuePostRenderEffect(job, instance && instance.suspense);
      };
    } else if (flush !== "sync") {
      isPre = true;
      baseWatchOptions.scheduler = (job, isFirstRun) => {
        if (isFirstRun) {
          job();
        } else {
          queueJob(job);
        }
      };
    }
    baseWatchOptions.augmentJob = (job) => {
      if (cb) {
        job.flags |= 4;
      }
      if (isPre) {
        job.flags |= 2;
        if (instance) {
          job.id = instance.uid;
          job.i = instance;
        }
      }
    };
    const watchHandle = watch$1(source, cb, baseWatchOptions);
    if (isInSSRComponentSetup) {
      if (ssrCleanup) {
        ssrCleanup.push(watchHandle);
      } else if (runsImmediately) {
        watchHandle();
      }
    }
    return watchHandle;
  }
  function instanceWatch(source, value, options2) {
    const publicThis = this.proxy;
    const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options2 = value;
    }
    const reset = setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options2);
    reset();
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i2 = 0; i2 < segments.length && cur; i2++) {
        cur = cur[segments[i2]];
      }
      return cur;
    };
  }
  function useModel(props, name, options2 = EMPTY_OBJ) {
    const i2 = getCurrentInstance();
    const camelizedName = camelize(name);
    const hyphenatedName = hyphenate(name);
    const modifiers = getModelModifiers(props, camelizedName);
    const res = customRef((track2, trigger2) => {
      let localValue;
      let prevSetValue = EMPTY_OBJ;
      let prevEmittedValue;
      watchSyncEffect(() => {
        const propValue = props[camelizedName];
        if (hasChanged(localValue, propValue)) {
          localValue = propValue;
          trigger2();
        }
      });
      return {
        get() {
          track2();
          return options2.get ? options2.get(localValue) : localValue;
        },
        set(value) {
          const emittedValue = options2.set ? options2.set(value) : value;
          if (!hasChanged(emittedValue, localValue) && !(prevSetValue !== EMPTY_OBJ && hasChanged(value, prevSetValue))) {
            return;
          }
          const rawProps = i2.vnode.props;
          if (!(rawProps && // check if parent has passed v-model
          (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps))) {
            localValue = value;
            trigger2();
          }
          i2.emit(`update:${name}`, emittedValue);
          if (hasChanged(value, emittedValue) && hasChanged(value, prevSetValue) && !hasChanged(emittedValue, prevEmittedValue)) {
            trigger2();
          }
          prevSetValue = value;
          prevEmittedValue = emittedValue;
        }
      };
    });
    res[Symbol.iterator] = () => {
      let i22 = 0;
      return {
        next() {
          if (i22 < 2) {
            return { value: i22++ ? modifiers || EMPTY_OBJ : res, done: false };
          } else {
            return { done: true };
          }
        }
      };
    };
    return res;
  }
  const getModelModifiers = (props, modelName) => {
    return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
  };
  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted) return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener2 = event.startsWith("update:");
    const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
    if (modifiers) {
      if (modifiers.trim) {
        args = rawArgs.map((a2) => isString$1(a2) ? a2.trim() : a2);
      }
      if (modifiers.number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener2) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw2 = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction$1(comp)) {
      const extendEmits = (raw22) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw22, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw2 && !hasExtends) {
      if (isObject$3(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$1(raw2)) {
      raw2.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw2);
    }
    if (isObject$3(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options2, key) {
    if (!options2 || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn$1(options2, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options2, hyphenate(key)) || hasOwn$1(options2, key);
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      propsOptions: [propsOptions],
      slots,
      attrs: attrs2,
      emit: emit2,
      render: render2,
      renderCache,
      props,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    const prev = setCurrentRenderingInstance(instance);
    let result;
    let fallthroughAttrs;
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = false ? new Proxy(proxyToUse, {
          get(target2, key, receiver) {
            warn$1(
              `Property '${String(
                key
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target2, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render2.call(
            thisProxy,
            proxyToUse,
            renderCache,
            false ? shallowReadonly(props) : props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs2;
      } else {
        const render22 = Component;
        if (false) ;
        result = normalizeVNode(
          render22.length > 1 ? render22(
            false ? shallowReadonly(props) : props,
            false ? {
              get attrs() {
                markAttrsAccessed();
                return shallowReadonly(attrs2);
              },
              slots,
              emit: emit2
            } : { attrs: attrs2, slots, emit: emit2 }
          ) : render22(
            false ? shallowReadonly(props) : props,
            null
          )
        );
        fallthroughAttrs = Component.props ? attrs2 : getFunctionalFallthrough(attrs2);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root2 = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root2;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root2 = cloneVNode(root2, fallthroughAttrs, false, true);
        }
      }
    }
    if (vnode.dirs) {
      root2 = cloneVNode(root2, null, false, true);
      root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      setTransitionHooks(root2, vnode.transition);
    }
    {
      result = root2;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  function filterSingleRoot(children, recurse = true) {
    let singleRoot;
    for (let i2 = 0; i2 < children.length; i2++) {
      const child = children[i2];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  const getFunctionalFallthrough = (attrs2) => {
    let res;
    for (const key in attrs2) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs2[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs2, props) => {
    const res = {};
    for (const key in attrs2) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs2[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i2 = 0; i2 < dynamicProps.length; i2++) {
          const key = dynamicProps[i2];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i2 = 0; i2 < nextKeys.length; i2++) {
      const key = nextKeys[i2];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent) {
      const root2 = parent.subTree;
      if (root2.suspense && root2.suspense.activeBranch === vnode) {
        root2.el = vnode.el;
      }
      if (root2 === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }
  const isSuspense = (type) => type.__isSuspense;
  let suspenseId = 0;
  const SuspenseImpl = {
    name: "Suspense",
    // In order to make Suspense tree-shakable, we need to avoid importing it
    // directly in the renderer. The renderer checks for the __isSuspense flag
    // on a vnode's type and calls the `process` method, passing in renderer
    // internals.
    __isSuspense: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals) {
      if (n1 == null) {
        mountSuspense(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace2,
          slotScopeIds,
          optimized,
          rendererInternals
        );
      } else {
        if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {
          n2.suspense = n1.suspense;
          n2.suspense.vnode = n2;
          n2.el = n1.el;
          return;
        }
        patchSuspense(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          namespace2,
          slotScopeIds,
          optimized,
          rendererInternals
        );
      }
    },
    hydrate: hydrateSuspense,
    normalize: normalizeSuspenseChildren
  };
  const Suspense = SuspenseImpl;
  function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (isFunction$1(eventListener)) {
      eventListener();
    }
  }
  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals) {
    const {
      p: patch,
      o: { createElement: createElement2 }
    } = rendererInternals;
    const hiddenContainer = createElement2("div");
    const suspense = vnode.suspense = createSuspenseBoundary(
      vnode,
      parentSuspense,
      parentComponent,
      container,
      hiddenContainer,
      anchor,
      namespace2,
      slotScopeIds,
      optimized,
      rendererInternals
    );
    patch(
      null,
      suspense.pendingBranch = vnode.ssContent,
      hiddenContainer,
      null,
      parentComponent,
      suspense,
      namespace2,
      slotScopeIds
    );
    if (suspense.deps > 0) {
      triggerEvent(vnode, "onPending");
      triggerEvent(vnode, "onFallback");
      patch(
        null,
        vnode.ssFallback,
        container,
        anchor,
        parentComponent,
        null,
        // fallback tree will not have suspense context
        namespace2,
        slotScopeIds
      );
      setActiveBranch(suspense, vnode.ssFallback);
    } else {
      suspense.resolve(false, true);
    }
  }
  function patchSuspense(n1, n2, container, anchor, parentComponent, namespace2, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement: createElement2 } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
      suspense.pendingBranch = newBranch;
      if (isSameVNodeType(newBranch, pendingBranch)) {
        patch(
          pendingBranch,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else if (isInFallback) {
          if (!isHydrating) {
            patch(
              activeBranch,
              newFallback,
              container,
              anchor,
              parentComponent,
              null,
              // fallback tree will not have suspense context
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newFallback);
          }
        }
      } else {
        suspense.pendingId = suspenseId++;
        if (isHydrating) {
          suspense.isHydrating = false;
          suspense.activeBranch = pendingBranch;
        } else {
          unmount(pendingBranch, parentComponent, suspense);
        }
        suspense.deps = 0;
        suspense.effects.length = 0;
        suspense.hiddenContainer = createElement2("div");
        if (isInFallback) {
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            patch(
              activeBranch,
              newFallback,
              container,
              anchor,
              parentComponent,
              null,
              // fallback tree will not have suspense context
              namespace2,
              slotScopeIds,
              optimized
            );
            setActiveBranch(suspense, newFallback);
          }
        } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(
            activeBranch,
            newBranch,
            container,
            anchor,
            parentComponent,
            suspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          suspense.resolve(true);
        } else {
          patch(
            null,
            newBranch,
            suspense.hiddenContainer,
            null,
            parentComponent,
            suspense,
            namespace2,
            slotScopeIds,
            optimized
          );
          if (suspense.deps <= 0) {
            suspense.resolve();
          }
        }
      }
    } else {
      if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newBranch);
      } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        if (newBranch.shapeFlag & 512) {
          suspense.pendingId = newBranch.component.suspenseId;
        } else {
          suspense.pendingId = suspenseId++;
        }
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          namespace2,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          const { timeout, pendingId } = suspense;
          if (timeout > 0) {
            setTimeout(() => {
              if (suspense.pendingId === pendingId) {
                suspense.fallback(newFallback);
              }
            }, timeout);
          } else if (timeout === 0) {
            suspense.fallback(newFallback);
          }
        }
      }
    }
  }
  function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace2, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    const {
      p: patch,
      m: move,
      um: unmount,
      n: next,
      o: { parentNode, remove: remove2 }
    } = rendererInternals;
    let parentSuspenseId;
    const isSuspensible = isVNodeSuspensible(vnode);
    if (isSuspensible) {
      if (parentSuspense && parentSuspense.pendingBranch) {
        parentSuspenseId = parentSuspense.pendingId;
        parentSuspense.deps++;
      }
    }
    const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
    const initialAnchor = anchor;
    const suspense = {
      vnode,
      parent: parentSuspense,
      parentComponent,
      namespace: namespace2,
      container,
      hiddenContainer,
      deps: 0,
      pendingId: suspenseId++,
      timeout: typeof timeout === "number" ? timeout : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !isHydrating,
      isHydrating,
      isUnmounted: false,
      effects: [],
      resolve(resume = false, sync = false) {
        const {
          vnode: vnode2,
          activeBranch,
          pendingBranch,
          pendingId,
          effects,
          parentComponent: parentComponent2,
          container: container2
        } = suspense;
        let delayEnter = false;
        if (suspense.isHydrating) {
          suspense.isHydrating = false;
        } else if (!resume) {
          delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = () => {
              if (pendingId === suspense.pendingId) {
                move(
                  pendingBranch,
                  container2,
                  anchor === initialAnchor ? next(activeBranch) : anchor,
                  0
                );
                queuePostFlushCb(effects);
              }
            };
          }
          if (activeBranch) {
            if (parentNode(activeBranch.el) === container2) {
              anchor = next(activeBranch);
            }
            unmount(activeBranch, parentComponent2, suspense, true);
          }
          if (!delayEnter) {
            move(pendingBranch, container2, anchor, 0);
          }
        }
        setActiveBranch(suspense, pendingBranch);
        suspense.pendingBranch = null;
        suspense.isInFallback = false;
        let parent = suspense.parent;
        let hasUnresolvedAncestor = false;
        while (parent) {
          if (parent.pendingBranch) {
            parent.effects.push(...effects);
            hasUnresolvedAncestor = true;
            break;
          }
          parent = parent.parent;
        }
        if (!hasUnresolvedAncestor && !delayEnter) {
          queuePostFlushCb(effects);
        }
        suspense.effects = [];
        if (isSuspensible) {
          if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
            parentSuspense.deps--;
            if (parentSuspense.deps === 0 && !sync) {
              parentSuspense.resolve();
            }
          }
        }
        triggerEvent(vnode2, "onResolve");
      },
      fallback(fallbackVNode) {
        if (!suspense.pendingBranch) {
          return;
        }
        const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace22 } = suspense;
        triggerEvent(vnode2, "onFallback");
        const anchor2 = next(activeBranch);
        const mountFallback = () => {
          if (!suspense.isInFallback) {
            return;
          }
          patch(
            null,
            fallbackVNode,
            container2,
            anchor2,
            parentComponent2,
            null,
            // fallback tree will not have suspense context
            namespace22,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, fallbackVNode);
        };
        const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = mountFallback;
        }
        suspense.isInFallback = true;
        unmount(
          activeBranch,
          parentComponent2,
          null,
          // no suspense so unmount hooks fire now
          true
          // shouldRemove
        );
        if (!delayEnter) {
          mountFallback();
        }
      },
      move(container2, anchor2, type) {
        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
        suspense.container = container2;
      },
      next() {
        return suspense.activeBranch && next(suspense.activeBranch);
      },
      registerDep(instance, setupRenderEffect, optimized2) {
        const isInPendingSuspense = !!suspense.pendingBranch;
        if (isInPendingSuspense) {
          suspense.deps++;
        }
        const hydratedEl = instance.vnode.el;
        instance.asyncDep.catch((err) => {
          handleError(err, instance, 0);
        }).then((asyncSetupResult) => {
          if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
            return;
          }
          instance.asyncResolved = true;
          const { vnode: vnode2 } = instance;
          handleSetupResult(instance, asyncSetupResult, false);
          if (hydratedEl) {
            vnode2.el = hydratedEl;
          }
          const placeholder = !hydratedEl && instance.subTree.el;
          setupRenderEffect(
            instance,
            vnode2,
            // component may have been moved before resolve.
            // if this is not a hydration, instance.subTree will be the comment
            // placeholder.
            parentNode(hydratedEl || instance.subTree.el),
            // anchor will not be used if this is hydration, so only need to
            // consider the comment placeholder case.
            hydratedEl ? null : next(instance.subTree),
            suspense,
            namespace2,
            optimized2
          );
          if (placeholder) {
            remove2(placeholder);
          }
          updateHOCHostEl(instance, vnode2.el);
          if (isInPendingSuspense && --suspense.deps === 0) {
            suspense.resolve();
          }
        });
      },
      unmount(parentSuspense2, doRemove) {
        suspense.isUnmounted = true;
        if (suspense.activeBranch) {
          unmount(
            suspense.activeBranch,
            parentComponent,
            parentSuspense2,
            doRemove
          );
        }
        if (suspense.pendingBranch) {
          unmount(
            suspense.pendingBranch,
            parentComponent,
            parentSuspense2,
            doRemove
          );
        }
      }
    };
    return suspense;
  }
  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(
      vnode,
      parentSuspense,
      parentComponent,
      node.parentNode,
      // eslint-disable-next-line no-restricted-globals
      document.createElement("div"),
      null,
      namespace2,
      slotScopeIds,
      optimized,
      rendererInternals,
      true
    );
    const result = hydrateNode(
      node,
      suspense.pendingBranch = vnode.ssContent,
      parentComponent,
      suspense,
      slotScopeIds,
      optimized
    );
    if (suspense.deps === 0) {
      suspense.resolve(false, true);
    }
    return result;
  }
  function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(
      isSlotChildren ? children.default : children
    );
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
  }
  function normalizeSuspenseSlot(s2) {
    let block;
    if (isFunction$1(s2)) {
      const trackBlock = isBlockTreeEnabled && s2._c;
      if (trackBlock) {
        s2._d = false;
        openBlock();
      }
      s2 = s2();
      if (trackBlock) {
        s2._d = true;
        block = currentBlock;
        closeBlock();
      }
    }
    if (isArray$1(s2)) {
      const singleChild = filterSingleRoot(s2);
      s2 = singleChild;
    }
    s2 = normalizeVNode(s2);
    if (block && !s2.dynamicChildren) {
      s2.dynamicChildren = block.filter((c2) => c2 !== s2);
    }
    return s2;
  }
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$1(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    let el = branch.el;
    while (!el && branch.component) {
      branch = branch.component.subTree;
      el = branch.el;
    }
    vnode.el = el;
    if (parentComponent && parentComponent.subTree === vnode) {
      parentComponent.vnode.el = el;
      updateHOCHostEl(parentComponent, el);
    }
  }
  function isVNodeSuspensible(vnode) {
    const suspensible = vnode.props && vnode.props.suspensible;
    return suspensible != null && suspensible !== false;
  }
  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value, inVOnce = false) {
    isBlockTreeEnabled += value;
    if (value < 0 && currentBlock && inVOnce) {
      currentBlock.hasOnce = true;
    }
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(
      createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        true
      )
    );
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  function transformVNodeArgs(transformer) {
  }
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref: ref3,
    ref_key,
    ref_for
  }) => {
    if (typeof ref3 === "number") {
      ref3 = "" + ref3;
    }
    return ref3 != null ? isString$1(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString$1(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag = -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString$1(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$3(style)) {
        if (isProxy(style) && !isArray$1(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$1(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props) return null;
    return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
    const { props, ref: ref3, patchFlag, children, transition } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children,
      target: vnode.target,
      targetStart: vnode.targetStart,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    if (transition && cloneTransition) {
      setTransitionHooks(
        cloned,
        transition.clone(cloned)
      );
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$1(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (isVNode(child)) {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$1(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !isInternalObject(children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i2 = 0; i2 < args.length; i2++) {
      const toMerge = args[i2];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      ids: parent ? parent.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g2 = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g2[key])) setters = g2[key] = [];
      setters.push(setter);
      return (v2) => {
        if (setters.length > 1) setters.forEach((set) => set(v2));
        else setters[0](v2);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v2) => currentInstance = v2
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v2) => isInSSRComponentSetup = v2
    );
  }
  const setCurrentInstance = (instance) => {
    const prev = currentInstance;
    internalSetCurrentInstance(instance);
    instance.scope.on();
    return () => {
      instance.scope.off();
      internalSetCurrentInstance(prev);
    };
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false, optimized = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children, optimized);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
    const { setup } = Component;
    if (setup) {
      pauseTracking();
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      const reset = setCurrentInstance(instance);
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      const isAsyncSetup = isPromise(setupResult);
      resetTracking();
      reset();
      if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
        markAsyncBoundary(instance);
      }
      if (isAsyncSetup) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e2) => {
            handleError(e2, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$3(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance, isSSR);
  }
  let compile$1;
  let installWithProxy;
  function registerRuntimeCompiler(_compile) {
    compile$1 = _compile;
    installWithProxy = (i2) => {
      if (i2.render._rc) {
        i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
      }
    };
  }
  const isRuntimeOnly = () => !compile$1;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile$1 && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend(
            extend(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile$1(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    {
      const reset = setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        reset();
      }
    }
  }
  const attrsProxyHandlers = {
    get(target2, key) {
      track(target2, "get", "");
      return target2[key];
    }
  };
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        attrs: new Proxy(instance.attrs, attrsProxyHandlers),
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getComponentPublicInstance(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target2, key) {
          if (key in target2) {
            return target2[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target2, key) {
          return key in target2 || key in publicPropertiesMap;
        }
      }));
    } else {
      return instance.proxy;
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }
  const computed = (getterOrOptions, debugOptions) => {
    const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    return c2;
  };
  function h$2(type, propsOrChildren, children) {
    const l2 = arguments.length;
    if (l2 === 2) {
      if (isObject$3(propsOrChildren) && !isArray$1(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l2 > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l2 === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    {
      return;
    }
  }
  function withMemo(memo, render2, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
      return cached;
    }
    const ret = render2();
    ret.memo = memo.slice();
    ret.cacheIndex = index;
    return cache[index] = ret;
  }
  function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
      return false;
    }
    for (let i2 = 0; i2 < prev.length; i2++) {
      if (hasChanged(prev[i2], memo[i2])) {
        return false;
      }
    }
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(cached);
    }
    return true;
  }
  const version = "3.5.13";
  const warn = NOOP;
  const ErrorTypeStrings = ErrorTypeStrings$1;
  const devtools = devtools$1;
  const setDevtoolsHook = setDevtoolsHook$1;
  const _ssrUtils = {
    createComponentInstance,
    setupComponent,
    renderComponentRoot,
    setCurrentRenderingInstance,
    isVNode,
    normalizeVNode,
    getComponentPublicInstance,
    ensureValidVNode,
    pushWarningContext,
    popWarningContext
  };
  const ssrUtils = _ssrUtils;
  const resolveFilter = null;
  const compatUtils = null;
  const DeprecationTypes = null;
  /**
  * @vue/runtime-dom v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let policy = void 0;
  const tt = typeof window !== "undefined" && window.trustedTypes;
  if (tt) {
    try {
      policy = /* @__PURE__ */ tt.createPolicy("vue", {
        createHTML: (val) => val
      });
    } catch (e2) {
    }
  }
  const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace2, is, props) => {
      const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace2, start, end2) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end2 || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end2 || !(start = start.nextSibling)) break;
        }
      } else {
        templateContainer.innerHTML = unsafeToTrustedHTML(
          namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content
        );
        const template = templateContainer.content;
        if (namespace2 === "svg" || namespace2 === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };
  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const decorate$1 = (t2) => {
    t2.displayName = "Transition";
    t2.props = TransitionPropsValidators;
    return t2;
  };
  const Transition = /* @__PURE__ */ decorate$1(
    (props, { slots }) => h$2(BaseTransition, resolveTransitionProps(props), slots)
  );
  const callHook = (hook, args = []) => {
    if (isArray$1(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done, isCancelled) => {
      el._enterCancelled = isCancelled;
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        if (!el._enterCancelled) {
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
        } else {
          addTransitionClass(el, leaveActiveClass);
          forceReflow();
        }
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve2);
          }
        });
        callHook(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false, void 0, true);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true, void 0, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$3(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n2 = NumberOf(duration);
      return [n2, n2];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout != null) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve2();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end2 = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e2) => {
      if (e2.target === el && ++ended >= propCount) {
        end2();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end2();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles2 = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles2[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
  }
  function toMs(s2) {
    if (s2 === "auto") return 0;
    return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }
  const vShowOriginalDisplay = Symbol("_vod");
  const vShowHidden = Symbol("_vsh");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue) return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOriginalDisplay] : "none";
    el[vShowHidden] = !value;
  }
  function initVShowForSSR() {
    vShow.getSSRProps = ({ value }) => {
      if (!value) {
        return { style: { display: "none" } };
      }
    };
  }
  const CSS_VAR_TEXT = Symbol("");
  function useCssVars(getter) {
    const instance = getCurrentInstance();
    if (!instance) {
      return;
    }
    const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
      Array.from(
        document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
      ).forEach((node) => setVarsOnNode(node, vars));
    };
    const setVars = () => {
      const vars = getter(instance.proxy);
      if (instance.ce) {
        setVarsOnNode(instance.ce, vars);
      } else {
        setVarsOnVNode(instance.subTree, vars);
      }
      updateTeleports(vars);
    };
    onBeforeUpdate(() => {
      queuePostFlushCb(setVars);
    });
    onMounted(() => {
      watch(setVars, NOOP, { flush: "post" });
      const ob = new MutationObserver(setVars);
      ob.observe(instance.subTree.el.parentNode, { childList: true });
      onUnmounted(() => ob.disconnect());
    });
  }
  function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;
      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    }
    while (vnode.component) {
      vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 && vnode.el) {
      setVarsOnNode(vnode.el, vars);
    } else if (vnode.type === Fragment) {
      vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
    } else if (vnode.type === Static) {
      let { el, anchor } = vnode;
      while (el) {
        setVarsOnNode(el, vars);
        if (el === anchor) break;
        el = el.nextSibling;
      }
    }
  }
  function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
      const style = el.style;
      let cssText = "";
      for (const key in vars) {
        style.setProperty(`--${key}`, vars[key]);
        cssText += `--${key}: ${vars[key]};`;
      }
      style[CSS_VAR_TEXT] = cssText;
    }
  }
  const displayRE = /(^|;)\s*display\s*:/;
  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString$1(next);
    let hasControlledDisplay = false;
    if (next && !isCssString) {
      if (prev) {
        if (!isString$1(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        } else {
          for (const prevStyle of prev.split(";")) {
            const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
      }
      for (const key in next) {
        if (key === "display") {
          hasControlledDisplay = true;
        }
        setStyle(style, key, next[key]);
      }
    } else {
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
          hasControlledDisplay = displayRE.test(next);
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
    }
    if (vShowOriginalDisplay in el) {
      el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
      if (el[vShowHidden]) {
        style.display = "none";
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$1(val)) {
      val.forEach((v2) => setStyle(style, name, v2));
    } else {
      if (val == null) val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i2 = 0; i2 < prefixes.length; i2++) {
      const prefixed = prefixes[i2] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance, isBoolean2 = isSpecialBooleanAttr(key)) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(
          key,
          isBoolean2 ? "" : isSymbol(value) ? String(value) : value
        );
      }
    }
  }
  function patchDOMProp(el, key, value, parentComponent, attrName) {
    if (key === "innerHTML" || key === "textContent") {
      if (value != null) {
        el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
      }
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
      const newValue = value == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        el.type === "checkbox" ? "on" : ""
      ) : String(value);
      if (oldValue !== newValue || !("_value" in el)) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      el._value = value;
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e2) {
    }
    needRemove && el.removeAttribute(attrName || key);
  }
  function addEventListener(el, event, handler, options2) {
    el.addEventListener(event, handler, options2);
  }
  function removeEventListener(el, event, handler, options2) {
    el.removeEventListener(event, handler, options2);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options2] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(
          nextValue,
          instance
        );
        addEventListener(el, name, invoker, options2);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options2);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options2;
    if (optionsModifierRE.test(name)) {
      options2 = {};
      let m2;
      while (m2 = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m2[0].length);
        options2[m2[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options2];
  }
  let cachedNow = 0;
  const p$3 = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p$3.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e2) => {
      if (!e2._vts) {
        e2._vts = Date.now();
      } else if (e2._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e2, invoker.value),
        instance,
        5,
        [e2]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e2, value) {
    if (isArray$1(value)) {
      const originalStop = e2.stopImmediatePropagation;
      e2.stopImmediatePropagation = () => {
        originalStop.call(e2);
        e2._stopped = true;
      };
      return value.map(
        (fn) => (e22) => !e22._stopped && fn && fn(e22)
      );
    } else {
      return value;
    }
  }
  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace2, parentComponent) => {
    const isSVG = namespace2 === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(el, key, nextValue);
      if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
        patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
      }
    } else if (
      // #11081 force set props for possible async custom element
      el._isVueCE && (/[A-Z]/.test(key) || !isString$1(nextValue))
    ) {
      patchDOMProp(el, camelize(key), nextValue, parentComponent, key);
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction$1(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString$1(value)) {
      return false;
    }
    return key in el;
  }
  const REMOVAL = {};
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineCustomElement(options2, extraOptions, _createApp) {
    const Comp = /* @__PURE__ */ defineComponent(options2, extraOptions);
    if (isPlainObject$4(Comp)) extend(Comp, extraOptions);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, _createApp);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options2, extraOptions) => {
    return /* @__PURE__ */ defineCustomElement(options2, extraOptions, createSSRApp);
  };
  const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
  };
  class VueElement extends BaseClass {
    constructor(_def, _props = {}, _createApp = createApp) {
      super();
      this._def = _def;
      this._props = _props;
      this._createApp = _createApp;
      this._isVueCE = true;
      this._instance = null;
      this._app = null;
      this._nonce = this._def.nonce;
      this._connected = false;
      this._resolved = false;
      this._numberProps = null;
      this._styleChildren = /* @__PURE__ */ new WeakSet();
      this._ob = null;
      if (this.shadowRoot && _createApp !== createApp) {
        this._root = this.shadowRoot;
      } else {
        if (_def.shadowRoot !== false) {
          this.attachShadow({ mode: "open" });
          this._root = this.shadowRoot;
        } else {
          this._root = this;
        }
      }
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
    connectedCallback() {
      if (!this.isConnected) return;
      if (!this.shadowRoot) {
        this._parseSlots();
      }
      this._connected = true;
      let parent = this;
      while (parent = parent && (parent.parentNode || parent.host)) {
        if (parent instanceof VueElement) {
          this._parent = parent;
          break;
        }
      }
      if (!this._instance) {
        if (this._resolved) {
          this._setParent();
          this._update();
        } else {
          if (parent && parent._pendingResolve) {
            this._pendingResolve = parent._pendingResolve.then(() => {
              this._pendingResolve = void 0;
              this._resolveDef();
            });
          } else {
            this._resolveDef();
          }
        }
      }
    }
    _setParent(parent = this._parent) {
      if (parent) {
        this._instance.parent = parent._instance;
        this._instance.provides = parent._instance.provides;
      }
    }
    disconnectedCallback() {
      this._connected = false;
      nextTick(() => {
        if (!this._connected) {
          if (this._ob) {
            this._ob.disconnect();
            this._ob = null;
          }
          this._app && this._app.unmount();
          if (this._instance) this._instance.ce = void 0;
          this._app = this._instance = null;
        }
      });
    }
    /**
     * resolve inner component definition (handle possible async component)
     */
    _resolveDef() {
      if (this._pendingResolve) {
        return;
      }
      for (let i2 = 0; i2 < this.attributes.length; i2++) {
        this._setAttr(this.attributes[i2].name);
      }
      this._ob = new MutationObserver((mutations2) => {
        for (const m2 of mutations2) {
          this._setAttr(m2.attributeName);
        }
      });
      this._ob.observe(this, { attributes: true });
      const resolve2 = (def2, isAsync = false) => {
        this._resolved = true;
        this._pendingResolve = void 0;
        const { props, styles: styles2 } = def2;
        let numberProps;
        if (props && !isArray$1(props)) {
          for (const key in props) {
            const opt = props[key];
            if (opt === Number || opt && opt.type === Number) {
              if (key in this._props) {
                this._props[key] = toNumber(this._props[key]);
              }
              (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
            }
          }
        }
        this._numberProps = numberProps;
        if (isAsync) {
          this._resolveProps(def2);
        }
        if (this.shadowRoot) {
          this._applyStyles(styles2);
        }
        this._mount(def2);
      };
      const asyncDef = this._def.__asyncLoader;
      if (asyncDef) {
        this._pendingResolve = asyncDef().then(
          (def2) => resolve2(this._def = def2, true)
        );
      } else {
        resolve2(this._def);
      }
    }
    _mount(def2) {
      this._app = this._createApp(def2);
      if (def2.configureApp) {
        def2.configureApp(this._app);
      }
      this._app._ceVNode = this._createVNode();
      this._app.mount(this._root);
      const exposed = this._instance && this._instance.exposed;
      if (!exposed) return;
      for (const key in exposed) {
        if (!hasOwn$1(this, key)) {
          Object.defineProperty(this, key, {
            // unwrap ref to be consistent with public instance behavior
            get: () => unref(exposed[key])
          });
        }
      }
    }
    _resolveProps(def2) {
      const { props } = def2;
      const declaredPropKeys = isArray$1(props) ? props : Object.keys(props || {});
      for (const key of Object.keys(this)) {
        if (key[0] !== "_" && declaredPropKeys.includes(key)) {
          this._setProp(key, this[key]);
        }
      }
      for (const key of declaredPropKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val, true, true);
          }
        });
      }
    }
    _setAttr(key) {
      if (key.startsWith("data-v-")) return;
      const has = this.hasAttribute(key);
      let value = has ? this.getAttribute(key) : REMOVAL;
      const camelKey = camelize(key);
      if (has && this._numberProps && this._numberProps[camelKey]) {
        value = toNumber(value);
      }
      this._setProp(camelKey, value, false, true);
    }
    /**
     * @internal
     */
    _getProp(key) {
      return this._props[key];
    }
    /**
     * @internal
     */
    _setProp(key, val, shouldReflect = true, shouldUpdate = false) {
      if (val !== this._props[key]) {
        if (val === REMOVAL) {
          delete this._props[key];
        } else {
          this._props[key] = val;
          if (key === "key" && this._app) {
            this._app._ceVNode.key = val;
          }
        }
        if (shouldUpdate && this._instance) {
          this._update();
        }
        if (shouldReflect) {
          const ob = this._ob;
          ob && ob.disconnect();
          if (val === true) {
            this.setAttribute(hyphenate(key), "");
          } else if (typeof val === "string" || typeof val === "number") {
            this.setAttribute(hyphenate(key), val + "");
          } else if (!val) {
            this.removeAttribute(hyphenate(key));
          }
          ob && ob.observe(this, { attributes: true });
        }
      }
    }
    _update() {
      render$1(this._createVNode(), this._root);
    }
    _createVNode() {
      const baseProps = {};
      if (!this.shadowRoot) {
        baseProps.onVnodeMounted = baseProps.onVnodeUpdated = this._renderSlots.bind(this);
      }
      const vnode = createVNode(this._def, extend(baseProps, this._props));
      if (!this._instance) {
        vnode.ce = (instance) => {
          this._instance = instance;
          instance.ce = this;
          instance.isCE = true;
          const dispatch = (event, args) => {
            this.dispatchEvent(
              new CustomEvent(
                event,
                isPlainObject$4(args[0]) ? extend({ detail: args }, args[0]) : { detail: args }
              )
            );
          };
          instance.emit = (event, ...args) => {
            dispatch(event, args);
            if (hyphenate(event) !== event) {
              dispatch(hyphenate(event), args);
            }
          };
          this._setParent();
        };
      }
      return vnode;
    }
    _applyStyles(styles2, owner) {
      if (!styles2) return;
      if (owner) {
        if (owner === this._def || this._styleChildren.has(owner)) {
          return;
        }
        this._styleChildren.add(owner);
      }
      const nonce = this._nonce;
      for (let i2 = styles2.length - 1; i2 >= 0; i2--) {
        const s2 = document.createElement("style");
        if (nonce) s2.setAttribute("nonce", nonce);
        s2.textContent = styles2[i2];
        this.shadowRoot.prepend(s2);
      }
    }
    /**
     * Only called when shadowRoot is false
     */
    _parseSlots() {
      const slots = this._slots = {};
      let n2;
      while (n2 = this.firstChild) {
        const slotName = n2.nodeType === 1 && n2.getAttribute("slot") || "default";
        (slots[slotName] || (slots[slotName] = [])).push(n2);
        this.removeChild(n2);
      }
    }
    /**
     * Only called when shadowRoot is false
     */
    _renderSlots() {
      const outlets = (this._teleportTarget || this).querySelectorAll("slot");
      const scopeId = this._instance.type.__scopeId;
      for (let i2 = 0; i2 < outlets.length; i2++) {
        const o2 = outlets[i2];
        const slotName = o2.getAttribute("name") || "default";
        const content = this._slots[slotName];
        const parent = o2.parentNode;
        if (content) {
          for (const n2 of content) {
            if (scopeId && n2.nodeType === 1) {
              const id = scopeId + "-s";
              const walker = document.createTreeWalker(n2, 1);
              n2.setAttribute(id, "");
              let child;
              while (child = walker.nextNode()) {
                child.setAttribute(id, "");
              }
            }
            parent.insertBefore(n2, o2);
          }
        } else {
          while (o2.firstChild) parent.insertBefore(o2.firstChild, o2);
        }
        parent.removeChild(o2);
      }
    }
    /**
     * @internal
     */
    _injectChildStyle(comp) {
      this._applyStyles(comp.styles, comp);
    }
    /**
     * @internal
     */
    _removeChildStyle(comp) {
    }
  }
  function useHost(caller) {
    const instance = getCurrentInstance();
    const el = instance && instance.ce;
    if (el) {
      return el;
    }
    return null;
  }
  function useShadowRoot() {
    const el = useHost();
    return el && el.shadowRoot;
  }
  function useCssModule(name = "$style") {
    {
      const instance = getCurrentInstance();
      if (!instance) {
        return EMPTY_OBJ;
      }
      const modules = instance.type.__cssModules;
      if (!modules) {
        return EMPTY_OBJ;
      }
      const mod = modules[name];
      if (!mod) {
        return EMPTY_OBJ;
      }
      return mod;
    }
  }
  const positionMap = /* @__PURE__ */ new WeakMap();
  const newPositionMap = /* @__PURE__ */ new WeakMap();
  const moveCbKey = Symbol("_moveCb");
  const enterCbKey = Symbol("_enterCb");
  const decorate = (t2) => {
    delete t2.props.mode;
    return t2;
  };
  const TransitionGroupImpl = /* @__PURE__ */ decorate({
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c2) => {
          const el = c2.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e2) => {
            if (e2 && e2.target !== el) {
              return;
            }
            if (!e2 || /transform$/.test(e2.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = [];
        if (children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.el && child.el instanceof Element) {
              prevChildren.push(child);
              setTransitionHooks(
                child,
                resolveTransitionHooks(
                  child,
                  cssTransitionProps,
                  state,
                  instance
                )
              );
              positionMap.set(
                child,
                child.el.getBoundingClientRect()
              );
            }
          }
        }
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          }
        }
        return createVNode(tag, null, children);
      };
    }
  });
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c2) {
    const el = c2.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c2) {
    newPositionMap.set(c2, c2.el.getBoundingClientRect());
  }
  function applyTranslation(c2) {
    const oldPos = positionMap.get(c2);
    const newPos = newPositionMap.get(c2);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s2 = c2.el.style;
      s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
      s2.transitionDuration = "0s";
      return c2;
    }
  }
  function hasCSSTransform(el, root2, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
      });
    }
    moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
    clone.style.display = "none";
    const container = root2.nodeType === 1 ? root2 : root2.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }
  const getModelAssigner = (vnode) => {
    const fn = vnode.props["onUpdate:modelValue"] || false;
    return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
  };
  function onCompositionStart(e2) {
    e2.target.composing = true;
  }
  function onCompositionEnd(e2) {
    const target2 = e2.target;
    if (target2.composing) {
      target2.composing = false;
      target2.dispatchEvent(new Event("input"));
    }
  }
  const assignKey = Symbol("_assign");
  const vModelText = {
    created(el, { modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      const castToNumber = number || vnode.props && vnode.props.type === "number";
      addEventListener(el, lazy ? "change" : "input", (e2) => {
        if (e2.target.composing) return;
        let domValue = el.value;
        if (trim) {
          domValue = domValue.trim();
        }
        if (castToNumber) {
          domValue = looseToNumber(domValue);
        }
        el[assignKey](domValue);
      });
      if (trim) {
        addEventListener(el, "change", () => {
          el.value = el.value.trim();
        });
      }
      if (!lazy) {
        addEventListener(el, "compositionstart", onCompositionStart);
        addEventListener(el, "compositionend", onCompositionEnd);
        addEventListener(el, "change", onCompositionEnd);
      }
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(el, { value }) {
      el.value = value == null ? "" : value;
    },
    beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (el.composing) return;
      const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
      const newValue = value == null ? "" : value;
      if (elValue === newValue) {
        return;
      }
      if (document.activeElement === el && el.type !== "range") {
        if (lazy && value === oldValue) {
          return;
        }
        if (trim && el.value.trim() === newValue) {
          return;
        }
      }
      el.value = newValue;
    }
  };
  const vModelCheckbox = {
    // #4096 array checkboxes need to be deep traversed
    deep: true,
    created(el, _2, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", () => {
        const modelValue = el._modelValue;
        const elementValue = getValue(el);
        const checked = el.checked;
        const assign2 = el[assignKey];
        if (isArray$1(modelValue)) {
          const index = looseIndexOf(modelValue, elementValue);
          const found = index !== -1;
          if (checked && !found) {
            assign2(modelValue.concat(elementValue));
          } else if (!checked && found) {
            const filtered = [...modelValue];
            filtered.splice(index, 1);
            assign2(filtered);
          }
        } else if (isSet(modelValue)) {
          const cloned = new Set(modelValue);
          if (checked) {
            cloned.add(elementValue);
          } else {
            cloned.delete(elementValue);
          }
          assign2(cloned);
        } else {
          assign2(getCheckboxValue(el, checked));
        }
      });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: setChecked,
    beforeUpdate(el, binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      setChecked(el, binding, vnode);
    }
  };
  function setChecked(el, { value, oldValue }, vnode) {
    el._modelValue = value;
    let checked;
    if (isArray$1(value)) {
      checked = looseIndexOf(value, vnode.props.value) > -1;
    } else if (isSet(value)) {
      checked = value.has(vnode.props.value);
    } else {
      if (value === oldValue) return;
      checked = looseEqual(value, getCheckboxValue(el, true));
    }
    if (el.checked !== checked) {
      el.checked = checked;
    }
  }
  const vModelRadio = {
    created(el, { value }, vnode) {
      el.checked = looseEqual(value, vnode.props.value);
      el[assignKey] = getModelAssigner(vnode);
      addEventListener(el, "change", () => {
        el[assignKey](getValue(el));
      });
    },
    beforeUpdate(el, { value, oldValue }, vnode) {
      el[assignKey] = getModelAssigner(vnode);
      if (value !== oldValue) {
        el.checked = looseEqual(value, vnode.props.value);
      }
    }
  };
  const vModelSelect = {
    // <select multiple> value need to be deep traversed
    deep: true,
    created(el, { value, modifiers: { number } }, vnode) {
      const isSetModel = isSet(value);
      addEventListener(el, "change", () => {
        const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map(
          (o2) => number ? looseToNumber(getValue(o2)) : getValue(o2)
        );
        el[assignKey](
          el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
        );
        el._assigning = true;
        nextTick(() => {
          el._assigning = false;
        });
      });
      el[assignKey] = getModelAssigner(vnode);
    },
    // set value in mounted & updated because <select> relies on its children
    // <option>s.
    mounted(el, { value }) {
      setSelected(el, value);
    },
    beforeUpdate(el, _binding, vnode) {
      el[assignKey] = getModelAssigner(vnode);
    },
    updated(el, { value }) {
      if (!el._assigning) {
        setSelected(el, value);
      }
    }
  };
  function setSelected(el, value) {
    const isMultiple = el.multiple;
    const isArrayValue = isArray$1(value);
    if (isMultiple && !isArrayValue && !isSet(value)) {
      return;
    }
    for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
      const option = el.options[i2];
      const optionValue = getValue(option);
      if (isMultiple) {
        if (isArrayValue) {
          const optionType = typeof optionValue;
          if (optionType === "string" || optionType === "number") {
            option.selected = value.some((v2) => String(v2) === String(optionValue));
          } else {
            option.selected = looseIndexOf(value, optionValue) > -1;
          }
        } else {
          option.selected = value.has(optionValue);
        }
      } else if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i2) el.selectedIndex = i2;
        return;
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked) {
    const key = checked ? "_trueValue" : "_falseValue";
    return key in el ? el[key] : checked;
  }
  const vModelDynamic = {
    created(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "created");
    },
    mounted(el, binding, vnode) {
      callModelHook(el, binding, vnode, null, "mounted");
    },
    beforeUpdate(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
    },
    updated(el, binding, vnode, prevVNode) {
      callModelHook(el, binding, vnode, prevVNode, "updated");
    }
  };
  function resolveDynamicModel(tagName, type) {
    switch (tagName) {
      case "SELECT":
        return vModelSelect;
      case "TEXTAREA":
        return vModelText;
      default:
        switch (type) {
          case "checkbox":
            return vModelCheckbox;
          case "radio":
            return vModelRadio;
          default:
            return vModelText;
        }
    }
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
    const modelToUse = resolveDynamicModel(
      el.tagName,
      vnode.props && vnode.props.type
    );
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
  }
  function initVModelForSSR() {
    vModelText.getSSRProps = ({ value }) => ({ value });
    vModelRadio.getSSRProps = ({ value }, vnode) => {
      if (vnode.props && looseEqual(vnode.props.value, value)) {
        return { checked: true };
      }
    };
    vModelCheckbox.getSSRProps = ({ value }, vnode) => {
      if (isArray$1(value)) {
        if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
          return { checked: true };
        }
      } else if (isSet(value)) {
        if (vnode.props && value.has(vnode.props.value)) {
          return { checked: true };
        }
      } else if (value) {
        return { checked: true };
      }
    };
    vModelDynamic.getSSRProps = (binding, vnode) => {
      if (typeof vnode.type !== "string") {
        return;
      }
      const modelToUse = resolveDynamicModel(
        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
        vnode.type.toUpperCase(),
        vnode.props && vnode.props.type
      );
      if (modelToUse.getSSRProps) {
        return modelToUse.getSSRProps(binding, vnode);
      }
    };
  }
  const systemModifiers = ["ctrl", "shift", "alt", "meta"];
  const modifierGuards = {
    stop: (e2) => e2.stopPropagation(),
    prevent: (e2) => e2.preventDefault(),
    self: (e2) => e2.target !== e2.currentTarget,
    ctrl: (e2) => !e2.ctrlKey,
    shift: (e2) => !e2.shiftKey,
    alt: (e2) => !e2.altKey,
    meta: (e2) => !e2.metaKey,
    left: (e2) => "button" in e2 && e2.button !== 0,
    middle: (e2) => "button" in e2 && e2.button !== 1,
    right: (e2) => "button" in e2 && e2.button !== 2,
    exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
  };
  const withModifiers = (fn, modifiers) => {
    const cache = fn._withMods || (fn._withMods = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
      for (let i2 = 0; i2 < modifiers.length; i2++) {
        const guard = modifierGuards[modifiers[i2]];
        if (guard && guard(event, modifiers)) return;
      }
      return fn(event, ...args);
    });
  };
  const keyNames = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  };
  const withKeys = (fn, modifiers) => {
    const cache = fn._withKeys || (fn._withKeys = {});
    const cacheKey = modifiers.join(".");
    return cache[cacheKey] || (cache[cacheKey] = (event) => {
      if (!("key" in event)) {
        return;
      }
      const eventKey = hyphenate(event.key);
      if (modifiers.some(
        (k2) => k2 === eventKey || keyNames[k2] === eventKey
      )) {
        return fn(event);
      }
    });
  };
  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  let enabledHydration = false;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
  }
  const render$1 = (...args) => {
    ensureRenderer().render(...args);
  };
  const hydrate = (...args) => {
    ensureHydrationRenderer().hydrate(...args);
  };
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container) return;
      const component = app._component;
      if (!isFunction$1(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      if (container.nodeType === 1) {
        container.textContent = "";
      }
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  const createSSRApp = (...args) => {
    const app = ensureHydrationRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (container) {
        return mount(container, true, resolveRootNamespace(container));
      }
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString$1(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }
  let ssrDirectiveInitialized = false;
  const initDirectivesForSSR = () => {
    if (!ssrDirectiveInitialized) {
      ssrDirectiveInitialized = true;
      initVModelForSSR();
      initVShowForSSR();
    }
  };
  /**
  * vue v3.5.13
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const compile = () => {
  };
  const vue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    BaseTransition,
    BaseTransitionPropsValidators,
    Comment,
    DeprecationTypes,
    EffectScope,
    ErrorCodes,
    ErrorTypeStrings,
    Fragment,
    KeepAlive,
    ReactiveEffect,
    Static,
    Suspense,
    Teleport,
    Text,
    TrackOpTypes,
    Transition,
    TransitionGroup,
    TriggerOpTypes,
    VueElement,
    assertNumber,
    callWithAsyncErrorHandling,
    callWithErrorHandling,
    camelize,
    capitalize,
    cloneVNode,
    compatUtils,
    compile,
    computed,
    createApp,
    createBlock,
    createCommentVNode,
    createElementBlock,
    createElementVNode: createBaseVNode,
    createHydrationRenderer,
    createPropsRestProxy,
    createRenderer,
    createSSRApp,
    createSlots,
    createStaticVNode,
    createTextVNode,
    createVNode,
    customRef,
    defineAsyncComponent,
    defineComponent,
    defineCustomElement,
    defineEmits,
    defineExpose,
    defineModel,
    defineOptions,
    defineProps,
    defineSSRCustomElement,
    defineSlots,
    devtools,
    effect,
    effectScope,
    getCurrentInstance,
    getCurrentScope,
    getCurrentWatcher,
    getTransitionRawChildren,
    guardReactiveProps,
    h: h$2,
    handleError,
    hasInjectionContext,
    hydrate,
    hydrateOnIdle,
    hydrateOnInteraction,
    hydrateOnMediaQuery,
    hydrateOnVisible,
    initCustomFormatter,
    initDirectivesForSSR,
    inject,
    isMemoSame,
    isProxy,
    isReactive,
    isReadonly,
    isRef,
    isRuntimeOnly,
    isShallow,
    isVNode,
    markRaw,
    mergeDefaults,
    mergeModels,
    mergeProps,
    nextTick,
    normalizeClass,
    normalizeProps,
    normalizeStyle,
    onActivated,
    onBeforeMount,
    onBeforeUnmount,
    onBeforeUpdate,
    onDeactivated,
    onErrorCaptured,
    onMounted,
    onRenderTracked,
    onRenderTriggered,
    onScopeDispose,
    onServerPrefetch,
    onUnmounted,
    onUpdated,
    onWatcherCleanup,
    openBlock,
    popScopeId,
    provide,
    proxyRefs,
    pushScopeId,
    queuePostFlushCb,
    reactive,
    readonly,
    ref,
    registerRuntimeCompiler,
    render: render$1,
    renderList,
    renderSlot,
    resolveComponent,
    resolveDirective,
    resolveDynamicComponent,
    resolveFilter,
    resolveTransitionHooks,
    setBlockTracking,
    setDevtoolsHook,
    setTransitionHooks,
    shallowReactive,
    shallowReadonly,
    shallowRef,
    ssrContextKey,
    ssrUtils,
    stop,
    toDisplayString,
    toHandlerKey,
    toHandlers,
    toRaw,
    toRef,
    toRefs,
    toValue: toValue$3,
    transformVNodeArgs,
    triggerRef,
    unref,
    useAttrs,
    useCssModule,
    useCssVars,
    useHost,
    useId: useId$1,
    useModel,
    useSSRContext,
    useShadowRoot,
    useSlots,
    useTemplateRef,
    useTransitionState,
    vModelCheckbox,
    vModelDynamic,
    vModelRadio,
    vModelSelect,
    vModelText,
    vShow,
    version,
    warn,
    watch,
    watchEffect,
    watchPostEffect,
    watchSyncEffect,
    withAsyncContext,
    withCtx,
    withDefaults,
    withDirectives,
    withKeys,
    withMemo,
    withModifiers,
    withScopeId
  }, Symbol.toStringTag, { value: "Module" }));
  /*!
   * pinia v3.0.4
   * (c) 2025 Eduardo San Martin Morote
   * @license MIT
   */
  let activePinia;
  const setActivePinia = (pinia2) => activePinia = pinia2;
  const piniaSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function isPlainObject$3(o2) {
    return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
  }
  var MutationType;
  (function(MutationType2) {
    MutationType2["direct"] = "direct";
    MutationType2["patchObject"] = "patch object";
    MutationType2["patchFunction"] = "patch function";
  })(MutationType || (MutationType = {}));
  function createPinia() {
    const scope = effectScope(true);
    const state = scope.run(() => ref({}));
    let _p = [];
    let toBeInstalled = [];
    const pinia2 = markRaw({
      install(app) {
        setActivePinia(pinia2);
        pinia2._a = app;
        app.provide(piniaSymbol, pinia2);
        app.config.globalProperties.$pinia = pinia2;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      },
      use(plugin) {
        if (!this._a) {
          toBeInstalled.push(plugin);
        } else {
          _p.push(plugin);
        }
        return this;
      },
      _p,
      // it's actually undefined here
      // @ts-expect-error
      _a: null,
      _e: scope,
      _s: /* @__PURE__ */ new Map(),
      state
    });
    return pinia2;
  }
  const noop$5 = () => {
  };
  function addSubscription(subscriptions, callback, detached, onCleanup = noop$5) {
    subscriptions.add(callback);
    const removeSubscription = () => {
      const isDel = subscriptions.delete(callback);
      isDel && onCleanup();
    };
    if (!detached && getCurrentScope()) {
      onScopeDispose(removeSubscription);
    }
    return removeSubscription;
  }
  function triggerSubscriptions(subscriptions, ...args) {
    subscriptions.forEach((callback) => {
      callback(...args);
    });
  }
  const fallbackRunWithContext = (fn) => fn();
  const ACTION_MARKER = Symbol();
  const ACTION_NAME = Symbol();
  function mergeReactiveObjects(target2, patchToApply) {
    if (target2 instanceof Map && patchToApply instanceof Map) {
      patchToApply.forEach((value, key) => target2.set(key, value));
    } else if (target2 instanceof Set && patchToApply instanceof Set) {
      patchToApply.forEach(target2.add, target2);
    }
    for (const key in patchToApply) {
      if (!patchToApply.hasOwnProperty(key))
        continue;
	  if (key === "__proto__" || key === "constructor") continue;
      const subPatch = patchToApply[key];
      const targetValue = target2[key];
      if (isPlainObject$3(targetValue) && isPlainObject$3(subPatch) && target2.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
        target2[key] = mergeReactiveObjects(targetValue, subPatch);
      } else {
        target2[key] = subPatch;
      }
    }
    return target2;
  }
  const skipHydrateSymbol = (
    /* istanbul ignore next */
    Symbol()
  );
  function shouldHydrate(obj) {
    return !isPlainObject$3(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
  }
  const { assign } = Object;
  function isComputed(o2) {
    return !!(isRef(o2) && o2.effect);
  }
  function createOptionsStore(id, options2, pinia2, hot) {
    const { state, actions, getters } = options2;
    const initialState = pinia2.state.value[id];
    let store;
    function setup() {
      if (!initialState && true) {
        pinia2.state.value[id] = state ? state() : {};
      }
      const localState = toRefs(pinia2.state.value[id]);
      return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
        computedGetters[name] = markRaw(computed(() => {
          setActivePinia(pinia2);
          const store2 = pinia2._s.get(id);
          return getters[name].call(store2, store2);
        }));
        return computedGetters;
      }, {}));
    }
    store = createSetupStore(id, setup, options2, pinia2, hot, true);
    return store;
  }
  function createSetupStore($id, setup, options2 = {}, pinia2, hot, isOptionsStore) {
    let scope;
    const optionsForPlugin = assign({ actions: {} }, options2);
    const $subscribeOptions = { deep: true };
    let isListening;
    let isSyncListening;
    let subscriptions = /* @__PURE__ */ new Set();
    let actionSubscriptions = /* @__PURE__ */ new Set();
    let debuggerEvents;
    const initialState = pinia2.state.value[$id];
    if (!isOptionsStore && !initialState && true) {
      pinia2.state.value[$id] = {};
    }
    ref({});
    let activeListener;
    function $patch(partialStateOrMutator) {
      let subscriptionMutation;
      isListening = isSyncListening = false;
      if (typeof partialStateOrMutator === "function") {
        partialStateOrMutator(pinia2.state.value[$id]);
        subscriptionMutation = {
          type: MutationType.patchFunction,
          storeId: $id,
          events: debuggerEvents
        };
      } else {
        mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
        subscriptionMutation = {
          type: MutationType.patchObject,
          payload: partialStateOrMutator,
          storeId: $id,
          events: debuggerEvents
        };
      }
      const myListenerId = activeListener = Symbol();
      nextTick().then(() => {
        if (activeListener === myListenerId) {
          isListening = true;
        }
      });
      isSyncListening = true;
      triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
    }
    const $reset = isOptionsStore ? function $reset2() {
      const { state } = options2;
      const newState = state ? state() : {};
      this.$patch(($state) => {
        assign($state, newState);
      });
    } : (
      /* istanbul ignore next */
      noop$5
    );
    function $dispose() {
      scope.stop();
      subscriptions.clear();
      actionSubscriptions.clear();
      pinia2._s.delete($id);
    }
    const action = (fn, name = "") => {
      if (ACTION_MARKER in fn) {
        fn[ACTION_NAME] = name;
        return fn;
      }
      const wrappedAction = function() {
        setActivePinia(pinia2);
        const args = Array.from(arguments);
        const afterCallbackSet = /* @__PURE__ */ new Set();
        const onErrorCallbackSet = /* @__PURE__ */ new Set();
        function after(callback) {
          afterCallbackSet.add(callback);
        }
        function onError(callback) {
          onErrorCallbackSet.add(callback);
        }
        triggerSubscriptions(actionSubscriptions, {
          args,
          name: wrappedAction[ACTION_NAME],
          store,
          after,
          onError
        });
        let ret;
        try {
          ret = fn.apply(this && this.$id === $id ? this : store, args);
        } catch (error) {
          triggerSubscriptions(onErrorCallbackSet, error);
          throw error;
        }
        if (ret instanceof Promise) {
          return ret.then((value) => {
            triggerSubscriptions(afterCallbackSet, value);
            return value;
          }).catch((error) => {
            triggerSubscriptions(onErrorCallbackSet, error);
            return Promise.reject(error);
          });
        }
        triggerSubscriptions(afterCallbackSet, ret);
        return ret;
      };
      wrappedAction[ACTION_MARKER] = true;
      wrappedAction[ACTION_NAME] = name;
      return wrappedAction;
    };
    const partialStore = {
      _p: pinia2,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch,
      $reset,
      $subscribe(callback, options22 = {}) {
        const removeSubscription = addSubscription(subscriptions, callback, options22.detached, () => stopWatcher());
        const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
          if (options22.flush === "sync" ? isSyncListening : isListening) {
            callback({
              storeId: $id,
              type: MutationType.direct,
              events: debuggerEvents
            }, state);
          }
        }, assign({}, $subscribeOptions, options22)));
        return removeSubscription;
      },
      $dispose
    };
    const store = reactive(partialStore);
    pinia2._s.set($id, store);
    const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
    const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(() => setup({ action }))));
    for (const key in setupStore) {
      const prop = setupStore[key];
      if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
        if (!isOptionsStore) {
          if (initialState && shouldHydrate(prop)) {
            if (isRef(prop)) {
              prop.value = initialState[key];
            } else {
              mergeReactiveObjects(prop, initialState[key]);
            }
          }
          pinia2.state.value[$id][key] = prop;
        }
      } else if (typeof prop === "function") {
        const actionValue = action(prop, key);
        setupStore[key] = actionValue;
        optionsForPlugin.actions[key] = prop;
      } else ;
    }
    assign(store, setupStore);
    assign(toRaw(store), setupStore);
    Object.defineProperty(store, "$state", {
      get: () => pinia2.state.value[$id],
      set: (state) => {
        $patch(($state) => {
          assign($state, state);
        });
      }
    });
    pinia2._p.forEach((extender) => {
      {
        assign(store, scope.run(() => extender({
          store,
          app: pinia2._a,
          pinia: pinia2,
          options: optionsForPlugin
        })));
      }
    });
    if (initialState && isOptionsStore && options2.hydrate) {
      options2.hydrate(store.$state, initialState);
    }
    isListening = true;
    isSyncListening = true;
    return store;
  }
  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineStore(id, setup, setupOptions) {
    let options2;
    const isSetupStore = typeof setup === "function";
    options2 = isSetupStore ? setupOptions : setup;
    function useStore(pinia2, hot) {
      const hasContext = hasInjectionContext();
      pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
      if (pinia2)
        setActivePinia(pinia2);
      pinia2 = activePinia;
      if (!pinia2._s.has(id)) {
        if (isSetupStore) {
          createSetupStore(id, setup, options2, pinia2);
        } else {
          createOptionsStore(id, options2, pinia2);
        }
      }
      const store = pinia2._s.get(id);
      return store;
    }
    useStore.$id = id;
    return useStore;
  }
  function storeToRefs(store) {
    const rawStore = toRaw(store);
    const refs = {};
    for (const key in rawStore) {
      const value = rawStore[key];
      if (value.effect) {
        refs[key] = // ...
        computed({
          get: () => store[key],
          set(value2) {
            store[key] = value2;
          }
        });
      } else if (isRef(value) || isReactive(value)) {
        refs[key] = // ---
        toRef(store, key);
      }
    }
    return refs;
  }
  const parents = /* @__PURE__ */ new Set();
  const coords = /* @__PURE__ */ new WeakMap();
  const siblings = /* @__PURE__ */ new WeakMap();
  const animations = /* @__PURE__ */ new WeakMap();
  const intersections = /* @__PURE__ */ new WeakMap();
  const intervals = /* @__PURE__ */ new WeakMap();
  const options = /* @__PURE__ */ new WeakMap();
  const debounces = /* @__PURE__ */ new WeakMap();
  const enabled = /* @__PURE__ */ new WeakSet();
  let root;
  let scrollX = 0;
  let scrollY = 0;
  const TGT = "__aa_tgt";
  const DEL = "__aa_del";
  const NEW = "__aa_new";
  const handleMutations = (mutations2) => {
    const elements = getElements(mutations2);
    if (elements) {
      elements.forEach((el) => animate(el));
    }
  };
  const handleResizes = (entries) => {
    entries.forEach((entry) => {
      if (entry.target === root)
        updateAllPos();
      if (coords.has(entry.target))
        updatePos(entry.target);
    });
  };
  function observePosition(el) {
    const oldObserver = intersections.get(el);
    oldObserver === null || oldObserver === void 0 ? void 0 : oldObserver.disconnect();
    let rect = coords.get(el);
    let invocations = 0;
    const buffer2 = 5;
    if (!rect) {
      rect = getCoords(el);
      coords.set(el, rect);
    }
    const { offsetWidth, offsetHeight } = root;
    const rootMargins = [
      rect.top - buffer2,
      offsetWidth - (rect.left + buffer2 + rect.width),
      offsetHeight - (rect.top + buffer2 + rect.height),
      rect.left - buffer2
    ];
    const rootMargin = rootMargins.map((px) => `${-1 * Math.floor(px)}px`).join(" ");
    const observer = new IntersectionObserver(() => {
      ++invocations > 1 && updatePos(el);
    }, {
      root,
      threshold: 1,
      rootMargin
    });
    observer.observe(el);
    intersections.set(el, observer);
  }
  function updatePos(el) {
    clearTimeout(debounces.get(el));
    const optionsOrPlugin = getOptions(el);
    const delay = isPlugin(optionsOrPlugin) ? 500 : optionsOrPlugin.duration;
    debounces.set(el, setTimeout(async () => {
      const currentAnimation = animations.get(el);
      try {
        await (currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.finished);
        coords.set(el, getCoords(el));
        observePosition(el);
      } catch {
      }
    }, delay));
  }
  function updateAllPos() {
    clearTimeout(debounces.get(root));
    debounces.set(root, setTimeout(() => {
      parents.forEach((parent) => forEach(parent, (el) => lowPriority(() => updatePos(el))));
    }, 100));
  }
  function poll(el) {
    setTimeout(() => {
      intervals.set(el, setInterval(() => lowPriority(updatePos.bind(null, el)), 2e3));
    }, Math.round(2e3 * Math.random()));
  }
  function lowPriority(callback) {
    if (typeof requestIdleCallback === "function") {
      requestIdleCallback(() => callback());
    } else {
      requestAnimationFrame(() => callback());
    }
  }
  let mutations;
  let resize;
  const supportedBrowser = typeof window !== "undefined" && "ResizeObserver" in window;
  if (supportedBrowser) {
    root = document.documentElement;
    mutations = new MutationObserver(handleMutations);
    resize = new ResizeObserver(handleResizes);
    window.addEventListener("scroll", () => {
      scrollY = window.scrollY;
      scrollX = window.scrollX;
    });
    resize.observe(root);
  }
  function getElements(mutations2) {
    const observedNodes = mutations2.reduce((nodes, mutation) => {
      return [
        ...nodes,
        ...Array.from(mutation.addedNodes),
        ...Array.from(mutation.removedNodes)
      ];
    }, []);
    const onlyCommentNodesObserved = observedNodes.every((node) => node.nodeName === "#comment");
    if (onlyCommentNodesObserved)
      return false;
    return mutations2.reduce((elements, mutation) => {
      if (elements === false)
        return false;
      if (mutation.target instanceof Element) {
        target(mutation.target);
        if (!elements.has(mutation.target)) {
          elements.add(mutation.target);
          for (let i2 = 0; i2 < mutation.target.children.length; i2++) {
            const child = mutation.target.children.item(i2);
            if (!child)
              continue;
            if (DEL in child) {
              return false;
            }
            target(mutation.target, child);
            elements.add(child);
          }
        }
        if (mutation.removedNodes.length) {
          for (let i2 = 0; i2 < mutation.removedNodes.length; i2++) {
            const child = mutation.removedNodes[i2];
            if (DEL in child) {
              return false;
            }
            if (child instanceof Element) {
              elements.add(child);
              target(mutation.target, child);
              siblings.set(child, [
                mutation.previousSibling,
                mutation.nextSibling
              ]);
            }
          }
        }
      }
      return elements;
    }, /* @__PURE__ */ new Set());
  }
  function target(el, child) {
    if (!child && !(TGT in el))
      Object.defineProperty(el, TGT, { value: el });
    else if (child && !(TGT in child))
      Object.defineProperty(child, TGT, { value: el });
  }
  function animate(el) {
    var _a2;
    const isMounted = el.isConnected;
    const preExisting = coords.has(el);
    if (isMounted && siblings.has(el))
      siblings.delete(el);
    if (animations.has(el)) {
      (_a2 = animations.get(el)) === null || _a2 === void 0 ? void 0 : _a2.cancel();
    }
    if (NEW in el) {
      add(el);
    } else if (preExisting && isMounted) {
      remain(el);
    } else if (preExisting && !isMounted) {
      remove(el);
    } else {
      add(el);
    }
  }
  function raw(str) {
    return Number(str.replace(/[^0-9.\-]/g, ""));
  }
  function getScrollOffset(el) {
    let p2 = el.parentElement;
    while (p2) {
      if (p2.scrollLeft || p2.scrollTop) {
        return { x: p2.scrollLeft, y: p2.scrollTop };
      }
      p2 = p2.parentElement;
    }
    return { x: 0, y: 0 };
  }
  function getCoords(el) {
    const rect = el.getBoundingClientRect();
    const { x: x2, y: y2 } = getScrollOffset(el);
    return {
      top: rect.top + y2,
      left: rect.left + x2,
      width: rect.width,
      height: rect.height
    };
  }
  function getTransitionSizes(el, oldCoords, newCoords) {
    let widthFrom = oldCoords.width;
    let heightFrom = oldCoords.height;
    let widthTo = newCoords.width;
    let heightTo = newCoords.height;
    const styles2 = getComputedStyle(el);
    const sizing = styles2.getPropertyValue("box-sizing");
    if (sizing === "content-box") {
      const paddingY = raw(styles2.paddingTop) + raw(styles2.paddingBottom) + raw(styles2.borderTopWidth) + raw(styles2.borderBottomWidth);
      const paddingX = raw(styles2.paddingLeft) + raw(styles2.paddingRight) + raw(styles2.borderRightWidth) + raw(styles2.borderLeftWidth);
      widthFrom -= paddingX;
      widthTo -= paddingX;
      heightFrom -= paddingY;
      heightTo -= paddingY;
    }
    return [widthFrom, widthTo, heightFrom, heightTo].map(Math.round);
  }
  function getOptions(el) {
    return TGT in el && options.has(el[TGT]) ? options.get(el[TGT]) : { duration: 250, easing: "ease-in-out" };
  }
  function getTarget(el) {
    if (TGT in el)
      return el[TGT];
    return void 0;
  }
  function isEnabled(el) {
    const target2 = getTarget(el);
    return target2 ? enabled.has(target2) : false;
  }
  function forEach(parent, ...callbacks) {
    callbacks.forEach((callback) => callback(parent, options.has(parent)));
    for (let i2 = 0; i2 < parent.children.length; i2++) {
      const child = parent.children.item(i2);
      if (child) {
        callbacks.forEach((callback) => callback(child, options.has(child)));
      }
    }
  }
  function getPluginTuple(pluginReturn) {
    if (Array.isArray(pluginReturn))
      return pluginReturn;
    return [pluginReturn];
  }
  function isPlugin(config2) {
    return typeof config2 === "function";
  }
  function remain(el) {
    const oldCoords = coords.get(el);
    const newCoords = getCoords(el);
    if (!isEnabled(el))
      return coords.set(el, newCoords);
    let animation;
    if (!oldCoords)
      return;
    const pluginOrOptions = getOptions(el);
    if (typeof pluginOrOptions !== "function") {
      const deltaX = oldCoords.left - newCoords.left;
      const deltaY = oldCoords.top - newCoords.top;
      const [widthFrom, widthTo, heightFrom, heightTo] = getTransitionSizes(el, oldCoords, newCoords);
      const start = {
        transform: `translate(${deltaX}px, ${deltaY}px)`
      };
      const end2 = {
        transform: `translate(0, 0)`
      };
      if (widthFrom !== widthTo) {
        start.width = `${widthFrom}px`;
        end2.width = `${widthTo}px`;
      }
      if (heightFrom !== heightTo) {
        start.height = `${heightFrom}px`;
        end2.height = `${heightTo}px`;
      }
      animation = el.animate([start, end2], {
        duration: pluginOrOptions.duration,
        easing: pluginOrOptions.easing
      });
    } else {
      const [keyframes] = getPluginTuple(pluginOrOptions(el, "remain", oldCoords, newCoords));
      animation = new Animation(keyframes);
      animation.play();
    }
    animations.set(el, animation);
    coords.set(el, newCoords);
    animation.addEventListener("finish", updatePos.bind(null, el));
  }
  function add(el) {
    if (NEW in el)
      delete el[NEW];
    const newCoords = getCoords(el);
    coords.set(el, newCoords);
    const pluginOrOptions = getOptions(el);
    if (!isEnabled(el))
      return;
    let animation;
    if (typeof pluginOrOptions !== "function") {
      animation = el.animate([
        { transform: "scale(.98)", opacity: 0 },
        { transform: "scale(0.98)", opacity: 0, offset: 0.5 },
        { transform: "scale(1)", opacity: 1 }
      ], {
        duration: pluginOrOptions.duration * 1.5,
        easing: "ease-in"
      });
    } else {
      const [keyframes] = getPluginTuple(pluginOrOptions(el, "add", newCoords));
      animation = new Animation(keyframes);
      animation.play();
    }
    animations.set(el, animation);
    animation.addEventListener("finish", updatePos.bind(null, el));
  }
  function cleanUp(el, styles2) {
    var _a2;
    el.remove();
    coords.delete(el);
    siblings.delete(el);
    animations.delete(el);
    (_a2 = intersections.get(el)) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    setTimeout(() => {
      if (DEL in el)
        delete el[DEL];
      Object.defineProperty(el, NEW, { value: true, configurable: true });
      if (styles2 && el instanceof HTMLElement) {
        for (const style in styles2) {
          el.style[style] = "";
        }
      }
    }, 0);
  }
  function remove(el) {
    var _a2;
    if (!siblings.has(el) || !coords.has(el))
      return;
    const [prev, next] = siblings.get(el);
    Object.defineProperty(el, DEL, { value: true, configurable: true });
    const finalX = window.scrollX;
    const finalY = window.scrollY;
    if (next && next.parentNode && next.parentNode instanceof Element) {
      next.parentNode.insertBefore(el, next);
    } else if (prev && prev.parentNode) {
      prev.parentNode.appendChild(el);
    } else {
      (_a2 = getTarget(el)) === null || _a2 === void 0 ? void 0 : _a2.appendChild(el);
    }
    if (!isEnabled(el))
      return cleanUp(el);
    const [top, left, width, height] = deletePosition(el);
    const optionsOrPlugin = getOptions(el);
    const oldCoords = coords.get(el);
    if (finalX !== scrollX || finalY !== scrollY) {
      adjustScroll(el, finalX, finalY, optionsOrPlugin);
    }
    let animation;
    let styleReset = {
      position: "absolute",
      top: `${top}px`,
      left: `${left}px`,
      width: `${width}px`,
      height: `${height}px`,
      margin: "0",
      pointerEvents: "none",
      transformOrigin: "center",
      zIndex: "100"
    };
    if (!isPlugin(optionsOrPlugin)) {
      Object.assign(el.style, styleReset);
      animation = el.animate([
        {
          transform: "scale(1)",
          opacity: 1
        },
        {
          transform: "scale(.98)",
          opacity: 0
        }
      ], { duration: optionsOrPlugin.duration, easing: "ease-out" });
    } else {
      const [keyframes, options2] = getPluginTuple(optionsOrPlugin(el, "remove", oldCoords));
      if ((options2 === null || options2 === void 0 ? void 0 : options2.styleReset) !== false) {
        styleReset = (options2 === null || options2 === void 0 ? void 0 : options2.styleReset) || styleReset;
        Object.assign(el.style, styleReset);
      }
      animation = new Animation(keyframes);
      animation.play();
    }
    animations.set(el, animation);
    animation.addEventListener("finish", cleanUp.bind(null, el, styleReset));
  }
  function adjustScroll(el, finalX, finalY, optionsOrPlugin) {
    const scrollDeltaX = scrollX - finalX;
    const scrollDeltaY = scrollY - finalY;
    const scrollBefore = document.documentElement.style.scrollBehavior;
    const scrollBehavior = getComputedStyle(root).scrollBehavior;
    if (scrollBehavior === "smooth") {
      document.documentElement.style.scrollBehavior = "auto";
    }
    window.scrollTo(window.scrollX + scrollDeltaX, window.scrollY + scrollDeltaY);
    if (!el.parentElement)
      return;
    const parent = el.parentElement;
    let lastHeight = parent.clientHeight;
    let lastWidth = parent.clientWidth;
    const startScroll = performance.now();
    function smoothScroll() {
      requestAnimationFrame(() => {
        if (!isPlugin(optionsOrPlugin)) {
          const deltaY = lastHeight - parent.clientHeight;
          const deltaX = lastWidth - parent.clientWidth;
          if (startScroll + optionsOrPlugin.duration > performance.now()) {
            window.scrollTo({
              left: window.scrollX - deltaX,
              top: window.scrollY - deltaY
            });
            lastHeight = parent.clientHeight;
            lastWidth = parent.clientWidth;
            smoothScroll();
          } else {
            document.documentElement.style.scrollBehavior = scrollBefore;
          }
        }
      });
    }
    smoothScroll();
  }
  function deletePosition(el) {
    const oldCoords = coords.get(el);
    const [width, , height] = getTransitionSizes(el, oldCoords, getCoords(el));
    let offsetParent = el.parentElement;
    while (offsetParent && (getComputedStyle(offsetParent).position === "static" || offsetParent instanceof HTMLBodyElement)) {
      offsetParent = offsetParent.parentElement;
    }
    if (!offsetParent)
      offsetParent = document.body;
    const parentStyles = getComputedStyle(offsetParent);
    const parentCoords = coords.get(offsetParent) || getCoords(offsetParent);
    const top = Math.round(oldCoords.top - parentCoords.top) - raw(parentStyles.borderTopWidth);
    const left = Math.round(oldCoords.left - parentCoords.left) - raw(parentStyles.borderLeftWidth);
    return [top, left, width, height];
  }
  function autoAnimate(el, config2 = {}) {
    if (mutations && resize) {
      const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
      const isDisabledDueToReduceMotion = mediaQuery.matches && !isPlugin(config2) && !config2.disrespectUserMotionPreference;
      if (!isDisabledDueToReduceMotion) {
        enabled.add(el);
        if (getComputedStyle(el).position === "static") {
          Object.assign(el.style, { position: "relative" });
        }
        forEach(el, updatePos, poll, (element) => resize === null || resize === void 0 ? void 0 : resize.observe(element));
        if (isPlugin(config2)) {
          options.set(el, config2);
        } else {
          options.set(el, { duration: 250, easing: "ease-in-out", ...config2 });
        }
        mutations.observe(el, { childList: true });
        parents.add(el);
      }
    }
    return Object.freeze({
      parent: el,
      enable: () => {
        enabled.add(el);
      },
      disable: () => {
        enabled.delete(el);
      },
      isEnabled: () => enabled.has(el)
    });
  }
  const vAutoAnimate$1 = {
    mounted: (el, binding) => {
      autoAnimate(el, binding.value || {});
    },
    // ignore ssr see #96:
    getSSRProps: () => ({})
  };
  const vAutoAnimate = vAutoAnimate$1;
  const autoAnimatePlugin = {
    install(app) {
      app.directive("auto-animate", vAutoAnimate);
    }
  };
  var Subscribable = class {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set();
      this.subscribe = this.subscribe.bind(this);
    }
    subscribe(listener) {
      this.listeners.add(listener);
      this.onSubscribe();
      return () => {
        this.listeners.delete(listener);
        this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
    }
    onUnsubscribe() {
    }
  };
  var isServer = typeof window === "undefined" || "Deno" in globalThis;
  function noop$4() {
  }
  function functionalUpdate(updater, input) {
    return typeof updater === "function" ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === "number" && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function resolveStaleTime(staleTime, query) {
    return typeof staleTime === "function" ? staleTime(query) : staleTime;
  }
  function resolveEnabled(enabled2, query) {
    return typeof enabled2 === "function" ? enabled2(query) : enabled2;
  }
  function matchQuery(filters, query) {
    const {
      type = "all",
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;
    if (queryKey) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }
    if (type !== "all") {
      const isActive = query.isActive();
      if (type === "active" && !isActive) {
        return false;
      }
      if (type === "inactive" && isActive) {
        return false;
      }
    }
    if (typeof stale === "boolean" && query.isStale() !== stale) {
      return false;
    }
    if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
      return false;
    }
    if (predicate && !predicate(query)) {
      return false;
    }
    return true;
  }
  function matchMutation(filters, mutation) {
    const { exact, status, predicate, mutationKey } = filters;
    if (mutationKey) {
      if (!mutation.options.mutationKey) {
        return false;
      }
      if (exact) {
        if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }
    if (status && mutation.state.status !== status) {
      return false;
    }
    if (predicate && !predicate(mutation)) {
      return false;
    }
    return true;
  }
  function hashQueryKeyByOptions(queryKey, options2) {
    const hashFn = (options2 == null ? void 0 : options2.queryKeyHashFn) || hashKey;
    return hashFn(queryKey);
  }
  function hashKey(queryKey) {
    return JSON.stringify(
      queryKey,
      (_2, val) => isPlainObject$2(val) ? Object.keys(val).sort().reduce((result, key) => {
        result[key] = val[key];
        return result;
      }, {}) : val
    );
  }
  function partialMatchKey(a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (typeof a2 !== typeof b2) {
      return false;
    }
    if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
      return !Object.keys(b2).some((key) => !partialMatchKey(a2[key], b2[key]));
    }
    return false;
  }
  function replaceEqualDeep(a2, b2) {
    if (a2 === b2) {
      return a2;
    }
    const array = isPlainArray(a2) && isPlainArray(b2);
    if (array || isPlainObject$2(a2) && isPlainObject$2(b2)) {
      const aItems = array ? a2 : Object.keys(a2);
      const aSize = aItems.length;
      const bItems = array ? b2 : Object.keys(b2);
      const bSize = bItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;
      for (let i2 = 0; i2 < bSize; i2++) {
        const key = array ? i2 : bItems[i2];
        if ((!array && aItems.includes(key) || array) && a2[key] === void 0 && b2[key] === void 0) {
          copy[key] = void 0;
          equalItems++;
        } else {
          copy[key] = replaceEqualDeep(a2[key], b2[key]);
          if (copy[key] === a2[key] && a2[key] !== void 0) {
            equalItems++;
          }
        }
      }
      return aSize === bSize && equalItems === aSize ? a2 : copy;
    }
    return b2;
  }
  function shallowEqualObjects(a2, b2) {
    if (!b2 || Object.keys(a2).length !== Object.keys(b2).length) {
      return false;
    }
    for (const key in a2) {
      if (a2[key] !== b2[key]) {
        return false;
      }
    }
    return true;
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function isPlainObject$2(o2) {
    if (!hasObjectPrototype(o2)) {
      return false;
    }
    const ctor = o2.constructor;
    if (ctor === void 0) {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    if (Object.getPrototypeOf(o2) !== Object.prototype) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype(o2) {
    return Object.prototype.toString.call(o2) === "[object Object]";
  }
  function sleep(timeout) {
    return new Promise((resolve2) => {
      setTimeout(resolve2, timeout);
    });
  }
  function replaceData(prevData, data, options2) {
    if (typeof options2.structuralSharing === "function") {
      return options2.structuralSharing(prevData, data);
    } else if (options2.structuralSharing !== false) {
      return replaceEqualDeep(prevData, data);
    }
    return data;
  }
  function addToEnd(items, item, max2 = 0) {
    const newItems = [...items, item];
    return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
  }
  function addToStart(items, item, max2 = 0) {
    const newItems = [item, ...items];
    return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
  }
  var skipToken = Symbol();
  function ensureQueryFn(options2, fetchOptions) {
    if (!options2.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
      return () => fetchOptions.initialPromise;
    }
    if (!options2.queryFn || options2.queryFn === skipToken) {
      return () => Promise.reject(new Error(`Missing queryFn: '${options2.queryHash}'`));
    }
    return options2.queryFn;
  }
  var FocusManager = (_a = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _focused);
      __privateAdd(this, _cleanup);
      __privateAdd(this, _setup);
      __privateSet(this, _setup, (onFocus) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          window.addEventListener("visibilitychange", listener, false);
          return () => {
            window.removeEventListener("visibilitychange", listener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup)) {
        this.setEventListener(__privateGet(this, _setup));
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
        __privateSet(this, _cleanup, void 0);
      }
    }
    setEventListener(setup) {
      var _a2;
      __privateSet(this, _setup, setup);
      (_a2 = __privateGet(this, _cleanup)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup, setup((focused) => {
        if (typeof focused === "boolean") {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      }));
    }
    setFocused(focused) {
      const changed = __privateGet(this, _focused) !== focused;
      if (changed) {
        __privateSet(this, _focused, focused);
        this.onFocus();
      }
    }
    onFocus() {
      const isFocused = this.isFocused();
      this.listeners.forEach((listener) => {
        listener(isFocused);
      });
    }
    isFocused() {
      var _a2;
      if (typeof __privateGet(this, _focused) === "boolean") {
        return __privateGet(this, _focused);
      }
      return ((_a2 = globalThis.document) == null ? void 0 : _a2.visibilityState) !== "hidden";
    }
  }, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
  var focusManager = new FocusManager();
  var OnlineManager = (_b = class extends Subscribable {
    constructor() {
      super();
      __privateAdd(this, _online, true);
      __privateAdd(this, _cleanup2);
      __privateAdd(this, _setup2);
      __privateSet(this, _setup2, (onOnline) => {
        if (!isServer && window.addEventListener) {
          const onlineListener = () => onOnline(true);
          const offlineListener = () => onOnline(false);
          window.addEventListener("online", onlineListener, false);
          window.addEventListener("offline", offlineListener, false);
          return () => {
            window.removeEventListener("online", onlineListener);
            window.removeEventListener("offline", offlineListener);
          };
        }
        return;
      });
    }
    onSubscribe() {
      if (!__privateGet(this, _cleanup2)) {
        this.setEventListener(__privateGet(this, _setup2));
      }
    }
    onUnsubscribe() {
      var _a2;
      if (!this.hasListeners()) {
        (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
        __privateSet(this, _cleanup2, void 0);
      }
    }
    setEventListener(setup) {
      var _a2;
      __privateSet(this, _setup2, setup);
      (_a2 = __privateGet(this, _cleanup2)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
    }
    setOnline(online) {
      const changed = __privateGet(this, _online) !== online;
      if (changed) {
        __privateSet(this, _online, online);
        this.listeners.forEach((listener) => {
          listener(online);
        });
      }
    }
    isOnline() {
      return __privateGet(this, _online);
    }
  }, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _b);
  var onlineManager = new OnlineManager();
  function pendingThenable() {
    let resolve2;
    let reject;
    const thenable = new Promise((_resolve, _reject) => {
      resolve2 = _resolve;
      reject = _reject;
    });
    thenable.status = "pending";
    thenable.catch(() => {
    });
    function finalize(data) {
      Object.assign(thenable, data);
      delete thenable.resolve;
      delete thenable.reject;
    }
    thenable.resolve = (value) => {
      finalize({
        status: "fulfilled",
        value
      });
      resolve2(value);
    };
    thenable.reject = (reason) => {
      finalize({
        status: "rejected",
        reason
      });
      reject(reason);
    };
    return thenable;
  }
  function defaultRetryDelay(failureCount) {
    return Math.min(1e3 * 2 ** failureCount, 3e4);
  }
  function canFetch(networkMode) {
    return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
  }
  var CancelledError = class extends Error {
    constructor(options2) {
      super("CancelledError");
      this.revert = options2 == null ? void 0 : options2.revert;
      this.silent = options2 == null ? void 0 : options2.silent;
    }
  };
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config2) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    const thenable = pendingThenable();
    const cancel = (cancelOptions) => {
      var _a2;
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        (_a2 = config2.abort) == null ? void 0 : _a2.call(config2);
      }
    };
    const cancelRetry = () => {
      isRetryCancelled = true;
    };
    const continueRetry = () => {
      isRetryCancelled = false;
    };
    const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
    const canStart = () => canFetch(config2.networkMode) && config2.canRun();
    const resolve2 = (value) => {
      var _a2;
      if (!isResolved) {
        isResolved = true;
        (_a2 = config2.onSuccess) == null ? void 0 : _a2.call(config2, value);
        continueFn == null ? void 0 : continueFn();
        thenable.resolve(value);
      }
    };
    const reject = (value) => {
      var _a2;
      if (!isResolved) {
        isResolved = true;
        (_a2 = config2.onError) == null ? void 0 : _a2.call(config2, value);
        continueFn == null ? void 0 : continueFn();
        thenable.reject(value);
      }
    };
    const pause = () => {
      return new Promise((continueResolve) => {
        var _a2;
        continueFn = (value) => {
          if (isResolved || canContinue()) {
            continueResolve(value);
          }
        };
        (_a2 = config2.onPause) == null ? void 0 : _a2.call(config2);
      }).then(() => {
        var _a2;
        continueFn = void 0;
        if (!isResolved) {
          (_a2 = config2.onContinue) == null ? void 0 : _a2.call(config2);
        }
      });
    };
    const run = () => {
      if (isResolved) {
        return;
      }
      let promiseOrValue;
      const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
      try {
        promiseOrValue = initialPromise ?? config2.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }
      Promise.resolve(promiseOrValue).then(resolve2).catch((error) => {
        var _a2;
        if (isResolved) {
          return;
        }
        const retry = config2.retry ?? (isServer ? 0 : 3);
        const retryDelay = config2.retryDelay ?? defaultRetryDelay;
        const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
        if (isRetryCancelled || !shouldRetry) {
          reject(error);
          return;
        }
        failureCount++;
        (_a2 = config2.onFail) == null ? void 0 : _a2.call(config2, failureCount, error);
        sleep(delay).then(() => {
          return canContinue() ? void 0 : pause();
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    };
    return {
      promise: thenable,
      cancel,
      continue: () => {
        continueFn == null ? void 0 : continueFn();
        return thenable;
      },
      cancelRetry,
      continueRetry,
      canStart,
      start: () => {
        if (canStart()) {
          run();
        } else {
          pause().then(run);
        }
        return thenable;
      }
    };
  }
  function createNotifyManager() {
    let queue2 = [];
    let transactions = 0;
    let notifyFn = (callback) => {
      callback();
    };
    let batchNotifyFn = (callback) => {
      callback();
    };
    let scheduleFn = (cb) => setTimeout(cb, 0);
    const schedule = (callback) => {
      if (transactions) {
        queue2.push(callback);
      } else {
        scheduleFn(() => {
          notifyFn(callback);
        });
      }
    };
    const flush = () => {
      const originalQueue = queue2;
      queue2 = [];
      if (originalQueue.length) {
        scheduleFn(() => {
          batchNotifyFn(() => {
            originalQueue.forEach((callback) => {
              notifyFn(callback);
            });
          });
        });
      }
    };
    return {
      batch: (callback) => {
        let result;
        transactions++;
        try {
          result = callback();
        } finally {
          transactions--;
          if (!transactions) {
            flush();
          }
        }
        return result;
      },
      /**
       * All calls to the wrapped function will be batched.
       */
      batchCalls: (callback) => {
        return (...args) => {
          schedule(() => {
            callback(...args);
          });
        };
      },
      schedule,
      /**
       * Use this method to set a custom notify function.
       * This can be used to for example wrap notifications with `React.act` while running tests.
       */
      setNotifyFunction: (fn) => {
        notifyFn = fn;
      },
      /**
       * Use this method to set a custom function to batch notifications together into a single tick.
       * By default React Query will use the batch function provided by ReactDOM or React Native.
       */
      setBatchNotifyFunction: (fn) => {
        batchNotifyFn = fn;
      },
      setScheduler: (fn) => {
        scheduleFn = fn;
      }
    };
  }
  var notifyManager = createNotifyManager();
  var Removable = (_c = class {
    constructor() {
      __privateAdd(this, _gcTimeout);
    }
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.gcTime)) {
        __privateSet(this, _gcTimeout, setTimeout(() => {
          this.optionalRemove();
        }, this.gcTime));
      }
    }
    updateGcTime(newGcTime) {
      this.gcTime = Math.max(
        this.gcTime || 0,
        newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
      );
    }
    clearGcTimeout() {
      if (__privateGet(this, _gcTimeout)) {
        clearTimeout(__privateGet(this, _gcTimeout));
        __privateSet(this, _gcTimeout, void 0);
      }
    }
  }, _gcTimeout = new WeakMap(), _c);
  var Query = (_d = class extends Removable {
    constructor(config2) {
      super();
      __privateAdd(this, _Query_instances);
      __privateAdd(this, _initialState);
      __privateAdd(this, _revertState);
      __privateAdd(this, _cache);
      __privateAdd(this, _retryer);
      __privateAdd(this, _defaultOptions);
      __privateAdd(this, _abortSignalConsumed);
      __privateSet(this, _abortSignalConsumed, false);
      __privateSet(this, _defaultOptions, config2.defaultOptions);
      this.setOptions(config2.options);
      this.observers = [];
      __privateSet(this, _cache, config2.cache);
      this.queryKey = config2.queryKey;
      this.queryHash = config2.queryHash;
      __privateSet(this, _initialState, getDefaultState$1(this.options));
      this.state = config2.state ?? __privateGet(this, _initialState);
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    get promise() {
      var _a2;
      return (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
    }
    setOptions(options2) {
      this.options = { ...__privateGet(this, _defaultOptions), ...options2 };
      this.updateGcTime(this.options.gcTime);
    }
    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === "idle") {
        __privateGet(this, _cache).remove(this);
      }
    }
    setData(newData, options2) {
      const data = replaceData(this.state.data, newData, this.options);
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        data,
        type: "success",
        dataUpdatedAt: options2 == null ? void 0 : options2.updatedAt,
        manual: options2 == null ? void 0 : options2.manual
      });
      return data;
    }
    setState(state, setStateOptions) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
    }
    cancel(options2) {
      var _a2, _b2;
      const promise = (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.promise;
      (_b2 = __privateGet(this, _retryer)) == null ? void 0 : _b2.cancel(options2);
      return promise ? promise.then(noop$4).catch(noop$4) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({ silent: true });
    }
    reset() {
      this.destroy();
      this.setState(__privateGet(this, _initialState));
    }
    isActive() {
      return this.observers.some(
        (observer) => resolveEnabled(observer.options.enabled, this) !== false
      );
    }
    isDisabled() {
      if (this.getObserversCount() > 0) {
        return !this.isActive();
      }
      return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
    }
    isStale() {
      if (this.state.isInvalidated) {
        return true;
      }
      if (this.getObserversCount() > 0) {
        return this.observers.some(
          (observer) => observer.getCurrentResult().isStale
        );
      }
      return this.state.data === void 0;
    }
    isStaleByTime(staleTime = 0) {
      return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }
    onFocus() {
      var _a2;
      const observer = this.observers.find((x2) => x2.shouldFetchOnWindowFocus());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
    }
    onOnline() {
      var _a2;
      const observer = this.observers.find((x2) => x2.shouldFetchOnReconnect());
      observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
      (_a2 = __privateGet(this, _retryer)) == null ? void 0 : _a2.continue();
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
      }
    }
    removeObserver(observer) {
      if (this.observers.includes(observer)) {
        this.observers = this.observers.filter((x2) => x2 !== observer);
        if (!this.observers.length) {
          if (__privateGet(this, _retryer)) {
            if (__privateGet(this, _abortSignalConsumed)) {
              __privateGet(this, _retryer).cancel({ revert: true });
            } else {
              __privateGet(this, _retryer).cancelRetry();
            }
          }
          this.scheduleGc();
        }
        __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
      }
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
      }
    }
    fetch(options2, fetchOptions) {
      var _a2, _b2, _c2;
      if (this.state.fetchStatus !== "idle") {
        if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
          this.cancel({ silent: true });
        } else if (__privateGet(this, _retryer)) {
          __privateGet(this, _retryer).continueRetry();
          return __privateGet(this, _retryer).promise;
        }
      }
      if (options2) {
        this.setOptions(options2);
      }
      if (!this.options.queryFn) {
        const observer = this.observers.find((x2) => x2.options.queryFn);
        if (observer) {
          this.setOptions(observer.options);
        }
      }
      const abortController = new AbortController();
      const addSignalProperty = (object) => {
        Object.defineProperty(object, "signal", {
          enumerable: true,
          get: () => {
            __privateSet(this, _abortSignalConsumed, true);
            return abortController.signal;
          }
        });
      };
      const fetchFn = () => {
        const queryFn = ensureQueryFn(this.options, fetchOptions);
        const queryFnContext = {
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext);
        __privateSet(this, _abortSignalConsumed, false);
        if (this.options.persister) {
          return this.options.persister(
            queryFn,
            queryFnContext,
            this
          );
        }
        return queryFn(queryFnContext);
      };
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      (_a2 = this.options.behavior) == null ? void 0 : _a2.onFetch(
        context2,
        this
      );
      __privateSet(this, _revertState, this.state);
      if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b2 = context2.fetchOptions) == null ? void 0 : _b2.meta)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c2 = context2.fetchOptions) == null ? void 0 : _c2.meta });
      }
      const onError = (error) => {
        var _a3, _b3, _c3, _d2;
        if (!(isCancelledError(error) && error.silent)) {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
            type: "error",
            error
          });
        }
        if (!isCancelledError(error)) {
          (_b3 = (_a3 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b3.call(
            _a3,
            error,
            this
          );
          (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
            _c3,
            this.state.data,
            error,
            this
          );
        }
        this.scheduleGc();
      };
      __privateSet(this, _retryer, createRetryer({
        initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
        fn: context2.fetchFn,
        abort: abortController.abort.bind(abortController),
        onSuccess: (data) => {
          var _a3, _b3, _c3, _d2;
          if (data === void 0) {
            onError(new Error(`${this.queryHash} data is undefined`));
            return;
          }
          try {
            this.setData(data);
          } catch (error) {
            onError(error);
            return;
          }
          (_b3 = (_a3 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b3.call(_a3, data, this);
          (_d2 = (_c3 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d2.call(
            _c3,
            data,
            this.state.error,
            this
          );
          this.scheduleGc();
        },
        onError,
        onFail: (failureCount, error) => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
        },
        onPause: () => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
        },
        onContinue: () => {
          __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
        },
        retry: context2.options.retry,
        retryDelay: context2.options.retryDelay,
        networkMode: context2.options.networkMode,
        canRun: () => true
      }));
      return __privateGet(this, _retryer).start();
    }
  }, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          return {
            ...state,
            data: action.data,
            dataUpdateCount: state.dataUpdateCount + 1,
            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: false,
            status: "success",
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const error = action.error;
          if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
            return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
          }
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      __privateGet(this, _cache).notify({ query: this, type: "updated", action });
    });
  }, _d);
  function fetchState(data, options2) {
    return {
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchStatus: canFetch(options2.networkMode) ? "fetching" : "paused",
      ...data === void 0 && {
        error: null,
        status: "pending"
      }
    };
  }
  function getDefaultState$1(options2) {
    const data = typeof options2.initialData === "function" ? options2.initialData() : options2.initialData;
    const hasData = data !== void 0;
    const initialDataUpdatedAt = hasData ? typeof options2.initialDataUpdatedAt === "function" ? options2.initialDataUpdatedAt() : options2.initialDataUpdatedAt : 0;
    return {
      data,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? "success" : "pending",
      fetchStatus: "idle"
    };
  }
  var QueryCache$1 = (_e = class extends Subscribable {
    constructor(config2 = {}) {
      super();
      __privateAdd(this, _queries);
      this.config = config2;
      __privateSet(this, _queries, /* @__PURE__ */ new Map());
    }
    build(client, options2, state) {
      const queryKey = options2.queryKey;
      const queryHash = options2.queryHash ?? hashQueryKeyByOptions(queryKey, options2);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          cache: this,
          queryKey,
          queryHash,
          options: client.defaultQueryOptions(options2),
          state,
          defaultOptions: client.getQueryDefaults(queryKey)
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!__privateGet(this, _queries).has(query.queryHash)) {
        __privateGet(this, _queries).set(query.queryHash, query);
        this.notify({
          type: "added",
          query
        });
      }
    }
    remove(query) {
      const queryInMap = __privateGet(this, _queries).get(query.queryHash);
      if (queryInMap) {
        query.destroy();
        if (queryInMap === query) {
          __privateGet(this, _queries).delete(query.queryHash);
        }
        this.notify({ type: "removed", query });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return __privateGet(this, _queries).get(queryHash);
    }
    getAll() {
      return [...__privateGet(this, _queries).values()];
    }
    find(filters) {
      const defaultedFilters = { exact: true, ...filters };
      return this.getAll().find(
        (query) => matchQuery(defaultedFilters, query)
      );
    }
    findAll(filters = {}) {
      const queries = this.getAll();
      return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.getAll().forEach((query) => {
          query.onOnline();
        });
      });
    }
  }, _queries = new WeakMap(), _e);
  var Mutation = (_f = class extends Removable {
    constructor(config2) {
      super();
      __privateAdd(this, _Mutation_instances);
      __privateAdd(this, _observers);
      __privateAdd(this, _mutationCache);
      __privateAdd(this, _retryer2);
      this.mutationId = config2.mutationId;
      __privateSet(this, _mutationCache, config2.mutationCache);
      __privateSet(this, _observers, []);
      this.state = config2.state || getDefaultState();
      this.setOptions(config2.options);
      this.scheduleGc();
    }
    setOptions(options2) {
      this.options = options2;
      this.updateGcTime(this.options.gcTime);
    }
    get meta() {
      return this.options.meta;
    }
    addObserver(observer) {
      if (!__privateGet(this, _observers).includes(observer)) {
        __privateGet(this, _observers).push(observer);
        this.clearGcTimeout();
        __privateGet(this, _mutationCache).notify({
          type: "observerAdded",
          mutation: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      __privateSet(this, _observers, __privateGet(this, _observers).filter((x2) => x2 !== observer));
      this.scheduleGc();
      __privateGet(this, _mutationCache).notify({
        type: "observerRemoved",
        mutation: this,
        observer
      });
    }
    optionalRemove() {
      if (!__privateGet(this, _observers).length) {
        if (this.state.status === "pending") {
          this.scheduleGc();
        } else {
          __privateGet(this, _mutationCache).remove(this);
        }
      }
    }
    continue() {
      var _a2;
      return ((_a2 = __privateGet(this, _retryer2)) == null ? void 0 : _a2.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
      this.execute(this.state.variables);
    }
    async execute(variables) {
      var _a2, _b2, _c2, _d2, _e2, _f2, _g2, _h2, _i2, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t2;
      __privateSet(this, _retryer2, createRetryer({
        fn: () => {
          if (!this.options.mutationFn) {
            return Promise.reject(new Error("No mutationFn found"));
          }
          return this.options.mutationFn(variables);
        },
        onFail: (failureCount, error) => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
        },
        onPause: () => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
        },
        onContinue: () => {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
        },
        retry: this.options.retry ?? 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => __privateGet(this, _mutationCache).canRun(this)
      }));
      const restored = this.state.status === "pending";
      const isPaused = !__privateGet(this, _retryer2).canStart();
      try {
        if (!restored) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
          await ((_b2 = (_a2 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b2.call(
            _a2,
            variables,
            this
          ));
          const context2 = await ((_d2 = (_c2 = this.options).onMutate) == null ? void 0 : _d2.call(_c2, variables));
          if (context2 !== this.state.context) {
            __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
              type: "pending",
              context: context2,
              variables,
              isPaused
            });
          }
        }
        const data = await __privateGet(this, _retryer2).start();
        await ((_f2 = (_e2 = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f2.call(
          _e2,
          data,
          variables,
          this.state.context,
          this
        ));
        await ((_h2 = (_g2 = this.options).onSuccess) == null ? void 0 : _h2.call(_g2, data, variables, this.state.context));
        await ((_j = (_i2 = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j.call(
          _i2,
          data,
          null,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_l = (_k = this.options).onSettled) == null ? void 0 : _l.call(_k, data, null, variables, this.state.context));
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
        return data;
      } catch (error) {
        try {
          await ((_n = (_m = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
            _m,
            error,
            variables,
            this.state.context,
            this
          ));
          await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
            _o,
            error,
            variables,
            this.state.context
          ));
          await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
            _q,
            void 0,
            error,
            this.state.variables,
            this.state.context,
            this
          ));
          await ((_t2 = (_s = this.options).onSettled) == null ? void 0 : _t2.call(
            _s,
            void 0,
            error,
            variables,
            this.state.context
          ));
          throw error;
        } finally {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
        }
      } finally {
        __privateGet(this, _mutationCache).runNext(this);
      }
    }
  }, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      __privateGet(this, _observers).forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      __privateGet(this, _mutationCache).notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }, _f);
  function getDefaultState() {
    return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: "idle",
      variables: void 0,
      submittedAt: 0
    };
  }
  var MutationCache$1 = (_g = class extends Subscribable {
    constructor(config2 = {}) {
      super();
      __privateAdd(this, _mutations);
      __privateAdd(this, _scopes);
      __privateAdd(this, _mutationId);
      this.config = config2;
      __privateSet(this, _mutations, /* @__PURE__ */ new Set());
      __privateSet(this, _scopes, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationId, 0);
    }
    build(client, options2, state) {
      const mutation = new Mutation({
        mutationCache: this,
        mutationId: ++__privateWrapper(this, _mutationId)._,
        options: client.defaultMutationOptions(options2),
        state
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      __privateGet(this, _mutations).add(mutation);
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          scopedMutations.push(mutation);
        } else {
          __privateGet(this, _scopes).set(scope, [mutation]);
        }
      }
      this.notify({ type: "added", mutation });
    }
    remove(mutation) {
      if (__privateGet(this, _mutations).delete(mutation)) {
        const scope = scopeFor(mutation);
        if (typeof scope === "string") {
          const scopedMutations = __privateGet(this, _scopes).get(scope);
          if (scopedMutations) {
            if (scopedMutations.length > 1) {
              const index = scopedMutations.indexOf(mutation);
              if (index !== -1) {
                scopedMutations.splice(index, 1);
              }
            } else if (scopedMutations[0] === mutation) {
              __privateGet(this, _scopes).delete(scope);
            }
          }
        }
      }
      this.notify({ type: "removed", mutation });
    }
    canRun(mutation) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
        const firstPendingMutation = mutationsWithSameScope == null ? void 0 : mutationsWithSameScope.find(
          (m2) => m2.state.status === "pending"
        );
        return !firstPendingMutation || firstPendingMutation === mutation;
      } else {
        return true;
      }
    }
    runNext(mutation) {
      var _a2;
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const foundMutation = (_a2 = __privateGet(this, _scopes).get(scope)) == null ? void 0 : _a2.find((m2) => m2 !== mutation && m2.state.isPaused);
        return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
      } else {
        return Promise.resolve();
      }
    }
    clear() {
      notifyManager.batch(() => {
        __privateGet(this, _mutations).forEach((mutation) => {
          this.notify({ type: "removed", mutation });
        });
        __privateGet(this, _mutations).clear();
        __privateGet(this, _scopes).clear();
      });
    }
    getAll() {
      return Array.from(__privateGet(this, _mutations));
    }
    find(filters) {
      const defaultedFilters = { exact: true, ...filters };
      return this.getAll().find(
        (mutation) => matchMutation(defaultedFilters, mutation)
      );
    }
    findAll(filters = {}) {
      return this.getAll().filter((mutation) => matchMutation(filters, mutation));
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach((listener) => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      const pausedMutations = this.getAll().filter((x2) => x2.state.isPaused);
      return notifyManager.batch(
        () => Promise.all(
          pausedMutations.map((mutation) => mutation.continue().catch(noop$4))
        )
      );
    }
  }, _mutations = new WeakMap(), _scopes = new WeakMap(), _mutationId = new WeakMap(), _g);
  function scopeFor(mutation) {
    var _a2;
    return (_a2 = mutation.options.scope) == null ? void 0 : _a2.id;
  }
  function infiniteQueryBehavior(pages) {
    return {
      onFetch: (context2, query) => {
        var _a2, _b2, _c2, _d2, _e2;
        const options2 = context2.options;
        const direction = (_c2 = (_b2 = (_a2 = context2.fetchOptions) == null ? void 0 : _a2.meta) == null ? void 0 : _b2.fetchMore) == null ? void 0 : _c2.direction;
        const oldPages = ((_d2 = context2.state.data) == null ? void 0 : _d2.pages) || [];
        const oldPageParams = ((_e2 = context2.state.data) == null ? void 0 : _e2.pageParams) || [];
        let result = { pages: [], pageParams: [] };
        let currentPage = 0;
        const fetchFn = async () => {
          let cancelled = false;
          const addSignalProperty = (object) => {
            Object.defineProperty(object, "signal", {
              enumerable: true,
              get: () => {
                if (context2.signal.aborted) {
                  cancelled = true;
                } else {
                  context2.signal.addEventListener("abort", () => {
                    cancelled = true;
                  });
                }
                return context2.signal;
              }
            });
          };
          const queryFn = ensureQueryFn(context2.options, context2.fetchOptions);
          const fetchPage = async (data, param, previous) => {
            if (cancelled) {
              return Promise.reject();
            }
            if (param == null && data.pages.length) {
              return Promise.resolve(data);
            }
            const queryFnContext = {
              queryKey: context2.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context2.options.meta
            };
            addSignalProperty(queryFnContext);
            const page = await queryFn(
              queryFnContext
            );
            const { maxPages } = context2.options;
            const addTo = previous ? addToStart : addToEnd;
            return {
              pages: addTo(data.pages, page, maxPages),
              pageParams: addTo(data.pageParams, param, maxPages)
            };
          };
          if (direction && oldPages.length) {
            const previous = direction === "backward";
            const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
            const oldData = {
              pages: oldPages,
              pageParams: oldPageParams
            };
            const param = pageParamFn(options2, oldData);
            result = await fetchPage(oldData, param, previous);
          } else {
            const remainingPages = pages ?? oldPages.length;
            do {
              const param = currentPage === 0 ? oldPageParams[0] ?? options2.initialPageParam : getNextPageParam(options2, result);
              if (currentPage > 0 && param == null) {
                break;
              }
              result = await fetchPage(result, param);
              currentPage++;
            } while (currentPage < remainingPages);
          }
          return result;
        };
        if (context2.options.persister) {
          context2.fetchFn = () => {
            var _a3, _b3;
            return (_b3 = (_a3 = context2.options).persister) == null ? void 0 : _b3.call(
              _a3,
              fetchFn,
              {
                queryKey: context2.queryKey,
                meta: context2.options.meta,
                signal: context2.signal
              },
              query
            );
          };
        } else {
          context2.fetchFn = fetchFn;
        }
      }
    };
  }
  function getNextPageParam(options2, { pages, pageParams }) {
    const lastIndex = pages.length - 1;
    return pages.length > 0 ? options2.getNextPageParam(
      pages[lastIndex],
      pages,
      pageParams[lastIndex],
      pageParams
    ) : void 0;
  }
  function getPreviousPageParam(options2, { pages, pageParams }) {
    var _a2;
    return pages.length > 0 ? (_a2 = options2.getPreviousPageParam) == null ? void 0 : _a2.call(options2, pages[0], pages, pageParams[0], pageParams) : void 0;
  }
  var QueryClient$1 = (_h = class {
    constructor(config2 = {}) {
      __privateAdd(this, _queryCache);
      __privateAdd(this, _mutationCache2);
      __privateAdd(this, _defaultOptions2);
      __privateAdd(this, _queryDefaults);
      __privateAdd(this, _mutationDefaults);
      __privateAdd(this, _mountCount);
      __privateAdd(this, _unsubscribeFocus);
      __privateAdd(this, _unsubscribeOnline);
      __privateSet(this, _queryCache, config2.queryCache || new QueryCache$1());
      __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache$1());
      __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
      __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
      __privateSet(this, _mountCount, 0);
    }
    mount() {
      __privateWrapper(this, _mountCount)._++;
      if (__privateGet(this, _mountCount) !== 1)
        return;
      __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
        if (focused) {
          await this.resumePausedMutations();
          __privateGet(this, _queryCache).onFocus();
        }
      }));
      __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
        if (online) {
          await this.resumePausedMutations();
          __privateGet(this, _queryCache).onOnline();
        }
      }));
    }
    unmount() {
      var _a2, _b2;
      __privateWrapper(this, _mountCount)._--;
      if (__privateGet(this, _mountCount) !== 0)
        return;
      (_a2 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a2.call(this);
      __privateSet(this, _unsubscribeFocus, void 0);
      (_b2 = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b2.call(this);
      __privateSet(this, _unsubscribeOnline, void 0);
    }
    isFetching(filters) {
      return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
    }
    isMutating(filters) {
      return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
    }
    getQueryData(queryKey) {
      var _a2;
      const options2 = this.defaultQueryOptions({ queryKey });
      return (_a2 = __privateGet(this, _queryCache).get(options2.queryHash)) == null ? void 0 : _a2.state.data;
    }
    ensureQueryData(options2) {
      const defaultedOptions = this.defaultQueryOptions(options2);
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      const cachedData = query.state.data;
      if (cachedData === void 0) {
        return this.fetchQuery(options2);
      }
      if (options2.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
        void this.prefetchQuery(defaultedOptions);
      }
      return Promise.resolve(cachedData);
    }
    getQueriesData(filters) {
      return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
        const data = state.data;
        return [queryKey, data];
      });
    }
    setQueryData(queryKey, updater, options2) {
      const defaultedOptions = this.defaultQueryOptions({ queryKey });
      const query = __privateGet(this, _queryCache).get(
        defaultedOptions.queryHash
      );
      const prevData = query == null ? void 0 : query.state.data;
      const data = functionalUpdate(updater, prevData);
      if (data === void 0) {
        return void 0;
      }
      return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options2, manual: true });
    }
    setQueriesData(filters, updater, options2) {
      return notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
          queryKey,
          this.setQueryData(queryKey, updater, options2)
        ])
      );
    }
    getQueryState(queryKey) {
      var _a2;
      const options2 = this.defaultQueryOptions({ queryKey });
      return (_a2 = __privateGet(this, _queryCache).get(
        options2.queryHash
      )) == null ? void 0 : _a2.state;
    }
    removeQueries(filters) {
      const queryCache = __privateGet(this, _queryCache);
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          queryCache.remove(query);
        });
      });
    }
    resetQueries(filters, options2) {
      const queryCache = __privateGet(this, _queryCache);
      const refetchFilters = {
        type: "active",
        ...filters
      };
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          query.reset();
        });
        return this.refetchQueries(refetchFilters, options2);
      });
    }
    cancelQueries(filters, cancelOptions = {}) {
      const defaultedCancelOptions = { revert: true, ...cancelOptions };
      const promises = notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
      );
      return Promise.all(promises).then(noop$4).catch(noop$4);
    }
    invalidateQueries(filters, options2 = {}) {
      return notifyManager.batch(() => {
        __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
          query.invalidate();
        });
        if ((filters == null ? void 0 : filters.refetchType) === "none") {
          return Promise.resolve();
        }
        const refetchFilters = {
          ...filters,
          type: (filters == null ? void 0 : filters.refetchType) ?? (filters == null ? void 0 : filters.type) ?? "active"
        };
        return this.refetchQueries(refetchFilters, options2);
      });
    }
    refetchQueries(filters, options2 = {}) {
      const fetchOptions = {
        ...options2,
        cancelRefetch: options2.cancelRefetch ?? true
      };
      const promises = notifyManager.batch(
        () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
          let promise = query.fetch(void 0, fetchOptions);
          if (!fetchOptions.throwOnError) {
            promise = promise.catch(noop$4);
          }
          return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
        })
      );
      return Promise.all(promises).then(noop$4);
    }
    fetchQuery(options2) {
      const defaultedOptions = this.defaultQueryOptions(options2);
      if (defaultedOptions.retry === void 0) {
        defaultedOptions.retry = false;
      }
      const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
      return query.isStaleByTime(
        resolveStaleTime(defaultedOptions.staleTime, query)
      ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }
    prefetchQuery(options2) {
      return this.fetchQuery(options2).then(noop$4).catch(noop$4);
    }
    fetchInfiniteQuery(options2) {
      options2.behavior = infiniteQueryBehavior(options2.pages);
      return this.fetchQuery(options2);
    }
    prefetchInfiniteQuery(options2) {
      return this.fetchInfiniteQuery(options2).then(noop$4).catch(noop$4);
    }
    ensureInfiniteQueryData(options2) {
      options2.behavior = infiniteQueryBehavior(options2.pages);
      return this.ensureQueryData(options2);
    }
    resumePausedMutations() {
      if (onlineManager.isOnline()) {
        return __privateGet(this, _mutationCache2).resumePausedMutations();
      }
      return Promise.resolve();
    }
    getQueryCache() {
      return __privateGet(this, _queryCache);
    }
    getMutationCache() {
      return __privateGet(this, _mutationCache2);
    }
    getDefaultOptions() {
      return __privateGet(this, _defaultOptions2);
    }
    setDefaultOptions(options2) {
      __privateSet(this, _defaultOptions2, options2);
    }
    setQueryDefaults(queryKey, options2) {
      __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
        queryKey,
        defaultOptions: options2
      });
    }
    getQueryDefaults(queryKey) {
      const defaults = [...__privateGet(this, _queryDefaults).values()];
      const result = {};
      defaults.forEach((queryDefault) => {
        if (partialMatchKey(queryKey, queryDefault.queryKey)) {
          Object.assign(result, queryDefault.defaultOptions);
        }
      });
      return result;
    }
    setMutationDefaults(mutationKey, options2) {
      __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
        mutationKey,
        defaultOptions: options2
      });
    }
    getMutationDefaults(mutationKey) {
      const defaults = [...__privateGet(this, _mutationDefaults).values()];
      let result = {};
      defaults.forEach((queryDefault) => {
        if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
          result = { ...result, ...queryDefault.defaultOptions };
        }
      });
      return result;
    }
    defaultQueryOptions(options2) {
      if (options2._defaulted) {
        return options2;
      }
      const defaultedOptions = {
        ...__privateGet(this, _defaultOptions2).queries,
        ...this.getQueryDefaults(options2.queryKey),
        ...options2,
        _defaulted: true
      };
      if (!defaultedOptions.queryHash) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(
          defaultedOptions.queryKey,
          defaultedOptions
        );
      }
      if (defaultedOptions.refetchOnReconnect === void 0) {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
      }
      if (defaultedOptions.throwOnError === void 0) {
        defaultedOptions.throwOnError = !!defaultedOptions.suspense;
      }
      if (!defaultedOptions.networkMode && defaultedOptions.persister) {
        defaultedOptions.networkMode = "offlineFirst";
      }
      if (defaultedOptions.queryFn === skipToken) {
        defaultedOptions.enabled = false;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options2) {
      if (options2 == null ? void 0 : options2._defaulted) {
        return options2;
      }
      return {
        ...__privateGet(this, _defaultOptions2).mutations,
        ...(options2 == null ? void 0 : options2.mutationKey) && this.getMutationDefaults(options2.mutationKey),
        ...options2,
        _defaulted: true
      };
    }
    clear() {
      __privateGet(this, _queryCache).clear();
      __privateGet(this, _mutationCache2).clear();
    }
  }, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _h);
  var QueryObserver = (_i = class extends Subscribable {
    constructor(client, options2) {
      super();
      __privateAdd(this, _QueryObserver_instances);
      __privateAdd(this, _client);
      __privateAdd(this, _currentQuery);
      __privateAdd(this, _currentQueryInitialState);
      __privateAdd(this, _currentResult);
      __privateAdd(this, _currentResultState);
      __privateAdd(this, _currentResultOptions);
      __privateAdd(this, _currentThenable);
      __privateAdd(this, _selectError);
      __privateAdd(this, _selectFn);
      __privateAdd(this, _selectResult);
      // This property keeps track of the last query with defined data.
      // It will be used to pass the previous data and query to the placeholder function between renders.
      __privateAdd(this, _lastQueryWithDefinedData);
      __privateAdd(this, _staleTimeoutId);
      __privateAdd(this, _refetchIntervalId);
      __privateAdd(this, _currentRefetchInterval);
      __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
      this.options = options2;
      __privateSet(this, _client, client);
      __privateSet(this, _selectError, null);
      __privateSet(this, _currentThenable, pendingThenable());
      if (!this.options.experimental_prefetchInRender) {
        __privateGet(this, _currentThenable).reject(
          new Error("experimental_prefetchInRender feature flag is not enabled")
        );
      }
      this.bindMethods();
      this.setOptions(options2);
    }
    bindMethods() {
      this.refetch = this.refetch.bind(this);
    }
    onSubscribe() {
      if (this.listeners.size === 1) {
        __privateGet(this, _currentQuery).addObserver(this);
        if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
          __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
        } else {
          this.updateResult();
        }
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        this.destroy();
      }
    }
    shouldFetchOnReconnect() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnReconnect
      );
    }
    shouldFetchOnWindowFocus() {
      return shouldFetchOn(
        __privateGet(this, _currentQuery),
        this.options,
        this.options.refetchOnWindowFocus
      );
    }
    destroy() {
      this.listeners = /* @__PURE__ */ new Set();
      __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
      __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
      __privateGet(this, _currentQuery).removeObserver(this);
    }
    setOptions(options2, notifyOptions) {
      const prevOptions = this.options;
      const prevQuery = __privateGet(this, _currentQuery);
      this.options = __privateGet(this, _client).defaultQueryOptions(options2);
      if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
        throw new Error(
          "Expected enabled to be a boolean or a callback that returns a boolean"
        );
      }
      __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
      __privateGet(this, _currentQuery).setOptions(this.options);
      if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
        __privateGet(this, _client).getQueryCache().notify({
          type: "observerOptionsUpdated",
          query: __privateGet(this, _currentQuery),
          observer: this
        });
      }
      const mounted = this.hasListeners();
      if (mounted && shouldFetchOptionally(
        __privateGet(this, _currentQuery),
        prevQuery,
        this.options,
        prevOptions
      )) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      }
      this.updateResult(notifyOptions);
      if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
        __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
      }
      const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
      if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
        __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
      }
    }
    getOptimisticResult(options2) {
      const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), options2);
      const result = this.createResult(query, options2);
      if (shouldAssignObserverCurrentProperties(this, result)) {
        __privateSet(this, _currentResult, result);
        __privateSet(this, _currentResultOptions, this.options);
        __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
      }
      return result;
    }
    getCurrentResult() {
      return __privateGet(this, _currentResult);
    }
    trackResult(result, onPropTracked) {
      const trackedResult = {};
      Object.keys(result).forEach((key) => {
        Object.defineProperty(trackedResult, key, {
          configurable: false,
          enumerable: true,
          get: () => {
            this.trackProp(key);
            onPropTracked == null ? void 0 : onPropTracked(key);
            return result[key];
          }
        });
      });
      return trackedResult;
    }
    trackProp(key) {
      __privateGet(this, _trackedProps).add(key);
    }
    getCurrentQuery() {
      return __privateGet(this, _currentQuery);
    }
    refetch({ ...options2 } = {}) {
      return this.fetch({
        ...options2
      });
    }
    fetchOptimistic(options2) {
      const defaultedOptions = __privateGet(this, _client).defaultQueryOptions(options2);
      const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), defaultedOptions);
      return query.fetch().then(() => this.createResult(query, defaultedOptions));
    }
    fetch(fetchOptions) {
      return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
        ...fetchOptions,
        cancelRefetch: fetchOptions.cancelRefetch ?? true
      }).then(() => {
        this.updateResult();
        return __privateGet(this, _currentResult);
      });
    }
    createResult(query, options2) {
      var _a2;
      const prevQuery = __privateGet(this, _currentQuery);
      const prevOptions = this.options;
      const prevResult = __privateGet(this, _currentResult);
      const prevResultState = __privateGet(this, _currentResultState);
      const prevResultOptions = __privateGet(this, _currentResultOptions);
      const queryChange = query !== prevQuery;
      const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
      const { state } = query;
      let newState = { ...state };
      let isPlaceholderData = false;
      let data;
      if (options2._optimisticResults) {
        const mounted = this.hasListeners();
        const fetchOnMount = !mounted && shouldFetchOnMount(query, options2);
        const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options2, prevOptions);
        if (fetchOnMount || fetchOptionally) {
          newState = {
            ...newState,
            ...fetchState(state.data, query.options)
          };
        }
        if (options2._optimisticResults === "isRestoring") {
          newState.fetchStatus = "idle";
        }
      }
      let { error, errorUpdatedAt, status } = newState;
      if (options2.select && newState.data !== void 0) {
        if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options2.select === __privateGet(this, _selectFn)) {
          data = __privateGet(this, _selectResult);
        } else {
          try {
            __privateSet(this, _selectFn, options2.select);
            data = options2.select(newState.data);
            data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options2);
            __privateSet(this, _selectResult, data);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      } else {
        data = newState.data;
      }
      if (options2.placeholderData !== void 0 && data === void 0 && status === "pending") {
        let placeholderData;
        if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options2.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
          placeholderData = prevResult.data;
        } else {
          placeholderData = typeof options2.placeholderData === "function" ? options2.placeholderData(
            (_a2 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a2.state.data,
            __privateGet(this, _lastQueryWithDefinedData)
          ) : options2.placeholderData;
          if (options2.select && placeholderData !== void 0) {
            try {
              placeholderData = options2.select(placeholderData);
              __privateSet(this, _selectError, null);
            } catch (selectError) {
              __privateSet(this, _selectError, selectError);
            }
          }
        }
        if (placeholderData !== void 0) {
          status = "success";
          data = replaceData(
            prevResult == null ? void 0 : prevResult.data,
            placeholderData,
            options2
          );
          isPlaceholderData = true;
        }
      }
      if (__privateGet(this, _selectError)) {
        error = __privateGet(this, _selectError);
        data = __privateGet(this, _selectResult);
        errorUpdatedAt = Date.now();
        status = "error";
      }
      const isFetching = newState.fetchStatus === "fetching";
      const isPending = status === "pending";
      const isError = status === "error";
      const isLoading = isPending && isFetching;
      const hasData = data !== void 0;
      const result = {
        status,
        fetchStatus: newState.fetchStatus,
        isPending,
        isSuccess: status === "success",
        isError,
        isInitialLoading: isLoading,
        isLoading,
        data,
        dataUpdatedAt: newState.dataUpdatedAt,
        error,
        errorUpdatedAt,
        failureCount: newState.fetchFailureCount,
        failureReason: newState.fetchFailureReason,
        errorUpdateCount: newState.errorUpdateCount,
        isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
        isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
        isFetching,
        isRefetching: isFetching && !isPending,
        isLoadingError: isError && !hasData,
        isPaused: newState.fetchStatus === "paused",
        isPlaceholderData,
        isRefetchError: isError && hasData,
        isStale: isStale(query, options2),
        refetch: this.refetch,
        promise: __privateGet(this, _currentThenable)
      };
      const nextResult = result;
      if (this.options.experimental_prefetchInRender) {
        const finalizeThenableIfPossible = (thenable) => {
          if (nextResult.status === "error") {
            thenable.reject(nextResult.error);
          } else if (nextResult.data !== void 0) {
            thenable.resolve(nextResult.data);
          }
        };
        const recreateThenable = () => {
          const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
          finalizeThenableIfPossible(pending);
        };
        const prevThenable = __privateGet(this, _currentThenable);
        switch (prevThenable.status) {
          case "pending":
            if (query.queryHash === prevQuery.queryHash) {
              finalizeThenableIfPossible(prevThenable);
            }
            break;
          case "fulfilled":
            if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
              recreateThenable();
            }
            break;
          case "rejected":
            if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
              recreateThenable();
            }
            break;
        }
      }
      return nextResult;
    }
    updateResult(notifyOptions) {
      const prevResult = __privateGet(this, _currentResult);
      const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
      __privateSet(this, _currentResultOptions, this.options);
      if (__privateGet(this, _currentResultState).data !== void 0) {
        __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
      }
      if (shallowEqualObjects(nextResult, prevResult)) {
        return;
      }
      __privateSet(this, _currentResult, nextResult);
      const defaultNotifyOptions = {};
      const shouldNotifyListeners = () => {
        if (!prevResult) {
          return true;
        }
        const { notifyOnChangeProps } = this.options;
        const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
        if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
          return true;
        }
        const includedProps = new Set(
          notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
        );
        if (this.options.throwOnError) {
          includedProps.add("error");
        }
        return Object.keys(__privateGet(this, _currentResult)).some((key) => {
          const typedKey = key;
          const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
          return changed && includedProps.has(typedKey);
        });
      };
      if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
        defaultNotifyOptions.listeners = true;
      }
      __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
    }
    onQueryUpdate() {
      this.updateResult();
      if (this.hasListeners()) {
        __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
      }
    }
  }, _client = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    let promise = __privateGet(this, _currentQuery).fetch(
      this.options,
      fetchOptions
    );
    if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
      promise = promise.catch(noop$4);
    }
    return promise;
  }, updateStaleTimeout_fn = function() {
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      __privateGet(this, _currentQuery)
    );
    if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
    const timeout = time + 1;
    __privateSet(this, _staleTimeoutId, setTimeout(() => {
      if (!__privateGet(this, _currentResult).isStale) {
        this.updateResult();
      }
    }, timeout));
  }, computeRefetchInterval_fn = function() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
  }, updateRefetchInterval_fn = function(nextInterval) {
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateSet(this, _currentRefetchInterval, nextInterval);
    if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
      return;
    }
    __privateSet(this, _refetchIntervalId, setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      }
    }, __privateGet(this, _currentRefetchInterval)));
  }, updateTimers_fn = function() {
    __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
  }, clearStaleTimeout_fn = function() {
    if (__privateGet(this, _staleTimeoutId)) {
      clearTimeout(__privateGet(this, _staleTimeoutId));
      __privateSet(this, _staleTimeoutId, void 0);
    }
  }, clearRefetchInterval_fn = function() {
    if (__privateGet(this, _refetchIntervalId)) {
      clearInterval(__privateGet(this, _refetchIntervalId));
      __privateSet(this, _refetchIntervalId, void 0);
    }
  }, updateQuery_fn = function() {
    const query = __privateGet(this, _client).getQueryCache().build(__privateGet(this, _client), this.options);
    if (query === __privateGet(this, _currentQuery)) {
      return;
    }
    const prevQuery = __privateGet(this, _currentQuery);
    __privateSet(this, _currentQuery, query);
    __privateSet(this, _currentQueryInitialState, query.state);
    if (this.hasListeners()) {
      prevQuery == null ? void 0 : prevQuery.removeObserver(this);
      query.addObserver(this);
    }
  }, notify_fn = function(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(__privateGet(this, _currentResult));
        });
      }
      __privateGet(this, _client).getQueryCache().notify({
        query: __privateGet(this, _currentQuery),
        type: "observerResultsUpdated"
      });
    });
  }, _i);
  function shouldLoadOnMount(query, options2) {
    return resolveEnabled(options2.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options2.retryOnMount === false);
  }
  function shouldFetchOnMount(query, options2) {
    return shouldLoadOnMount(query, options2) || query.state.data !== void 0 && shouldFetchOn(query, options2, options2.refetchOnMount);
  }
  function shouldFetchOn(query, options2, field) {
    if (resolveEnabled(options2.enabled, query) !== false) {
      const value = typeof field === "function" ? field(query) : field;
      return value === "always" || value !== false && isStale(query, options2);
    }
    return false;
  }
  function shouldFetchOptionally(query, prevQuery, options2, prevOptions) {
    return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options2.suspense || query.state.status !== "error") && isStale(query, options2);
  }
  function isStale(query, options2) {
    return resolveEnabled(options2.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options2.staleTime, query));
  }
  function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
    if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
      return true;
    }
    return false;
  }
  var VUE_QUERY_CLIENT = "VUE_QUERY_CLIENT";
  function getClientKey(key) {
    const suffix = key ? `:${key}` : "";
    return `${VUE_QUERY_CLIENT}${suffix}`;
  }
  function updateState(state, update) {
    Object.keys(state).forEach((key) => {
      state[key] = update[key];
    });
  }
  function _cloneDeep(value, customize, currentKey = "", currentLevel = 0) {
    if (customize) {
      const result = customize(value, currentKey, currentLevel);
      if (result === void 0 && isRef(value)) {
        return result;
      }
      if (result !== void 0) {
        return result;
      }
    }
    if (Array.isArray(value)) {
      return value.map(
        (val, index) => _cloneDeep(val, customize, String(index), currentLevel + 1)
      );
    }
    if (typeof value === "object" && isPlainObject$1(value)) {
      const entries = Object.entries(value).map(([key, val]) => [
        key,
        _cloneDeep(val, customize, key, currentLevel + 1)
      ]);
      return Object.fromEntries(entries);
    }
    return value;
  }
  function cloneDeep(value, customize) {
    return _cloneDeep(value, customize);
  }
  function cloneDeepUnref(obj, unrefGetters = false) {
    return cloneDeep(obj, (val, key, level) => {
      if (level === 1 && key === "queryKey") {
        return cloneDeepUnref(val, true);
      }
      if (unrefGetters && isFunction(val)) {
        return cloneDeepUnref(val(), unrefGetters);
      }
      if (isRef(val)) {
        return cloneDeepUnref(unref(val), unrefGetters);
      }
      return void 0;
    });
  }
  function isPlainObject$1(value) {
    if (Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
  }
  function isFunction(value) {
    return typeof value === "function";
  }
  function shouldThrowError(throwOnError, params) {
    if (typeof throwOnError === "function") {
      return throwOnError(...params);
    }
    return !!throwOnError;
  }
  function useQueryClient(id = "") {
    if (!hasInjectionContext()) {
      throw new Error(
        "vue-query hooks can only be used inside setup() function or functions that support injection context."
      );
    }
    const key = getClientKey(id);
    const queryClient2 = inject(key);
    if (!queryClient2) {
      throw new Error(
        "No 'queryClient' found in Vue context, use 'VueQueryPlugin' to properly initialize the library."
      );
    }
    return queryClient2;
  }
  var QueryCache = class extends QueryCache$1 {
    find(filters) {
      return super.find(cloneDeepUnref(filters));
    }
    findAll(filters = {}) {
      return super.findAll(cloneDeepUnref(filters));
    }
  };
  var MutationCache = class extends MutationCache$1 {
    find(filters) {
      return super.find(cloneDeepUnref(filters));
    }
    findAll(filters = {}) {
      return super.findAll(cloneDeepUnref(filters));
    }
  };
  var QueryClient = class extends QueryClient$1 {
    constructor(config2 = {}) {
      const vueQueryConfig = {
        defaultOptions: config2.defaultOptions,
        queryCache: config2.queryCache || new QueryCache(),
        mutationCache: config2.mutationCache || new MutationCache()
      };
      super(vueQueryConfig);
      this.isRestoring = ref(false);
    }
    isFetching(filters = {}) {
      return super.isFetching(cloneDeepUnref(filters));
    }
    isMutating(filters = {}) {
      return super.isMutating(cloneDeepUnref(filters));
    }
    getQueryData(queryKey) {
      return super.getQueryData(cloneDeepUnref(queryKey));
    }
    ensureQueryData(options2) {
      return super.ensureQueryData(cloneDeepUnref(options2));
    }
    getQueriesData(filters) {
      return super.getQueriesData(cloneDeepUnref(filters));
    }
    setQueryData(queryKey, updater, options2 = {}) {
      return super.setQueryData(
        cloneDeepUnref(queryKey),
        updater,
        cloneDeepUnref(options2)
      );
    }
    setQueriesData(filters, updater, options2 = {}) {
      return super.setQueriesData(
        cloneDeepUnref(filters),
        updater,
        cloneDeepUnref(options2)
      );
    }
    getQueryState(queryKey) {
      return super.getQueryState(cloneDeepUnref(queryKey));
    }
    removeQueries(filters = {}) {
      return super.removeQueries(cloneDeepUnref(filters));
    }
    resetQueries(filters = {}, options2 = {}) {
      return super.resetQueries(cloneDeepUnref(filters), cloneDeepUnref(options2));
    }
    cancelQueries(filters = {}, options2 = {}) {
      return super.cancelQueries(cloneDeepUnref(filters), cloneDeepUnref(options2));
    }
    invalidateQueries(filters = {}, options2 = {}) {
      const filtersCloned = cloneDeepUnref(filters);
      const optionsCloned = cloneDeepUnref(options2);
      super.invalidateQueries(
        { ...filtersCloned, refetchType: "none" },
        optionsCloned
      );
      if (filtersCloned.refetchType === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filtersCloned,
        type: filtersCloned.refetchType ?? filtersCloned.type ?? "active"
      };
      return nextTick().then(() => {
        return super.refetchQueries(refetchFilters, optionsCloned);
      });
    }
    refetchQueries(filters = {}, options2 = {}) {
      return super.refetchQueries(
        cloneDeepUnref(filters),
        cloneDeepUnref(options2)
      );
    }
    fetchQuery(options2) {
      return super.fetchQuery(cloneDeepUnref(options2));
    }
    prefetchQuery(options2) {
      return super.prefetchQuery(cloneDeepUnref(options2));
    }
    fetchInfiniteQuery(options2) {
      return super.fetchInfiniteQuery(cloneDeepUnref(options2));
    }
    prefetchInfiniteQuery(options2) {
      return super.prefetchInfiniteQuery(cloneDeepUnref(options2));
    }
    setDefaultOptions(options2) {
      super.setDefaultOptions(cloneDeepUnref(options2));
    }
    setQueryDefaults(queryKey, options2) {
      super.setQueryDefaults(cloneDeepUnref(queryKey), cloneDeepUnref(options2));
    }
    getQueryDefaults(queryKey) {
      return super.getQueryDefaults(cloneDeepUnref(queryKey));
    }
    setMutationDefaults(mutationKey, options2) {
      super.setMutationDefaults(
        cloneDeepUnref(mutationKey),
        cloneDeepUnref(options2)
      );
    }
    getMutationDefaults(mutationKey) {
      return super.getMutationDefaults(cloneDeepUnref(mutationKey));
    }
  };
  var VueQueryPlugin = {
    install: (app, options2 = {}) => {
      const clientKey = getClientKey(options2.queryClientKey);
      let client;
      if ("queryClient" in options2 && options2.queryClient) {
        client = options2.queryClient;
      } else {
        const clientConfig = "queryClientConfig" in options2 ? options2.queryClientConfig : void 0;
        client = new QueryClient(clientConfig);
      }
      if (!isServer) {
        client.mount();
      }
      let persisterUnmount = () => {
      };
      if (options2.clientPersister) {
        client.isRestoring.value = true;
        const [unmount, promise] = options2.clientPersister(client);
        persisterUnmount = unmount;
        promise.then(() => {
          var _a2;
          client.isRestoring.value = false;
          (_a2 = options2.clientPersisterOnSuccess) == null ? void 0 : _a2.call(options2, client);
        });
      }
      const cleanup = () => {
        client.unmount();
        persisterUnmount();
      };
      if (app.onUnmount) {
        app.onUnmount(cleanup);
      } else {
        const originalUnmount = app.unmount;
        app.unmount = function vueQueryUnmount() {
          cleanup();
          originalUnmount();
        };
      }
      {
        app.provide(clientKey, client);
      }
    }
  };
  function useBaseQuery(Observer, options2, queryClient2) {
    const client = useQueryClient();
    const defaultedOptions = computed(() => {
      const clonedOptions = cloneDeepUnref(options2);
      if (typeof clonedOptions.enabled === "function") {
        clonedOptions.enabled = clonedOptions.enabled();
      }
      const defaulted = client.defaultQueryOptions(clonedOptions);
      defaulted._optimisticResults = client.isRestoring.value ? "isRestoring" : "optimistic";
      return defaulted;
    });
    const observer = new Observer(client, defaultedOptions.value);
    const state = shallowReactive(observer.getCurrentResult());
    let unsubscribe = () => {
    };
    watch(
      client.isRestoring,
      (isRestoring) => {
        if (!isRestoring) {
          unsubscribe();
          unsubscribe = observer.subscribe((result) => {
            updateState(state, result);
          });
        }
      },
      { immediate: true }
    );
    const updater = () => {
      observer.setOptions(defaultedOptions.value);
      updateState(state, observer.getCurrentResult());
    };
    watch(defaultedOptions, updater);
    onScopeDispose(() => {
      unsubscribe();
    });
    const refetch = (...args) => {
      updater();
      return state.refetch(...args);
    };
    const suspense = () => {
      return new Promise(
        (resolve2, reject) => {
          let stopWatch = () => {
          };
          const run = () => {
            if (defaultedOptions.value.enabled !== false) {
              observer.setOptions(defaultedOptions.value);
              const optimisticResult = observer.getOptimisticResult(
                defaultedOptions.value
              );
              if (optimisticResult.isStale) {
                stopWatch();
                observer.fetchOptimistic(defaultedOptions.value).then(resolve2, (error) => {
                  if (shouldThrowError(defaultedOptions.value.throwOnError, [
                    error,
                    observer.getCurrentQuery()
                  ])) {
                    reject(error);
                  } else {
                    resolve2(observer.getCurrentResult());
                  }
                });
              } else {
                stopWatch();
                resolve2(optimisticResult);
              }
            }
          };
          run();
          stopWatch = watch(defaultedOptions, run);
        }
      );
    };
    watch(
      () => state.error,
      (error) => {
        if (state.isError && !state.isFetching && shouldThrowError(defaultedOptions.value.throwOnError, [
          error,
          observer.getCurrentQuery()
        ])) {
          throw error;
        }
      }
    );
    const readonlyState = state;
    const object = toRefs(readonlyState);
    for (const key in state) {
      if (typeof state[key] === "function") {
        object[key] = state[key];
      }
    }
    object.suspense = suspense;
    object.refetch = refetch;
    return object;
  }
  function useQuery(options2, queryClient2) {
    return useBaseQuery(QueryObserver, options2);
  }
  const unleadingSlashIt = (str) => {
    return str.replace(/^\//, "");
  };
  const getApiUrl = (path) => {
    path = unleadingSlashIt(path);
    return `https://opuscapita.com/wp-json/compliance-map/v1/${path}`;
  };
  const getFetchOptions = (override = {}) => {
    return {
      method: "GET",
      headers: {
        "Content-Type": "application/json"
      },
      ...override
    };
  };
  function b642ab(base64string) {
    return Uint8Array.from(atob(base64string), (c2) => c2.charCodeAt(0));
  }
  async function decryptApiData(data, parseJSON = true) {
    try {
      let [iv, encrypted] = data.split(".");
      iv = b642ab(iv);
      encrypted = b642ab(encrypted);
      const cryptoKey = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(atob("MmRiN2E4YmQ2Y2Q1MTlkMA==")),
        { name: "AES-GCM", length: 128 },
        false,
        ["decrypt"]
      );
      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv, tagLength: 128 },
        cryptoKey,
        encrypted
      );
      const decryptedString = new TextDecoder().decode(decrypted);
      if (parseJSON) {
        return JSON.parse(decryptedString);
      }
      return decryptedString;
    } catch (error) {
      console.error(error);
      throw new Error("Could not decrypt countries");
    }
  }
  const getCountries = async () => {
    const response = await fetch(getApiUrl("/countries/all"), getFetchOptions());
    if (!response.ok) throw new Error(response.statusText);
    const rawData = await response.json();
    if (!rawData.data) throw new Error(rawData.message);
    const { data } = rawData;
    if (!data.countries) throw new Error("Couldn't find countries");
    const { countries } = data;
    return await decryptApiData(countries);
  };
  function isArray(value) {
    return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    let result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function toString$2(value) {
    return value == null ? "" : baseToString(value);
  }
  function isString(value) {
    return typeof value === "string";
  }
  function isNumber(value) {
    return typeof value === "number";
  }
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
  }
  function isObject$2(value) {
    return typeof value === "object";
  }
  function isObjectLike(value) {
    return isObject$2(value) && value !== null;
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isBlank(value) {
    return !value.trim().length;
  }
  function getTag(value) {
    return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
  }
  const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
  const PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
  const MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
  const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
  const hasOwn = Object.prototype.hasOwnProperty;
  class KeyStore {
    constructor(keys) {
      this._keys = [];
      this._keyMap = {};
      let totalWeight = 0;
      keys.forEach((key) => {
        let obj = createKey(key);
        this._keys.push(obj);
        this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      });
      this._keys.forEach((key) => {
        key.weight /= totalWeight;
      });
    }
    get(keyId) {
      return this._keyMap[keyId];
    }
    keys() {
      return this._keys;
    }
    toJSON() {
      return JSON.stringify(this._keys);
    }
  }
  function createKey(key) {
    let path = null;
    let id = null;
    let src = null;
    let weight = 1;
    let getFn = null;
    if (isString(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, "name")) {
        throw new Error(MISSING_KEY_PROPERTY("name"));
      }
      const name = key.name;
      src = name;
      if (hasOwn.call(key, "weight")) {
        weight = key.weight;
        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
        }
      }
      path = createKeyPath(name);
      id = createKeyId(name);
      getFn = key.getFn;
    }
    return { path, id, weight, src, getFn };
  }
  function createKeyPath(key) {
    return isArray(key) ? key : key.split(".");
  }
  function createKeyId(key) {
    return isArray(key) ? key.join(".") : key;
  }
  function get$1(obj, path) {
    let list = [];
    let arr = false;
    const deepGet = (obj2, path2, index) => {
      if (!isDefined(obj2)) {
        return;
      }
      if (!path2[index]) {
        list.push(obj2);
      } else {
        let key = path2[index];
        const value = obj2[key];
        if (!isDefined(value)) {
          return;
        }
        if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(toString$2(value));
        } else if (isArray(value)) {
          arr = true;
          for (let i2 = 0, len = value.length; i2 < len; i2 += 1) {
            deepGet(value[i2], path2, index + 1);
          }
        } else if (path2.length) {
          deepGet(value, path2, index + 1);
        }
      }
    };
    deepGet(obj, isString(path) ? path.split(".") : path, 0);
    return arr ? list : list[0];
  }
  const MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };
  const BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: (a2, b2) => a2.score === b2.score ? a2.idx < b2.idx ? -1 : 1 : a2.score < b2.score ? -1 : 1
  };
  const FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };
  const AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get$1,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false,
    // The weight to determine how much field length norm effects scoring.
    fieldNormWeight: 1
  };
  var Config = {
    ...BasicOptions,
    ...MatchOptions,
    ...FuzzyOptions,
    ...AdvancedOptions
  };
  const SPACE = /[^ ]+/g;
  function norm(weight = 1, mantissa = 3) {
    const cache = /* @__PURE__ */ new Map();
    const m2 = Math.pow(10, mantissa);
    return {
      get(value) {
        const numTokens = value.match(SPACE).length;
        if (cache.has(numTokens)) {
          return cache.get(numTokens);
        }
        const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
        const n2 = parseFloat(Math.round(norm2 * m2) / m2);
        cache.set(numTokens, n2);
        return n2;
      },
      clear() {
        cache.clear();
      }
    };
  }
  class FuseIndex {
    constructor({
      getFn = Config.getFn,
      fieldNormWeight = Config.fieldNormWeight
    } = {}) {
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }
    setSources(docs = []) {
      this.docs = docs;
    }
    setIndexRecords(records = []) {
      this.records = records;
    }
    setKeys(keys = []) {
      this.keys = keys;
      this._keysMap = {};
      keys.forEach((key, idx) => {
        this._keysMap[key.id] = idx;
      });
    }
    create() {
      if (this.isCreated || !this.docs.length) {
        return;
      }
      this.isCreated = true;
      if (isString(this.docs[0])) {
        this.docs.forEach((doc2, docIndex) => {
          this._addString(doc2, docIndex);
        });
      } else {
        this.docs.forEach((doc2, docIndex) => {
          this._addObject(doc2, docIndex);
        });
      }
      this.norm.clear();
    }
    // Adds a doc to the end of the index
    add(doc2) {
      const idx = this.size();
      if (isString(doc2)) {
        this._addString(doc2, idx);
      } else {
        this._addObject(doc2, idx);
      }
    }
    // Removes the doc at the specified index of the index
    removeAt(idx) {
      this.records.splice(idx, 1);
      for (let i2 = idx, len = this.size(); i2 < len; i2 += 1) {
        this.records[i2].i -= 1;
      }
    }
    getValueForItemAtKeyId(item, keyId) {
      return item[this._keysMap[keyId]];
    }
    size() {
      return this.records.length;
    }
    _addString(doc2, docIndex) {
      if (!isDefined(doc2) || isBlank(doc2)) {
        return;
      }
      let record = {
        v: doc2,
        i: docIndex,
        n: this.norm.get(doc2)
      };
      this.records.push(record);
    }
    _addObject(doc2, docIndex) {
      let record = { i: docIndex, $: {} };
      this.keys.forEach((key, keyIndex) => {
        let value = key.getFn ? key.getFn(doc2) : this.getFn(doc2, key.path);
        if (!isDefined(value)) {
          return;
        }
        if (isArray(value)) {
          let subRecords = [];
          const stack2 = [{ nestedArrIndex: -1, value }];
          while (stack2.length) {
            const { nestedArrIndex, value: value2 } = stack2.pop();
            if (!isDefined(value2)) {
              continue;
            }
            if (isString(value2) && !isBlank(value2)) {
              let subRecord = {
                v: value2,
                i: nestedArrIndex,
                n: this.norm.get(value2)
              };
              subRecords.push(subRecord);
            } else if (isArray(value2)) {
              value2.forEach((item, k2) => {
                stack2.push({
                  nestedArrIndex: k2,
                  value: item
                });
              });
            } else ;
          }
          record.$[keyIndex] = subRecords;
        } else if (isString(value) && !isBlank(value)) {
          let subRecord = {
            v: value,
            n: this.norm.get(value)
          };
          record.$[keyIndex] = subRecord;
        }
      });
      this.records.push(record);
    }
    toJSON() {
      return {
        keys: this.keys,
        records: this.records
      };
    }
  }
  function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex;
  }
  function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
    const { keys, records } = data;
    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex;
  }
  function computeScore$1(pattern, {
    errors = 0,
    currentLocation = 0,
    expectedLocation = 0,
    distance = Config.distance,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    const accuracy = errors / pattern.length;
    if (ignoreLocation) {
      return accuracy;
    }
    const proximity = Math.abs(expectedLocation - currentLocation);
    if (!distance) {
      return proximity ? 1 : accuracy;
    }
    return accuracy + proximity / distance;
  }
  function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
    let indices = [];
    let start = -1;
    let end2 = -1;
    let i2 = 0;
    for (let len = matchmask.length; i2 < len; i2 += 1) {
      let match = matchmask[i2];
      if (match && start === -1) {
        start = i2;
      } else if (!match && start !== -1) {
        end2 = i2 - 1;
        if (end2 - start + 1 >= minMatchCharLength) {
          indices.push([start, end2]);
        }
        start = -1;
      }
    }
    if (matchmask[i2 - 1] && i2 - start >= minMatchCharLength) {
      indices.push([start, i2 - 1]);
    }
    return indices;
  }
  const MAX_BITS = 32;
  function search(text, pattern, patternAlphabet, {
    location = Config.location,
    distance = Config.distance,
    threshold = Config.threshold,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    includeMatches = Config.includeMatches,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    }
    const patternLen = pattern.length;
    const textLen = text.length;
    const expectedLocation = Math.max(0, Math.min(location, textLen));
    let currentThreshold = threshold;
    let bestLocation = expectedLocation;
    const computeMatches = minMatchCharLength > 1 || includeMatches;
    const matchMask = computeMatches ? Array(textLen) : [];
    let index;
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      let score = computeScore$1(pattern, {
        currentLocation: index,
        expectedLocation,
        distance,
        ignoreLocation
      });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;
      if (computeMatches) {
        let i2 = 0;
        while (i2 < patternLen) {
          matchMask[index + i2] = 1;
          i2 += 1;
        }
      }
    }
    bestLocation = -1;
    let lastBitArr = [];
    let finalScore = 1;
    let binMax = patternLen + textLen;
    const mask = 1 << patternLen - 1;
    for (let i2 = 0; i2 < patternLen; i2 += 1) {
      let binMin = 0;
      let binMid = binMax;
      while (binMin < binMid) {
        const score2 = computeScore$1(pattern, {
          errors: i2,
          currentLocation: expectedLocation + binMid,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (score2 <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }
      binMax = binMid;
      let start = Math.max(1, expectedLocation - binMid + 1);
      let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
      let bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << i2) - 1;
      for (let j2 = finish; j2 >= start; j2 -= 1) {
        let currentLocation = j2 - 1;
        let charMatch = patternAlphabet[text.charAt(currentLocation)];
        if (computeMatches) {
          matchMask[currentLocation] = +!!charMatch;
        }
        bitArr[j2] = (bitArr[j2 + 1] << 1 | 1) & charMatch;
        if (i2) {
          bitArr[j2] |= (lastBitArr[j2 + 1] | lastBitArr[j2]) << 1 | 1 | lastBitArr[j2 + 1];
        }
        if (bitArr[j2] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: i2,
            currentLocation,
            expectedLocation,
            distance,
            ignoreLocation
          });
          if (finalScore <= currentThreshold) {
            currentThreshold = finalScore;
            bestLocation = currentLocation;
            if (bestLocation <= expectedLocation) {
              break;
            }
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }
      const score = computeScore$1(pattern, {
        errors: i2 + 1,
        currentLocation: expectedLocation,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score > currentThreshold) {
        break;
      }
      lastBitArr = bitArr;
    }
    const result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(1e-3, finalScore)
    };
    if (computeMatches) {
      const indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }
    return result;
  }
  function createPatternAlphabet(pattern) {
    let mask = {};
    for (let i2 = 0, len = pattern.length; i2 < len; i2 += 1) {
      const char = pattern.charAt(i2);
      mask[char] = (mask[char] || 0) | 1 << len - i2 - 1;
    }
    return mask;
  }
  class BitapSearch {
    constructor(pattern, {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}) {
      this.options = {
        location,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreLocation
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.chunks = [];
      if (!this.pattern.length) {
        return;
      }
      const addChunk = (pattern2, startIndex) => {
        this.chunks.push({
          pattern: pattern2,
          alphabet: createPatternAlphabet(pattern2),
          startIndex
        });
      };
      const len = this.pattern.length;
      if (len > MAX_BITS) {
        let i2 = 0;
        const remainder = len % MAX_BITS;
        const end2 = len - remainder;
        while (i2 < end2) {
          addChunk(this.pattern.substr(i2, MAX_BITS), i2);
          i2 += MAX_BITS;
        }
        if (remainder) {
          const startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }
    searchIn(text) {
      const { isCaseSensitive, includeMatches } = this.options;
      if (!isCaseSensitive) {
        text = text.toLowerCase();
      }
      if (this.pattern === text) {
        let result2 = {
          isMatch: true,
          score: 0
        };
        if (includeMatches) {
          result2.indices = [[0, text.length - 1]];
        }
        return result2;
      }
      const {
        location,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        ignoreLocation
      } = this.options;
      let allIndices = [];
      let totalScore = 0;
      let hasMatches = false;
      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
        const { isMatch, score, indices } = search(text, pattern, alphabet, {
          location: location + startIndex,
          distance,
          threshold,
          findAllMatches,
          minMatchCharLength,
          includeMatches,
          ignoreLocation
        });
        if (isMatch) {
          hasMatches = true;
        }
        totalScore += score;
        if (isMatch && indices) {
          allIndices = [...allIndices, ...indices];
        }
      });
      let result = {
        isMatch: hasMatches,
        score: hasMatches ? totalScore / this.chunks.length : 1
      };
      if (hasMatches && includeMatches) {
        result.indices = allIndices;
      }
      return result;
    }
  }
  class BaseMatch {
    constructor(pattern) {
      this.pattern = pattern;
    }
    static isMultiMatch(pattern) {
      return getMatch(pattern, this.multiRegex);
    }
    static isSingleMatch(pattern) {
      return getMatch(pattern, this.singleRegex);
    }
    search() {
    }
  }
  function getMatch(pattern, exp) {
    const matches2 = pattern.match(exp);
    return matches2 ? matches2[1] : null;
  }
  class ExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "exact";
    }
    static get multiRegex() {
      return /^="(.*)"$/;
    }
    static get singleRegex() {
      return /^=(.*)$/;
    }
    search(text) {
      const isMatch = text === this.pattern;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      };
    }
  }
  class InverseExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "inverse-exact";
    }
    static get multiRegex() {
      return /^!"(.*)"$/;
    }
    static get singleRegex() {
      return /^!(.*)$/;
    }
    search(text) {
      const index = text.indexOf(this.pattern);
      const isMatch = index === -1;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      };
    }
  }
  class PrefixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "prefix-exact";
    }
    static get multiRegex() {
      return /^\^"(.*)"$/;
    }
    static get singleRegex() {
      return /^\^(.*)$/;
    }
    search(text) {
      const isMatch = text.startsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, this.pattern.length - 1]
      };
    }
  }
  class InversePrefixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "inverse-prefix-exact";
    }
    static get multiRegex() {
      return /^!\^"(.*)"$/;
    }
    static get singleRegex() {
      return /^!\^(.*)$/;
    }
    search(text) {
      const isMatch = !text.startsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      };
    }
  }
  class SuffixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "suffix-exact";
    }
    static get multiRegex() {
      return /^"(.*)"\$$/;
    }
    static get singleRegex() {
      return /^(.*)\$$/;
    }
    search(text) {
      const isMatch = text.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [text.length - this.pattern.length, text.length - 1]
      };
    }
  }
  class InverseSuffixExactMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "inverse-suffix-exact";
    }
    static get multiRegex() {
      return /^!"(.*)"\$$/;
    }
    static get singleRegex() {
      return /^!(.*)\$$/;
    }
    search(text) {
      const isMatch = !text.endsWith(this.pattern);
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices: [0, text.length - 1]
      };
    }
  }
  class FuzzyMatch extends BaseMatch {
    constructor(pattern, {
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance,
      includeMatches = Config.includeMatches,
      findAllMatches = Config.findAllMatches,
      minMatchCharLength = Config.minMatchCharLength,
      isCaseSensitive = Config.isCaseSensitive,
      ignoreLocation = Config.ignoreLocation
    } = {}) {
      super(pattern);
      this._bitapSearch = new BitapSearch(pattern, {
        location,
        threshold,
        distance,
        includeMatches,
        findAllMatches,
        minMatchCharLength,
        isCaseSensitive,
        ignoreLocation
      });
    }
    static get type() {
      return "fuzzy";
    }
    static get multiRegex() {
      return /^"(.*)"$/;
    }
    static get singleRegex() {
      return /^(.*)$/;
    }
    search(text) {
      return this._bitapSearch.searchIn(text);
    }
  }
  class IncludeMatch extends BaseMatch {
    constructor(pattern) {
      super(pattern);
    }
    static get type() {
      return "include";
    }
    static get multiRegex() {
      return /^'"(.*)"$/;
    }
    static get singleRegex() {
      return /^'(.*)$/;
    }
    search(text) {
      let location = 0;
      let index;
      const indices = [];
      const patternLen = this.pattern.length;
      while ((index = text.indexOf(this.pattern, location)) > -1) {
        location = index + patternLen;
        indices.push([index, location - 1]);
      }
      const isMatch = !!indices.length;
      return {
        isMatch,
        score: isMatch ? 0 : 1,
        indices
      };
    }
  }
  const searchers = [
    ExactMatch,
    IncludeMatch,
    PrefixExactMatch,
    InversePrefixExactMatch,
    InverseSuffixExactMatch,
    SuffixExactMatch,
    InverseExactMatch,
    FuzzyMatch
  ];
  const searchersLen = searchers.length;
  const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  const OR_TOKEN = "|";
  function parseQuery(pattern, options2 = {}) {
    return pattern.split(OR_TOKEN).map((item) => {
      let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
      let results = [];
      for (let i2 = 0, len = query.length; i2 < len; i2 += 1) {
        const queryItem = query[i2];
        let found = false;
        let idx = -1;
        while (!found && ++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options2));
            found = true;
          }
        }
        if (found) {
          continue;
        }
        idx = -1;
        while (++idx < searchersLen) {
          const searcher = searchers[idx];
          let token = searcher.isSingleMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options2));
            break;
          }
        }
      }
      return results;
    });
  }
  const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
  class ExtendedSearch {
    constructor(pattern, {
      isCaseSensitive = Config.isCaseSensitive,
      includeMatches = Config.includeMatches,
      minMatchCharLength = Config.minMatchCharLength,
      ignoreLocation = Config.ignoreLocation,
      findAllMatches = Config.findAllMatches,
      location = Config.location,
      threshold = Config.threshold,
      distance = Config.distance
    } = {}) {
      this.query = null;
      this.options = {
        isCaseSensitive,
        includeMatches,
        minMatchCharLength,
        findAllMatches,
        ignoreLocation,
        location,
        threshold,
        distance
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.query = parseQuery(this.pattern, this.options);
    }
    static condition(_2, options2) {
      return options2.useExtendedSearch;
    }
    searchIn(text) {
      const query = this.query;
      if (!query) {
        return {
          isMatch: false,
          score: 1
        };
      }
      const { includeMatches, isCaseSensitive } = this.options;
      text = isCaseSensitive ? text : text.toLowerCase();
      let numMatches = 0;
      let allIndices = [];
      let totalScore = 0;
      for (let i2 = 0, qLen = query.length; i2 < qLen; i2 += 1) {
        const searchers2 = query[i2];
        allIndices.length = 0;
        numMatches = 0;
        for (let j2 = 0, pLen = searchers2.length; j2 < pLen; j2 += 1) {
          const searcher = searchers2[j2];
          const { isMatch, indices, score } = searcher.search(text);
          if (isMatch) {
            numMatches += 1;
            totalScore += score;
            if (includeMatches) {
              const type = searcher.constructor.type;
              if (MultiMatchSet.has(type)) {
                allIndices = [...allIndices, ...indices];
              } else {
                allIndices.push(indices);
              }
            }
          } else {
            totalScore = 0;
            numMatches = 0;
            allIndices.length = 0;
            break;
          }
        }
        if (numMatches) {
          let result = {
            isMatch: true,
            score: totalScore / numMatches
          };
          if (includeMatches) {
            result.indices = allIndices;
          }
          return result;
        }
      }
      return {
        isMatch: false,
        score: 1
      };
    }
  }
  const registeredSearchers = [];
  function register(...args) {
    registeredSearchers.push(...args);
  }
  function createSearcher(pattern, options2) {
    for (let i2 = 0, len = registeredSearchers.length; i2 < len; i2 += 1) {
      let searcherClass = registeredSearchers[i2];
      if (searcherClass.condition(pattern, options2)) {
        return new searcherClass(pattern, options2);
      }
    }
    return new BitapSearch(pattern, options2);
  }
  const LogicalOperator = {
    AND: "$and",
    OR: "$or"
  };
  const KeyType = {
    PATH: "$path",
    PATTERN: "$val"
  };
  const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
  const isPath = (query) => !!query[KeyType.PATH];
  const isLeaf = (query) => !isArray(query) && isObject$2(query) && !isExpression(query);
  const convertToExplicit = (query) => ({
    [LogicalOperator.AND]: Object.keys(query).map((key) => ({
      [key]: query[key]
    }))
  });
  function parse$1(query, options2, { auto = true } = {}) {
    const next = (query2) => {
      let keys = Object.keys(query2);
      const isQueryPath = isPath(query2);
      if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
        return next(convertToExplicit(query2));
      }
      if (isLeaf(query2)) {
        const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
        const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
        if (!isString(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
        }
        const obj = {
          keyId: createKeyId(key),
          pattern
        };
        if (auto) {
          obj.searcher = createSearcher(pattern, options2);
        }
        return obj;
      }
      let node = {
        children: [],
        operator: keys[0]
      };
      keys.forEach((key) => {
        const value = query2[key];
        if (isArray(value)) {
          value.forEach((item) => {
            node.children.push(next(item));
          });
        }
      });
      return node;
    };
    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }
    return next(query);
  }
  function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
    results.forEach((result) => {
      let totalScore = 1;
      result.matches.forEach(({ key, norm: norm2, score }) => {
        const weight = key ? key.weight : null;
        totalScore *= Math.pow(
          score === 0 && weight ? Number.EPSILON : score,
          (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
        );
      });
      result.score = totalScore;
    });
  }
  function transformMatches(result, data) {
    const matches2 = result.matches;
    data.matches = [];
    if (!isDefined(matches2)) {
      return;
    }
    matches2.forEach((match) => {
      if (!isDefined(match.indices) || !match.indices.length) {
        return;
      }
      const { indices, value } = match;
      let obj = {
        indices,
        value
      };
      if (match.key) {
        obj.key = match.key.src;
      }
      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }
      data.matches.push(obj);
    });
  }
  function transformScore(result, data) {
    data.score = result.score;
  }
  function format(results, docs, {
    includeMatches = Config.includeMatches,
    includeScore = Config.includeScore
  } = {}) {
    const transformers = [];
    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);
    return results.map((result) => {
      const { idx } = result;
      const data = {
        item: docs[idx],
        refIndex: idx
      };
      if (transformers.length) {
        transformers.forEach((transformer) => {
          transformer(result, data);
        });
      }
      return data;
    });
  }
  class Fuse {
    constructor(docs, options2 = {}, index) {
      this.options = { ...Config, ...options2 };
      if (this.options.useExtendedSearch && false) ;
      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index);
    }
    setCollection(docs, index) {
      this._docs = docs;
      if (index && !(index instanceof FuseIndex)) {
        throw new Error(INCORRECT_INDEX_TYPE);
      }
      this._myIndex = index || createIndex(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight
      });
    }
    add(doc2) {
      if (!isDefined(doc2)) {
        return;
      }
      this._docs.push(doc2);
      this._myIndex.add(doc2);
    }
    remove(predicate = () => false) {
      const results = [];
      for (let i2 = 0, len = this._docs.length; i2 < len; i2 += 1) {
        const doc2 = this._docs[i2];
        if (predicate(doc2, i2)) {
          this.removeAt(i2);
          i2 -= 1;
          len -= 1;
          results.push(doc2);
        }
      }
      return results;
    }
    removeAt(idx) {
      this._docs.splice(idx, 1);
      this._myIndex.removeAt(idx);
    }
    getIndex() {
      return this._myIndex;
    }
    search(query, { limit = -1 } = {}) {
      const {
        includeMatches,
        includeScore,
        shouldSort,
        sortFn,
        ignoreFieldNorm
      } = this.options;
      let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
      computeScore(results, { ignoreFieldNorm });
      if (shouldSort) {
        results.sort(sortFn);
      }
      if (isNumber(limit) && limit > -1) {
        results = results.slice(0, limit);
      }
      return format(results, this._docs, {
        includeMatches,
        includeScore
      });
    }
    _searchStringList(query) {
      const searcher = createSearcher(query, this.options);
      const { records } = this._myIndex;
      const results = [];
      records.forEach(({ v: text, i: idx, n: norm2 }) => {
        if (!isDefined(text)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          results.push({
            item: text,
            idx,
            matches: [{ score, value: text, norm: norm2, indices }]
          });
        }
      });
      return results;
    }
    _searchLogical(query) {
      const expression = parse$1(query, this.options);
      const evaluate2 = (node, item, idx) => {
        if (!node.children) {
          const { keyId, searcher } = node;
          const matches2 = this._findMatches({
            key: this._keyStore.get(keyId),
            value: this._myIndex.getValueForItemAtKeyId(item, keyId),
            searcher
          });
          if (matches2 && matches2.length) {
            return [
              {
                idx,
                item,
                matches: matches2
              }
            ];
          }
          return [];
        }
        const res = [];
        for (let i2 = 0, len = node.children.length; i2 < len; i2 += 1) {
          const child = node.children[i2];
          const result = evaluate2(child, item, idx);
          if (result.length) {
            res.push(...result);
          } else if (node.operator === LogicalOperator.AND) {
            return [];
          }
        }
        return res;
      };
      const records = this._myIndex.records;
      const resultMap = {};
      const results = [];
      records.forEach(({ $: item, i: idx }) => {
        if (isDefined(item)) {
          let expResults = evaluate2(expression, item, idx);
          if (expResults.length) {
            if (!resultMap[idx]) {
              resultMap[idx] = { idx, item, matches: [] };
              results.push(resultMap[idx]);
            }
            expResults.forEach(({ matches: matches2 }) => {
              resultMap[idx].matches.push(...matches2);
            });
          }
        }
      });
      return results;
    }
    _searchObjectList(query) {
      const searcher = createSearcher(query, this.options);
      const { keys, records } = this._myIndex;
      const results = [];
      records.forEach(({ $: item, i: idx }) => {
        if (!isDefined(item)) {
          return;
        }
        let matches2 = [];
        keys.forEach((key, keyIndex) => {
          matches2.push(
            ...this._findMatches({
              key,
              value: item[keyIndex],
              searcher
            })
          );
        });
        if (matches2.length) {
          results.push({
            idx,
            item,
            matches: matches2
          });
        }
      });
      return results;
    }
    _findMatches({ key, value, searcher }) {
      if (!isDefined(value)) {
        return [];
      }
      let matches2 = [];
      if (isArray(value)) {
        value.forEach(({ v: text, i: idx, n: norm2 }) => {
          if (!isDefined(text)) {
            return;
          }
          const { isMatch, score, indices } = searcher.searchIn(text);
          if (isMatch) {
            matches2.push({
              score,
              key,
              value: text,
              idx,
              norm: norm2,
              indices
            });
          }
        });
      } else {
        const { v: text, n: norm2 } = value;
        const { isMatch, score, indices } = searcher.searchIn(text);
        if (isMatch) {
          matches2.push({ score, key, value: text, norm: norm2, indices });
        }
      }
      return matches2;
    }
  }
  Fuse.version = "7.0.0";
  Fuse.createIndex = createIndex;
  Fuse.parseIndex = parseIndex;
  Fuse.config = Config;
  {
    Fuse.parseQuery = parse$1;
  }
  {
    register(ExtendedSearch);
  }
  const getTaxonomySlugs = (taxonomies) => {
    if (taxonomies === void 0) return [];
    return taxonomies.map((taxonomy) => taxonomy.slug);
  };
  const getTaxonomyIds = (taxonomies) => {
    if (taxonomies === void 0) return [];
    return taxonomies.map((taxonomy) => taxonomy.term_id).filter((id) => id !== void 0);
  };
  function sanitizePropertyName(propName) {
    if (typeof propName !== "string") {
      return `$${String(propName)}`;
    }
    return `$${propName}`;
  }
  function unsanitizePropertyName(sanitizedPropName) {
    if (typeof sanitizedPropName !== "string") {
      return String(sanitizedPropName);
    }
    return sanitizedPropName.startsWith("$") ? sanitizedPropName.slice(1) : sanitizedPropName;
  }
  function escapeAmpersand(value) {
    return value.replace(/&(?!([a-z0-9]+|#[0-9]+|#x[a-f0-9]+);)/gi, "&amp;");
  }
  function escapeLessThan(value) {
    return value.replace(/</g, "&lt;");
  }
  function escapeHTML(value) {
    return escapeLessThan(escapeAmpersand(value));
  }
  const useCountryStore = /* @__PURE__ */ defineStore("country", () => {
    const uiStore = useUiStore();
    const shouldFetch = ref(false);
    const { data: countries, isLoading } = useQuery({
      queryKey: ["countries"],
      enabled: shouldFetch,
      queryFn: getCountries
    });
    const fetchCountries = () => {
      shouldFetch.value = true;
    };
    const searchIndex = computed(() => {
      const keys = ["name"];
      return Fuse.createIndex(keys, countries.value);
    });
    const filteredCountries = computed(() => {
      let filteredCountries2 = countries.value ?? [];
      if (uiStore.hasSearch) {
        const fuse = new Fuse(
          filteredCountries2,
          {
            threshold: 0.3
          },
          searchIndex.value
        );
        const searchResults = fuse.search(uiStore.searchText);
        filteredCountries2 = searchResults.map((c2) => c2.item);
      }
      return filteredCountries2.filter((country) => {
        if (uiStore.selectedRegions.length > 0) {
          const regions = country.taxonomies["region"] ?? [];
          if (!regions.some((r2) => uiStore.selectedRegions.includes(r2.term_id))) {
            return false;
          }
        }
        for (const selectedTaxonomies of Object.values(selectedFilters.value)) {
          const selectedIds = [];
          const itemIds = [];
          for (const sanitizedKey of Object.keys(selectedTaxonomies)) {
            const key = unsanitizePropertyName(sanitizedKey);
            if (!selectedTaxonomies[sanitizedKey] || selectedTaxonomies[sanitizedKey].length === 0)
              continue;
            itemIds.push(...getTaxonomyIds(country.taxonomies[key] ?? []));
            selectedIds.push(...selectedTaxonomies[sanitizedKey]);
          }
          if (selectedIds.length !== 0) {
            if (!itemIds.some((id) => selectedIds.includes(id))) {
              return false;
            }
          }
        }
        return true;
      }).toSorted((a2, b2) => {
        if (uiStore.countryOrderBy === "recently_updated") {
          const aChanged = new Date(a2.changedOn);
          const bChanged = new Date(b2.changedOn);
          return bChanged.getTime() - aChanged.getTime();
        }
        return a2.name.localeCompare(b2.name);
      });
    });
    const compareCountries = ref([]);
    const selectedCountry = ref(void 0);
    const selectCountry = (country) => {
      if (selectedCountry.value === country) {
        selectedCountry.value = void 0;
        compareCountries.value = [];
        uiStore.searchText = "";
        return;
      }
      selectedCountry.value = country;
    };
    const isSelected = (country) => {
      return compareCountries.value.findIndex((c2) => c2.id === country.id) > -1 || country === selectedCountry.value;
    };
    const formatChangeForTaxonomy = (taxonomyName, country) => {
      let output = "";
      let currentString = "";
      let upcomingString = "";
      const current = country.taxonomies[taxonomyName + "-current"];
      const upcoming = country.taxonomies[taxonomyName + "-upcoming"];
      if (current) {
        current.forEach((item, index) => {
          currentString += escapeHTML(item.name);
          if (index < current.length - 1) {
            currentString += ", ";
          }
        });
        output += currentString;
        if (upcoming) {
          output += " (Current)";
        }
      } else {
        if (!upcoming) {
          output += "Not specified";
        }
      }
      if (upcoming) {
        upcoming.forEach((item, index) => {
          upcomingString += escapeHTML(item.name);
          if (index < upcoming.length - 1) {
            upcomingString += ", ";
          }
        });
        if (current) {
          output += "  <br/>";
        }
        output += `${upcomingString} (Upcoming)`;
      }
      return output;
    };
    const selectedFilters = ref({});
    const selectedFilterCount = ref(0);
    const toggleFilter = (filter, key, option) => {
      const sanitizedFilter = sanitizePropertyName(filter);
      const sanitizedKey = sanitizePropertyName(key);
      if (!selectedFilters.value[sanitizedFilter]) {
        selectedFilters.value[sanitizedFilter] = {};
      }
      if (!selectedFilters.value[sanitizedFilter][sanitizedKey]) {
        selectedFilters.value[sanitizedFilter][sanitizedKey] = [];
      }
      const foundIdx = selectedFilters.value[sanitizedFilter][sanitizedKey].findIndex(
        (o2) => o2 === option
      );
      if (foundIdx === -1) {
        selectedFilters.value[sanitizedFilter][sanitizedKey].push(option);
        return true;
      }
      selectedFilters.value[sanitizedFilter][sanitizedKey].splice(foundIdx, 1);
      return false;
    };
    const toggleFilters = (filter, entries) => {
      const sanitizedFilter = sanitizePropertyName(filter);
      if (!selectedFilters.value[sanitizedFilter]) {
        selectedFilters.value[sanitizedFilter] = {};
      }
      let change = void 0;
      entries.forEach((entry) => {
        if (entry.length === 0 || !entry[0]) return;
        const key = entry[0];
        const options2 = entry.slice(1);
        options2.forEach((option) => {
          if (change === void 0) {
            change = toggleFilter(filter, key, option);
          } else {
            toggleFilter(filter, key, option);
          }
        });
      });
      if (change === true) {
        selectedFilterCount.value++;
      }
      if (change === false) {
        selectedFilterCount.value--;
      }
    };
    const hasFilters = computed(() => {
      if (uiStore.selectedRegions.length > 0) {
        return true;
      }
      for (const filterKey of Object.keys(selectedFilters.value)) {
        for (const taxKey of Object.keys(selectedFilters.value[filterKey])) {
          if (selectedFilters.value[filterKey][taxKey].length > 0) {
            return true;
          }
        }
      }
      return false;
    });
    const resetFilters = () => {
      selectedFilters.value = {};
      uiStore.selectedRegions = [];
      selectedFilterCount.value = 0;
    };
    const getFilter = (key) => {
      const sanitizedKey = sanitizePropertyName(key);
      if (!selectedFilters.value[sanitizedKey]) {
        return [];
      }
      return Object.keys(selectedFilters.value[sanitizedKey]).reduce((acc, curr) => {
        if (selectedFilters.value[sanitizedKey][curr].length === 0) {
          return acc;
        }
        acc.push(...selectedFilters.value[sanitizedKey][curr]);
        return acc;
      }, []);
    };
    const getCountriesByFirstLetter = (letter) => {
      var _a2;
      return (_a2 = countries.value) == null ? void 0 : _a2.filter(
        (country) => country.name.charAt(0).toUpperCase() === letter.toUpperCase()
      );
    };
    return {
      isLoading,
      filteredCountries,
      countries,
      compareCountries,
      selectedCountry,
      selectedFilters,
      hasFilters,
      selectedFilterCount,
      getFilter,
      toggleFilter,
      resetFilters,
      toggleFilters,
      isSelected,
      selectCountry,
      formatChangeForTaxonomy,
      fetchCountries,
      getCountriesByFirstLetter
    };
  });
  const useUiStore = /* @__PURE__ */ defineStore("ui", () => {
    const countryStore = useCountryStore();
    const searchText = ref("");
    const hasSearch = computed(() => {
      return searchText.value && searchText.value.trim() !== "";
    });
    const selectedRegions = ref([]);
    const toggleRegion = (region) => {
      const foundIdx = selectedRegions.value.findIndex((r2) => r2 === region);
      if (foundIdx === -1) {
        countryStore.selectedFilterCount++;
        selectedRegions.value.push(region);
        return;
      }
      countryStore.selectedFilterCount--;
      selectedRegions.value.splice(foundIdx, 1);
    };
    const isRegionSelected = (region) => {
      return selectedRegions.value.includes(region);
    };
    const countryOrderBy = ref("name");
    const setCountryOrderBy = (orderBy) => {
      countryOrderBy.value = orderBy;
    };
    return {
      searchText,
      hasSearch,
      selectedRegions,
      countryOrderBy,
      toggleRegion,
      isRegionSelected,
      setCountryOrderBy
    };
  });
  const _hoisted_1$f = { class: "relative flex w-max max-w-[100vw] items-center py-2 font-sans" };
  const _sfc_main$f = /* @__PURE__ */ defineComponent({
    __name: "SearchBar",
    setup(__props) {
      const uiStore = useUiStore();
      const handleSearch = () => {
        const countryProfiles = document.getElementById("country-profiles");
        if (!countryProfiles) return;
        let elementTop = countryProfiles.getBoundingClientRect().top;
        if (elementTop > 200) {
          elementTop = elementTop - 200;
        }
        window.scrollTo({
          top: elementTop,
          behavior: "smooth"
        });
      };
      return (_ctx, _cache2) => {
        return openBlock(), createElementBlock("div", _hoisted_1$f, [
          _cache2[1] || (_cache2[1] = createBaseVNode("i", { class: "fa-regular fa-search pointer-events-none absolute left-1 top-[50%] -translate-y-[50%] !text-secondary sm:left-[20px] sm:text-xl" }, null, -1)),
          _cache2[2] || (_cache2[2] = createBaseVNode("label", {
            class: "sr-only",
            for: "compliance-app-search"
          }, " Search countries by name ", -1)),
          withDirectives(createBaseVNode("input", {
            id: "compliance-app-search",
            class: "!w-full cursor-text rounded-lg !border !border-solid !border-gray-light !p-4 !px-6 sm:min-w-[295px] sm:!pl-16",
            type: "text",
            "onUpdate:modelValue": _cache2[0] || (_cache2[0] = ($event) => unref(uiStore).searchText = $event),
            onKeyup: withKeys(handleSearch, ["enter"]),
            placeholder: "Search for country/region"
          }, null, 544), [
            [vModelText, unref(uiStore).searchText]
          ])
        ]);
      };
    }
  });
  const _hoisted_1$e = { class: "country-profile col-span-12 !border-0 p-2 !text-primary lg:col-span-8" };
  const _hoisted_2$9 = { class: "w-100 flex justify-between" };
  const _hoisted_3$8 = { class: "flex" };
  const _hoisted_4$7 = { class: "!text-primary" };
  const _hoisted_5$5 = { class: "country-profile image-frame col-span-4 row-span-3 !m-3 !hidden !border-0 lg:!block" };
  const _hoisted_6$4 = ["src"];
  const _hoisted_7$3 = { class: "country-profile col-span-12 !border-0 !py-3 !text-primary *:px-3 max-md:*:pr-5 lg:col-span-4" };
  const _hoisted_8$3 = ["innerHTML"];
  const _hoisted_9$1 = { class: "country-profile col-span-12 !border-0 !py-3 !text-primary *:px-3 max-md:*:pr-5 lg:col-span-4" };
  const _hoisted_10$1 = ["innerHTML"];
  const _hoisted_11$1 = { class: "country-profile col-span-12 !border-0 !py-3 !text-primary *:px-3 max-md:*:pr-5 lg:col-span-4" };
  const _hoisted_12 = ["innerHTML"];
  const _hoisted_13 = { class: "country-profile col-span-12 !border-0 !py-3 !text-primary *:px-3 max-md:*:pr-5 lg:col-span-4" };
  const _hoisted_14 = {
    key: 1,
    class: "z-[1] -mb-4 rounded-lg !border-0 bg-white"
  };
  const _hoisted_15 = { class: "w-100 flex justify-between" };
  const _hoisted_16 = { class: "flex" };
  const _hoisted_17 = ["innerHTML"];
  const _hoisted_18 = ["innerHTML"];
  const _hoisted_19 = ["innerHTML"];
  const _hoisted_20 = { class: "my-auto box-border flex min-h-10 min-w-[140px] max-w-32 justify-center rounded-sm bg-[#CFE8FF] px-3 py-2" };
  const _hoisted_21 = { class: "text-sm font-bold uppercase" };
  const _hoisted_22 = { class: "my-auto pl-3" };
  const _hoisted_23 = {
    class: "fa-ul no-padding",
    style: { "--fa-li-margin": "1.5em" }
  };
  const _hoisted_24 = {
    class: "fa-ul no-padding",
    style: { "--fa-li-margin": "1.5em" }
  };
  const _sfc_main$e = /* @__PURE__ */ defineComponent({
    __name: "CountrySingle",
    props: {
      size: {},
      country: {},
      columnclass: {},
      isCompare: { default: 0 }
    },
    setup(__props) {
      const props = __props;
      const placeholderImage = new URL("/prod/s3fs-public/navigator/Placeholder.jpg", _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.js", document.baseURI).href).href;
      const imageError = ref(false);
      const countryStore = useCountryStore();
      const getCountryImage = computed(() => () => {
        if (imageError.value) return placeholderImage;
        return `https://opuscapita.com/wp-content/themes/opuscapita/assets/images/countries/${props.country.code}.webp`;
      });
      const regulatoryStatus = computed(() => {
        const status = getTaxonomySlugs(props.country.taxonomies["regulatory-landscape"]);
        if (!status || status.length === 0) return "";
        switch (status[0]) {
          case "recentlyenforced":
            return "Recently enforced";
          case "stable":
            return "Stable";
          case "changing":
            return "Changing";
          default:
            return "-";
        }
      });
      return (_ctx, _cache2) => {
        return openBlock(), createElementBlock(Fragment, null, [
          _ctx.columnclass == "single" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", _hoisted_1$e, [
              createBaseVNode("div", _hoisted_2$9, [
                createBaseVNode("div", _hoisted_3$8, [
                  createBaseVNode("h2", _hoisted_4$7, toDisplayString(_ctx.country.name), 1)
                ])
              ])
            ]),
            createBaseVNode("div", _hoisted_5$5, [
              createBaseVNode("img", {
                src: getCountryImage.value(),
                onErrorOnce: _cache2[0] || (_cache2[0] = ($event) => imageError.value = true)
              }, null, 40, _hoisted_6$4)
            ]),
            createBaseVNode("div", _hoisted_7$3, [
              _cache2[1] || (_cache2[1] = createBaseVNode("h3", { class: "!text-secondary" }, "TAX COMPLIANCE MODEL", -1)),
              createBaseVNode("p", {
                innerHTML: unref(countryStore).formatChangeForTaxonomy("b2b-einvoicing-model", _ctx.country)
              }, null, 8, _hoisted_8$3)
            ]),
            createBaseVNode("div", _hoisted_9$1, [
              _cache2[2] || (_cache2[2] = createBaseVNode("h3", { class: "!text-secondary" }, "INVOICE EXCHANGE MODEL", -1)),
              createBaseVNode("p", {
                innerHTML: unref(countryStore).formatChangeForTaxonomy("b2b-document-exchange", _ctx.country)
              }, null, 8, _hoisted_10$1)
            ]),
            createBaseVNode("div", _hoisted_11$1, [
              _cache2[3] || (_cache2[3] = createBaseVNode("h3", { class: "!text-secondary" }, "FORMATS", -1)),
              createBaseVNode("p", {
                innerHTML: unref(countryStore).formatChangeForTaxonomy("mandatory-format", _ctx.country)
              }, null, 8, _hoisted_12)
            ]),
            createBaseVNode("div", _hoisted_13, [
              _cache2[4] || (_cache2[4] = createBaseVNode("h3", { class: "!text-secondary" }, "STATUS", -1)),
              createBaseVNode("p", null, toDisplayString(regulatoryStatus.value), 1)
            ])
          ], 64)) : (openBlock(), createElementBlock("div", _hoisted_14, [
            createBaseVNode("div", {
              class: normalizeClass([_ctx.columnclass, "country-profile p-2 !text-primary"])
            }, [
              createBaseVNode("div", _hoisted_15, [
                createBaseVNode("div", _hoisted_16, [
                  createBaseVNode("h2", null, toDisplayString(_ctx.country.name), 1)
                ])
              ])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.columnclass, "country-profile !py-3 !text-primary *:px-3 max-md:*:pr-5"])
            }, [
              _cache2[5] || (_cache2[5] = createBaseVNode("h3", { class: "!text-secondary" }, "TAX COMPLIANCE MODEL", -1)),
              createBaseVNode("p", {
                innerHTML: unref(countryStore).formatChangeForTaxonomy("b2b-einvoicing-model", _ctx.country)
              }, null, 8, _hoisted_17)
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.columnclass, "country-profile !py-3 !text-primary *:px-3 max-md:*:pr-5"])
            }, [
              _cache2[6] || (_cache2[6] = createBaseVNode("h3", { class: "!text-secondary" }, "INVOICE EXCHANGE MODEL", -1)),
              createBaseVNode("p", {
                innerHTML: unref(countryStore).formatChangeForTaxonomy("b2b-document-exchange", _ctx.country)
              }, null, 8, _hoisted_18)
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.columnclass, "country-profile !py-3 !text-primary *:px-3 max-md:*:pr-5"])
            }, [
              _cache2[7] || (_cache2[7] = createBaseVNode("h3", { class: "!text-secondary" }, "FORMATS", -1)),
              createBaseVNode("p", {
                innerHTML: unref(countryStore).formatChangeForTaxonomy("mandatory-format", _ctx.country)
              }, null, 8, _hoisted_19)
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.columnclass, "country-profile !py-3 !text-primary *:px-3 max-md:*:pr-5"])
            }, [
              _cache2[8] || (_cache2[8] = createBaseVNode("h3", { class: "!text-secondary" }, "STATUS", -1)),
              createBaseVNode("p", null, toDisplayString(regulatoryStatus.value), 1)
            ], 2)
          ])),
          createBaseVNode("div", {
            class: normalizeClass([_ctx.columnclass == "single" ? "col-span-12 rounded-lg" : _ctx.columnclass + " -mb-2", "country-profile bg-white !p-0 !text-primary"])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["relative z-[2] my-0 box-border flex min-h-[50px] w-full items-center bg-gradient-tertiary px-3 !text-white sm:absolute md:md:rounded-t-lg", _ctx.isCompare !== 0 ? "sm:hidden" : ""])
            }, _cache2[9] || (_cache2[9] = [
              createBaseVNode("h3", { class: "!my-0 text-sm" }, "TIMELINE", -1)
            ]), 2),
            _cache2[10] || (_cache2[10] = createBaseVNode("div", { class: "hidden sm:!block sm:h-[50px]" }, null, -1)),
            createBaseVNode("div", {
              class: normalizeClass(["w-100 mb-8 flex flex-col gap-2 gap-6", _ctx.size == "full" ? "p-4 lg:!p-10" : "pt-5 *:px-3 max-md:*:pr-5"])
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.country.meta.timelines, (timeline, index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: normalizeClass(["flex flex-col md:flex-row", _ctx.size == "full" ? "items-start" : "flex-col"])
                }, [
                  createBaseVNode("div", _hoisted_20, [
                    createBaseVNode("div", _hoisted_21, toDisplayString(new Date(timeline.date).toLocaleDateString("en-GB", {
                      year: "numeric",
                      month: "short",
                      day: "numeric"
                    })), 1)
                  ]),
                  createBaseVNode("p", _hoisted_22, toDisplayString(timeline.description), 1)
                ], 2);
              }), 128)),
              _ctx.country.meta.timelines.length == 0 ? (openBlock(), createElementBlock("p", {
                key: 0,
                class: normalizeClass(_ctx.size == "full" ? "m-0 ms-4 pt-2" : "mt-3")
              }, " No upcoming changes announced ", 2)) : createCommentVNode("", true)
            ], 2)
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass([_ctx.columnclass == "single" ? "col-span-12 rounded-lg" : _ctx.columnclass + " -mb-2", "country-profile rounded-lg bg-white !p-0 !text-primary"])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["my-0 box-border flex min-h-[50px] w-full items-center bg-gradient-tertiary px-3 !text-white sm:absolute md:rounded-t-lg", _ctx.isCompare !== 0 ? "sm:hidden" : ""])
            }, _cache2[11] || (_cache2[11] = [
              createBaseVNode("h3", { class: "!my-0 text-sm" }, "ISSUING RULES", -1)
            ]), 2),
            _cache2[13] || (_cache2[13] = createBaseVNode("div", { class: "hidden sm:!block sm:h-[50px]" }, null, -1)),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.size == "full" ? "!p-2 lg:!p-10" : "pt-5 *:px-3 max-md:*:pr-5")
            }, [
              createBaseVNode("ul", _hoisted_23, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.country.meta.issuingRules, (rule, index) => {
                  return openBlock(), createElementBlock("li", {
                    key: index,
                    class: "mb-4"
                  }, [
                    _cache2[12] || (_cache2[12] = createBaseVNode("span", { class: "fa-li" }, [
                      createBaseVNode("i", { class: "fa-regular fa-2xs fa-circle font-normal !text-primary !text-secondary" })
                    ], -1)),
                    createTextVNode(" " + toDisplayString(rule.description), 1)
                  ]);
                }), 128))
              ])
            ], 2)
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass([_ctx.columnclass == "single" ? "col-span-12 rounded-lg" : _ctx.columnclass + " -mb-2", "country-profile rounded-lg bg-white !p-0 !text-primary"])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["my-0 box-border flex min-h-[50px] w-full items-center bg-gradient-tertiary px-3 !text-white sm:absolute md:rounded-t-lg", _ctx.isCompare !== 0 ? "sm:hidden" : ""])
            }, _cache2[14] || (_cache2[14] = [
              createBaseVNode("h3", { class: "!my-0 text-sm" }, "RECEIVING RULES", -1)
            ]), 2),
            _cache2[16] || (_cache2[16] = createBaseVNode("div", { class: "hidden sm:!block sm:h-[50px]" }, null, -1)),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.size == "full" ? "!p-2 lg:!p-10" : "pt-5 *:!px-3 max-md:*:!pr-5")
            }, [
              createBaseVNode("ul", _hoisted_24, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.country.meta.receivingRules, (rule, index) => {
                  return openBlock(), createElementBlock("li", {
                    key: index,
                    class: "mb-4"
                  }, [
                    _cache2[15] || (_cache2[15] = createBaseVNode("span", { class: "fa-li" }, [
                      createBaseVNode("i", { class: "fa-regular fa-2xs fa-circle font-normal !text-primary !text-secondary" })
                    ], -1)),
                    createTextVNode(" " + toDisplayString(rule.description), 1)
                  ]);
                }), 128))
              ])
            ], 2)
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass([_ctx.columnclass == "single" ? "col-span-12 rounded-lg" : _ctx.columnclass, "country-profile rounded-lg bg-white !p-0 !text-primary"])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["my-0 box-border flex min-h-[50px] w-full items-center bg-gradient-tertiary px-3 !text-white sm:absolute md:rounded-t-lg", _ctx.isCompare !== 0 ? "sm:hidden" : ""])
            }, _cache2[17] || (_cache2[17] = [
              createBaseVNode("h3", { class: "!my-0 text-sm" }, "KEY FACTS", -1)
            ]), 2),
            _cache2[19] || (_cache2[19] = createBaseVNode("div", { class: "hidden sm:!block sm:h-[50px]" }, null, -1)),
            createBaseVNode("div", {
              class: normalizeClass(["w-100", _ctx.size === "full" ? "!p-5 lg:!p-[3.25rem]" : "*: pt-5 *:!px-3 max-md:*:!pr-5"])
            }, [
              createBaseVNode("ul", {
                class: normalizeClass(["fa-ul no-padding font-normal", {
                  "grid grid-rows-[auto_1fr] gap-x-40 lg:grid-cols-2": _ctx.size === "full"
                }]),
                style: { "--fa-li-margin": "1.5em" }
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.country.meta.keyFacts, (fact, index) => {
                  return openBlock(), createElementBlock("li", {
                    key: index,
                    class: "mb-4"
                  }, [
                    _cache2[18] || (_cache2[18] = createBaseVNode("span", { class: "fa-li" }, [
                      createBaseVNode("i", { class: "fa-regular fa-2xs fa-circle font-normal !text-secondary" })
                    ], -1)),
                    createTextVNode(" " + toDisplayString(fact.description), 1)
                  ]);
                }), 128))
              ], 2)
            ], 2)
          ], 2)
        ], 64);
      };
    }
  });
  const _export_sfc = (sfc, props) => {
    const target2 = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target2[key] = val;
    }
    return target2;
  };
  const __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-cb07adac"]]);
  const _hoisted_1$d = {
    key: 0,
    class: "z-5 sticky top-0 block bg-gray-light p-3 sm:hidden"
  };
  const _hoisted_2$8 = { class: "flex justify-between text-sm" };
  const _hoisted_3$7 = ["onClick"];
  const _hoisted_4$6 = { class: "overflow-hidden" };
  const _sfc_main$d = /* @__PURE__ */ defineComponent({
    __name: "CountryCompare",
    setup(__props) {
      const countryStore = useCountryStore();
      const columnSize = computed(() => () => {
        if (countryStore.compareCountries.length == 1) {
          return "half";
        }
        if (countryStore.compareCountries.length == 2) {
          return "third";
        }
        return "full";
      });
      const comparePage = ref(0);
      function setPage(next) {
        comparePage.value = next;
        if (comparePage.value < 0) {
          comparePage.value = 0;
        }
        if (comparePage.value >= countryStore.compareCountries.length) {
          comparePage.value = countryStore.compareCountries.length;
        }
      }
      return (_ctx, _cache2) => {
        var _a2;
        const _component_CountrySingle = __unplugin_components_0$1;
        return openBlock(), createElementBlock(Fragment, null, [
          unref(countryStore).compareCountries.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
            createBaseVNode("div", _hoisted_2$8, [
              createBaseVNode("button", {
                onClick: _cache2[0] || (_cache2[0] = ($event) => setPage(0)),
                class: normalizeClass(["max-h-6 max-w-24 overflow-hidden border-0 bg-transparent text-center text-md", comparePage.value == 0 ? "font-bold underline" : ""])
              }, toDisplayString((_a2 = unref(countryStore).selectedCountry) == null ? void 0 : _a2.name), 3),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(countryStore).compareCountries, (btn, index) => {
                return openBlock(), createElementBlock("button", {
                  class: normalizeClass(["max-h-6 max-w-32 overflow-hidden border-0 bg-transparent text-center text-md", comparePage.value == index + 1 ? "font-bold underline" : ""]),
                  onClick: ($event) => setPage(index + 1),
                  key: index
                }, toDisplayString(btn == null ? void 0 : btn.name), 11, _hoisted_3$7);
              }), 128))
            ])
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_4$6, [
            createBaseVNode("div", {
              class: normalizeClass([
                "relative",
                unref(countryStore).compareCountries.length > 0 ? `compare-columns page-${comparePage.value} sm:gap-x-4` : "single-column gap-y-4"
              ])
            }, [
              unref(countryStore).selectedCountry ? (openBlock(), createBlock(_component_CountrySingle, {
                key: 0,
                country: unref(countryStore).selectedCountry,
                size: columnSize.value(),
                columnclass: unref(countryStore).compareCountries.length == 0 ? "single" : ""
              }, null, 8, ["country", "size", "columnclass"])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(countryStore).compareCountries, (country, index) => {
                return openBlock(), createBlock(_component_CountrySingle, {
                  key: country.code,
                  size: columnSize.value(),
                  columnclass: "",
                  country,
                  "is-compare": index + 1
                }, null, 8, ["size", "country", "is-compare"]);
              }), 128))
            ], 2)
          ])
        ], 64);
      };
    }
  });
  const _sfc_main$c = {};
  const _hoisted_1$c = { class: "flex items-center justify-center" };
  function _sfc_render(_ctx, _cache2) {
    return openBlock(), createElementBlock("div", _hoisted_1$c, _cache2[0] || (_cache2[0] = [
      createBaseVNode("i", { class: "fa-regular fa-spinner-third fa-spin" }, null, -1)
    ]));
  }
  const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render]]);
  function serialize(o2) {
    return typeof o2 == "string" ? `'${o2}'` : new c$2().serialize(o2);
  }
  const c$2 = /* @__PURE__ */ function() {
    var _t2;
    class o2 {
      constructor() {
        __privateAdd(this, _t2, /* @__PURE__ */ new Map());
      }
      compare(t2, r2) {
        const e2 = typeof t2, n2 = typeof r2;
        return e2 === "string" && n2 === "string" ? t2.localeCompare(r2) : e2 === "number" && n2 === "number" ? t2 - r2 : String.prototype.localeCompare.call(this.serialize(t2, true), this.serialize(r2, true));
      }
      serialize(t2, r2) {
        if (t2 === null) return "null";
        switch (typeof t2) {
          case "string":
            return r2 ? t2 : `'${t2}'`;
          case "bigint":
            return `${t2}n`;
          case "object":
            return this.$object(t2);
          case "function":
            return this.$function(t2);
        }
        return String(t2);
      }
      serializeObject(t2) {
        const r2 = Object.prototype.toString.call(t2);
        if (r2 !== "[object Object]") return this.serializeBuiltInType(r2.length < 10 ? `unknown:${r2}` : r2.slice(8, -1), t2);
        const e2 = t2.constructor, n2 = e2 === Object || e2 === void 0 ? "" : e2.name;
        if (n2 !== "" && globalThis[n2] === e2) return this.serializeBuiltInType(n2, t2);
        if (typeof t2.toJSON == "function") {
          const i2 = t2.toJSON();
          return n2 + (i2 !== null && typeof i2 == "object" ? this.$object(i2) : `(${this.serialize(i2)})`);
        }
        return this.serializeObjectEntries(n2, Object.entries(t2));
      }
      serializeBuiltInType(t2, r2) {
        const e2 = this["$" + t2];
        if (e2) return e2.call(this, r2);
        if (typeof (r2 == null ? void 0 : r2.entries) == "function") return this.serializeObjectEntries(t2, r2.entries());
        throw new Error(`Cannot serialize ${t2}`);
      }
      serializeObjectEntries(t2, r2) {
        const e2 = Array.from(r2).sort((i2, a2) => this.compare(i2[0], a2[0]));
        let n2 = `${t2}{`;
        for (let i2 = 0; i2 < e2.length; i2++) {
          const [a2, l2] = e2[i2];
          n2 += `${this.serialize(a2, true)}:${this.serialize(l2)}`, i2 < e2.length - 1 && (n2 += ",");
        }
        return n2 + "}";
      }
      $object(t2) {
        let r2 = __privateGet(this, _t2).get(t2);
        return r2 === void 0 && (__privateGet(this, _t2).set(t2, `#${__privateGet(this, _t2).size}`), r2 = this.serializeObject(t2), __privateGet(this, _t2).set(t2, r2)), r2;
      }
      $function(t2) {
        const r2 = Function.prototype.toString.call(t2);
        return r2.slice(-15) === "[native code] }" ? `${t2.name || ""}()[native]` : `${t2.name}(${t2.length})${r2.replace(/\s*\n\s*/g, "")}`;
      }
      $Array(t2) {
        let r2 = "[";
        for (let e2 = 0; e2 < t2.length; e2++) r2 += this.serialize(t2[e2]), e2 < t2.length - 1 && (r2 += ",");
        return r2 + "]";
      }
      $Date(t2) {
        try {
          return `Date(${t2.toISOString()})`;
        } catch {
          return "Date(null)";
        }
      }
      $ArrayBuffer(t2) {
        return `ArrayBuffer[${new Uint8Array(t2).join(",")}]`;
      }
      $Set(t2) {
        return `Set${this.$Array(Array.from(t2).sort((r2, e2) => this.compare(r2, e2)))}`;
      }
      $Map(t2) {
        return this.serializeObjectEntries("Map", t2.entries());
      }
    }
    _t2 = new WeakMap();
    for (const s2 of ["Error", "RegExp", "URL"]) o2.prototype["$" + s2] = function(t2) {
      return `${s2}(${t2})`;
    };
    for (const s2 of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) o2.prototype["$" + s2] = function(t2) {
      return `${s2}[${t2.join(",")}]`;
    };
    for (const s2 of ["BigInt64Array", "BigUint64Array"]) o2.prototype["$" + s2] = function(t2) {
      return `${s2}[${t2.join("n,")}${t2.length > 0 ? "n" : ""}]`;
    };
    return o2;
  }();
  function isEqual(object1, object2) {
    if (object1 === object2) {
      return true;
    }
    if (serialize(object1) === serialize(object2)) {
      return true;
    }
    return false;
  }
  function findValuesBetween(array, start, end2) {
    const startIndex = array.findIndex((i2) => isEqual(i2, start));
    const endIndex = array.findIndex((i2) => isEqual(i2, end2));
    if (startIndex === -1 || endIndex === -1) return [];
    const [minIndex, maxIndex] = [startIndex, endIndex].sort((a2, b2) => a2 - b2);
    return array.slice(minIndex, maxIndex + 1);
  }
  function createContext(providerComponentName, contextName) {
    const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
    const injectionKey = Symbol(symbolDescription);
    const injectContext = (fallback) => {
      const context2 = inject(injectionKey, fallback);
      if (context2) return context2;
      if (context2 === null) return context2;
      throw new Error(`Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(", ")}` : `\`${providerComponentName}\``}`);
    };
    const provideContext = (contextValue) => {
      provide(injectionKey, contextValue);
      return contextValue;
    };
    return [injectContext, provideContext];
  }
  function getActiveElement() {
    let activeElement = document.activeElement;
    if (activeElement == null) return null;
    while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) activeElement = activeElement.shadowRoot.activeElement;
    return activeElement;
  }
  function handleAndDispatchCustomEvent(name, handler, detail) {
    const target2 = detail.originalEvent.target;
    const event = new CustomEvent(name, {
      bubbles: false,
      cancelable: true,
      detail
    });
    if (handler) target2.addEventListener(name, handler, { once: true });
    target2.dispatchEvent(event);
  }
  function renderSlotFragments(children) {
    if (!children) return [];
    return children.flatMap((child) => {
      if (child.type === Fragment) return renderSlotFragments(child.children);
      return [child];
    });
  }
  const ignoredElement = ["INPUT", "TEXTAREA"];
  function useArrowNavigation(e2, currentElement, parentElement, options2 = {}) {
    if (!currentElement || options2.enableIgnoredElement && ignoredElement.includes(currentElement.nodeName)) return null;
    const { arrowKeyOptions = "both", attributeName = "[data-reka-collection-item]", itemsArray = [], loop = true, dir = "ltr", preventScroll = true, focus: focus2 = false } = options2;
    const [right, left, up, down, home, end2] = [
      e2.key === "ArrowRight",
      e2.key === "ArrowLeft",
      e2.key === "ArrowUp",
      e2.key === "ArrowDown",
      e2.key === "Home",
      e2.key === "End"
    ];
    const goingVertical = up || down;
    const goingHorizontal = right || left;
    if (!home && !end2 && (!goingVertical && !goingHorizontal || arrowKeyOptions === "vertical" && goingHorizontal || arrowKeyOptions === "horizontal" && goingVertical)) return null;
    const allCollectionItems = parentElement ? Array.from(parentElement.querySelectorAll(attributeName)) : itemsArray;
    if (!allCollectionItems.length) return null;
    if (preventScroll) e2.preventDefault();
    let item = null;
    if (goingHorizontal || goingVertical) {
      const goForward = goingVertical ? down : dir === "ltr" ? right : left;
      item = findNextFocusableElement(allCollectionItems, currentElement, {
        goForward,
        loop
      });
    } else if (home) item = allCollectionItems.at(0) || null;
    else if (end2) item = allCollectionItems.at(-1) || null;
    if (focus2) item == null ? void 0 : item.focus();
    return item;
  }
  function findNextFocusableElement(elements, currentElement, options2, iterations = elements.length) {
    if (--iterations === 0) return null;
    const index = elements.indexOf(currentElement);
    const newIndex = options2.goForward ? index + 1 : index - 1;
    if (!options2.loop && (newIndex < 0 || newIndex >= elements.length)) return null;
    const adjustedNewIndex = (newIndex + elements.length) % elements.length;
    const candidate = elements[adjustedNewIndex];
    if (!candidate) return null;
    const isDisabled = candidate.hasAttribute("disabled") && candidate.getAttribute("disabled") !== "false";
    if (isDisabled) return findNextFocusableElement(elements, candidate, options2, iterations);
    return candidate;
  }
  const [injectConfigProviderContext, provideConfigProviderContext] = createContext("ConfigProvider");
  function computedEager(fn, options2) {
    var _a2;
    const result = shallowRef();
    watchEffect(() => {
      result.value = fn();
    }, {
      ...options2,
      flush: (_a2 = void 0) != null ? _a2 : "sync"
    });
    return readonly(result);
  }
  function tryOnScopeDispose$1(fn) {
    if (getCurrentScope()) {
      onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function createEventHook() {
    const fns = /* @__PURE__ */ new Set();
    const off = (fn) => {
      fns.delete(fn);
    };
    const clear = () => {
      fns.clear();
    };
    const on = (fn) => {
      fns.add(fn);
      const offFn = () => off(fn);
      tryOnScopeDispose$1(offFn);
      return {
        off: offFn
      };
    };
    const trigger2 = (...args) => {
      return Promise.all(Array.from(fns).map((fn) => fn(...args)));
    };
    return {
      on,
      off,
      trigger: trigger2,
      clear
    };
  }
  function createGlobalState(stateFactory) {
    let initialized = false;
    let state;
    const scope = effectScope(true);
    return (...args) => {
      if (!initialized) {
        state = scope.run(() => stateFactory(...args));
        initialized = true;
      }
      return state;
    };
  }
  function createSharedComposable(composable) {
    let subscribers = 0;
    let state;
    let scope;
    const dispose = () => {
      subscribers -= 1;
      if (scope && subscribers <= 0) {
        scope.stop();
        state = void 0;
        scope = void 0;
      }
    };
    return (...args) => {
      subscribers += 1;
      if (!scope) {
        scope = effectScope(true);
        state = scope.run(() => composable(...args));
      }
      tryOnScopeDispose$1(dispose);
      return state;
    };
  }
  const isClient$1 = typeof window !== "undefined" && typeof document !== "undefined";
  typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
  const isDef = (val) => typeof val !== "undefined";
  const toString$1 = Object.prototype.toString;
  const isObject$1 = (val) => toString$1.call(val) === "[object Object]";
  const isIOS = /* @__PURE__ */ getIsIOS();
  function getIsIOS() {
    var _a2, _b2;
    return isClient$1 && ((_a2 = window == null ? void 0 : window.navigator) == null ? void 0 : _a2.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b2 = window == null ? void 0 : window.navigator) == null ? void 0 : _b2.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
  }
  function getLifeCycleTarget$1(target2) {
    return getCurrentInstance();
  }
  function toArray$1(value) {
    return Array.isArray(value) ? value : [value];
  }
  function refAutoReset(defaultValue, afterMs = 1e4) {
    return customRef((track2, trigger2) => {
      let value = toValue$3(defaultValue);
      let timer;
      const resetAfter = () => setTimeout(() => {
        value = toValue$3(defaultValue);
        trigger2();
      }, toValue$3(afterMs));
      tryOnScopeDispose$1(() => {
        clearTimeout(timer);
      });
      return {
        get() {
          track2();
          return value;
        },
        set(newValue) {
          value = newValue;
          trigger2();
          clearTimeout(timer);
          timer = resetAfter();
        }
      };
    });
  }
  const toValue$2 = toValue$3;
  function tryOnBeforeUnmount(fn, target2) {
    const instance = getLifeCycleTarget$1();
    if (instance)
      onBeforeUnmount(fn, target2);
  }
  function watchImmediate(source, cb, options2) {
    return watch(
      source,
      cb,
      {
        ...options2,
        immediate: true
      }
    );
  }
  const defaultWindow$1 = isClient$1 ? window : void 0;
  function unrefElement$1(elRef) {
    var _a2;
    const plain = toValue$3(elRef);
    return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
  }
  function useEventListener$1(...args) {
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
    };
    const register2 = (el, event, listener, options2) => {
      el.addEventListener(event, listener, options2);
      return () => el.removeEventListener(event, listener, options2);
    };
    const firstParamTargets = computed(() => {
      const test = toArray$1(toValue$3(args[0])).filter((e2) => e2 != null);
      return test.every((e2) => typeof e2 !== "string") ? test : void 0;
    });
    const stopWatch = watchImmediate(
      () => {
        var _a2, _b2;
        return [
          (_b2 = (_a2 = firstParamTargets.value) == null ? void 0 : _a2.map((e2) => unrefElement$1(e2))) != null ? _b2 : [defaultWindow$1].filter((e2) => e2 != null),
          toArray$1(toValue$3(firstParamTargets.value ? args[1] : args[0])),
          toArray$1(unref(firstParamTargets.value ? args[2] : args[1])),
          // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
          toValue$3(firstParamTargets.value ? args[3] : args[2])
        ];
      },
      ([raw_targets, raw_events, raw_listeners, raw_options]) => {
        cleanup();
        if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
          return;
        const optionsClone = isObject$1(raw_options) ? { ...raw_options } : raw_options;
        cleanups.push(
          ...raw_targets.flatMap(
            (el) => raw_events.flatMap(
              (event) => raw_listeners.map((listener) => register2(el, event, listener, optionsClone))
            )
          )
        );
      },
      { flush: "post" }
    );
    const stop2 = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose$1(cleanup);
    return stop2;
  }
  function useMounted$1() {
    const isMounted = shallowRef(false);
    const instance = getCurrentInstance();
    if (instance) {
      onMounted(() => {
        isMounted.value = true;
      }, instance);
    }
    return isMounted;
  }
  function createKeyPredicate(keyFilter) {
    if (typeof keyFilter === "function")
      return keyFilter;
    else if (typeof keyFilter === "string")
      return (event) => event.key === keyFilter;
    else if (Array.isArray(keyFilter))
      return (event) => keyFilter.includes(event.key);
    return () => true;
  }
  function onKeyStroke(...args) {
    let key;
    let handler;
    let options2 = {};
    if (args.length === 3) {
      key = args[0];
      handler = args[1];
      options2 = args[2];
    } else if (args.length === 2) {
      if (typeof args[1] === "object") {
        key = true;
        handler = args[0];
        options2 = args[1];
      } else {
        key = args[0];
        handler = args[1];
      }
    } else {
      key = true;
      handler = args[0];
    }
    const {
      target: target2 = defaultWindow$1,
      eventName = "keydown",
      passive = false,
      dedupe = false
    } = options2;
    const predicate = createKeyPredicate(key);
    const listener = (e2) => {
      if (e2.repeat && toValue$3(dedupe))
        return;
      if (predicate(e2))
        handler(e2);
    };
    return useEventListener$1(target2, eventName, listener, passive);
  }
  function cloneFnJSON(source) {
    return JSON.parse(JSON.stringify(source));
  }
  function useVModel(props, key, emit2, options2 = {}) {
    var _a2, _b2, _c2;
    const {
      clone = false,
      passive = false,
      eventName,
      deep = false,
      defaultValue,
      shouldEmit
    } = options2;
    const vm = getCurrentInstance();
    const _emit = emit2 || (vm == null ? void 0 : vm.emit) || ((_a2 = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a2.bind(vm)) || ((_c2 = (_b2 = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b2.$emit) == null ? void 0 : _c2.bind(vm == null ? void 0 : vm.proxy));
    let event = eventName;
    if (!key) {
      key = "modelValue";
    }
    event = event || `update:${key.toString()}`;
    const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
    const getValue2 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
    const triggerEmit = (value) => {
      if (shouldEmit) {
        if (shouldEmit(value))
          _emit(event, value);
      } else {
        _emit(event, value);
      }
    };
    if (passive) {
      const initialValue = getValue2();
      const proxy = ref(initialValue);
      let isUpdating = false;
      watch(
        () => props[key],
        (v2) => {
          if (!isUpdating) {
            isUpdating = true;
            proxy.value = cloneFn(v2);
            nextTick(() => isUpdating = false);
          }
        }
      );
      watch(
        proxy,
        (v2) => {
          if (!isUpdating && (v2 !== props[key] || deep))
            triggerEmit(v2);
        },
        { deep }
      );
      return proxy;
    } else {
      return computed({
        get() {
          return getValue2();
        },
        set(value) {
          triggerEmit(value);
        }
      });
    }
  }
  function isPlainObject(value) {
    if (value === null || typeof value !== "object") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
      return false;
    }
    if (Symbol.iterator in value) {
      return false;
    }
    if (Symbol.toStringTag in value) {
      return Object.prototype.toString.call(value) === "[object Module]";
    }
    return true;
  }
  function _defu(baseObject, defaults, namespace2 = ".", merger) {
    if (!isPlainObject(defaults)) {
      return _defu(baseObject, {}, namespace2, merger);
    }
    const object = Object.assign({}, defaults);
    for (const key in baseObject) {
      if (key === "__proto__" || key === "constructor") {
        continue;
      }
      const value = baseObject[key];
      if (value === null || value === void 0) {
        continue;
      }
      if (merger && merger(object, key, value, namespace2)) {
        continue;
      }
      if (Array.isArray(value) && Array.isArray(object[key])) {
        object[key] = [...value, ...object[key]];
      } else if (isPlainObject(value) && isPlainObject(object[key])) {
        object[key] = _defu(
          value,
          object[key],
          (namespace2 ? `${namespace2}.` : "") + key.toString(),
          merger
        );
      } else {
        object[key] = value;
      }
    }
    return object;
  }
  function createDefu(merger) {
    return (...arguments_) => (
      // eslint-disable-next-line unicorn/no-array-reduce
      arguments_.reduce((p2, c2) => _defu(p2, c2, "", merger), {})
    );
  }
  const defu = createDefu();
  const useBodyLockStackCount = createSharedComposable(() => {
    const map = ref(/* @__PURE__ */ new Map());
    const initialOverflow = ref();
    const locked = computed(() => {
      for (const value of map.value.values()) if (value) return true;
      return false;
    });
    const context2 = injectConfigProviderContext({ scrollBody: ref(true) });
    let stopTouchMoveListener = null;
    const resetBodyStyle = () => {
      document.body.style.paddingRight = "";
      document.body.style.marginRight = "";
      document.body.style.pointerEvents = "";
      document.documentElement.style.removeProperty("--scrollbar-width");
      document.body.style.overflow = initialOverflow.value ?? "";
      isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
      initialOverflow.value = void 0;
    };
    watch(locked, (val, oldVal) => {
      var _a2;
      if (!isClient$1) return;
      if (!val) {
        if (oldVal) resetBodyStyle();
        return;
      }
      if (initialOverflow.value === void 0) initialOverflow.value = document.body.style.overflow;
      const verticalScrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      const defaultConfig = {
        padding: verticalScrollbarWidth,
        margin: 0
      };
      const config2 = ((_a2 = context2.scrollBody) == null ? void 0 : _a2.value) ? typeof context2.scrollBody.value === "object" ? defu({
        padding: context2.scrollBody.value.padding === true ? verticalScrollbarWidth : context2.scrollBody.value.padding,
        margin: context2.scrollBody.value.margin === true ? verticalScrollbarWidth : context2.scrollBody.value.margin
      }, defaultConfig) : defaultConfig : {
        padding: 0,
        margin: 0
      };
      if (verticalScrollbarWidth > 0) {
        document.body.style.paddingRight = typeof config2.padding === "number" ? `${config2.padding}px` : String(config2.padding);
        document.body.style.marginRight = typeof config2.margin === "number" ? `${config2.margin}px` : String(config2.margin);
        document.documentElement.style.setProperty("--scrollbar-width", `${verticalScrollbarWidth}px`);
        document.body.style.overflow = "hidden";
      }
      if (isIOS) stopTouchMoveListener = useEventListener$1(document, "touchmove", (e2) => preventDefault(e2), { passive: false });
      nextTick(() => {
        document.body.style.pointerEvents = "none";
        document.body.style.overflow = "hidden";
      });
    }, {
      immediate: true,
      flush: "sync"
    });
    return map;
  });
  function useBodyScrollLock(initialState) {
    const id = Math.random().toString(36).substring(2, 7);
    const map = useBodyLockStackCount();
    map.value.set(id, initialState ?? false);
    const locked = computed({
      get: () => map.value.get(id) ?? false,
      set: (value) => map.value.set(id, value)
    });
    tryOnBeforeUnmount(() => {
      map.value.delete(id);
    });
    return locked;
  }
  function checkOverflowScroll(ele) {
    const style = window.getComputedStyle(ele);
    if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) return true;
    else {
      const parent = ele.parentNode;
      if (!(parent instanceof Element) || parent.tagName === "BODY") return false;
      return checkOverflowScroll(parent);
    }
  }
  function preventDefault(rawEvent) {
    const e2 = rawEvent || window.event;
    const _target = e2.target;
    if (_target instanceof Element && checkOverflowScroll(_target)) return false;
    if (e2.touches.length > 1) return true;
    if (e2.preventDefault && e2.cancelable) e2.preventDefault();
    return false;
  }
  function useDirection(dir) {
    const context2 = injectConfigProviderContext({ dir: ref("ltr") });
    return computed(() => {
      var _a2;
      return (dir == null ? void 0 : dir.value) || ((_a2 = context2.dir) == null ? void 0 : _a2.value) || "ltr";
    });
  }
  function useEmitAsProps(emit2) {
    const vm = getCurrentInstance();
    const events = vm == null ? void 0 : vm.type.emits;
    const result = {};
    if (!(events == null ? void 0 : events.length)) console.warn(`No emitted event found. Please check component: ${vm == null ? void 0 : vm.type.__name}`);
    events == null ? void 0 : events.forEach((ev) => {
      result[toHandlerKey(camelize(ev))] = (...arg) => emit2(ev, ...arg);
    });
    return result;
  }
  function useFilter(options2) {
    const computedOptions = computed(() => unref(options2));
    const collator = computed(() => new Intl.Collator("en", {
      usage: "search",
      ...computedOptions.value
    }));
    const startsWith = (string, substring) => {
      if (substring.length === 0) return true;
      string = string.normalize("NFC");
      substring = substring.normalize("NFC");
      return collator.value.compare(string.slice(0, substring.length), substring) === 0;
    };
    const endsWith = (string, substring) => {
      if (substring.length === 0) return true;
      string = string.normalize("NFC");
      substring = substring.normalize("NFC");
      return collator.value.compare(string.slice(-substring.length), substring) === 0;
    };
    const contains = (string, substring) => {
      if (substring.length === 0) return true;
      string = string.normalize("NFC");
      substring = substring.normalize("NFC");
      let scan = 0;
      const sliceLen = substring.length;
      for (; scan + sliceLen <= string.length; scan++) {
        const slice = string.slice(scan, scan + sliceLen);
        if (collator.value.compare(substring, slice) === 0) return true;
      }
      return false;
    };
    return {
      startsWith,
      endsWith,
      contains
    };
  }
  let count$1 = 0;
  function useFocusGuards() {
    watchEffect((cleanupFn) => {
      if (!isClient$1) return;
      const edgeGuards = document.querySelectorAll("[data-reka-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
      document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
      count$1++;
      cleanupFn(() => {
        if (count$1 === 1) document.querySelectorAll("[data-reka-focus-guard]").forEach((node) => node.remove());
        count$1--;
      });
    });
  }
  function createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-reka-focus-guard", "");
    element.tabIndex = 0;
    element.style.outline = "none";
    element.style.opacity = "0";
    element.style.position = "fixed";
    element.style.pointerEvents = "none";
    return element;
  }
  function useFormControl(el) {
    return computed(() => {
      var _a2;
      return toValue$2(el) ? Boolean((_a2 = unrefElement$1(el)) == null ? void 0 : _a2.closest("form")) : true;
    });
  }
  function useForwardExpose() {
    const instance = getCurrentInstance();
    const currentRef = ref();
    const currentElement = computed(() => {
      var _a2, _b2;
      return ["#text", "#comment"].includes((_a2 = currentRef.value) == null ? void 0 : _a2.$el.nodeName) ? (_b2 = currentRef.value) == null ? void 0 : _b2.$el.nextElementSibling : unrefElement$1(currentRef);
    });
    const localExpose = Object.assign({}, instance.exposed);
    const ret = {};
    for (const key in instance.props) Object.defineProperty(ret, key, {
      enumerable: true,
      configurable: true,
      get: () => instance.props[key]
    });
    if (Object.keys(localExpose).length > 0) for (const key in localExpose) Object.defineProperty(ret, key, {
      enumerable: true,
      configurable: true,
      get: () => localExpose[key]
    });
    Object.defineProperty(ret, "$el", {
      enumerable: true,
      configurable: true,
      get: () => instance.vnode.el
    });
    instance.exposed = ret;
    function forwardRef(ref$1) {
      currentRef.value = ref$1;
      if (!ref$1) return;
      Object.defineProperty(ret, "$el", {
        enumerable: true,
        configurable: true,
        get: () => ref$1 instanceof Element ? ref$1 : ref$1.$el
      });
      instance.exposed = ret;
    }
    return {
      forwardRef,
      currentRef,
      currentElement
    };
  }
  function useForwardProps(props) {
    const vm = getCurrentInstance();
    const defaultProps = Object.keys((vm == null ? void 0 : vm.type.props) ?? {}).reduce((prev, curr) => {
      const defaultValue = (vm == null ? void 0 : vm.type.props[curr]).default;
      if (defaultValue !== void 0) prev[curr] = defaultValue;
      return prev;
    }, {});
    const refProps = toRef(props);
    return computed(() => {
      const preservedProps = {};
      const assignedProps = (vm == null ? void 0 : vm.vnode.props) ?? {};
      Object.keys(assignedProps).forEach((key) => {
        preservedProps[camelize(key)] = assignedProps[key];
      });
      return Object.keys({
        ...defaultProps,
        ...preservedProps
      }).reduce((prev, curr) => {
        if (refProps.value[curr] !== void 0) prev[curr] = refProps.value[curr];
        return prev;
      }, {});
    });
  }
  function useForwardPropsEmits(props, emit2) {
    const parsedProps = useForwardProps(props);
    const emitsAsProps = emit2 ? useEmitAsProps(emit2) : {};
    return computed(() => ({
      ...parsedProps.value,
      ...emitsAsProps
    }));
  }
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target2) {
      if (parent.contains(target2)) {
        return target2;
      }
      var correctedTarget = unwrapHost(target2);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target2, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x2) {
      return Boolean(x2);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          try {
            var attr = node.getAttribute(controlAttribute);
            var alreadyHidden = attr !== null && attr !== "false";
            var counterValue = (counterMap.get(node) || 0) + 1;
            var markerValue = (markerCounter.get(node) || 0) + 1;
            counterMap.set(node, counterValue);
            markerCounter.set(node, markerValue);
            hiddenNodes.push(node);
            if (counterValue === 1 && alreadyHidden) {
              uncontrolledNodes.set(node, true);
            }
            if (markerValue === 1) {
              node.setAttribute(markerName, "true");
            }
            if (!alreadyHidden) {
              node.setAttribute(controlAttribute, "true");
            }
          } catch (e2) {
            console.error("aria-hidden: cannot operate on ", node, e2);
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };
  function useHideOthers(target2) {
    let undo;
    watch(() => unrefElement$1(target2), (el) => {
      if (el) undo = hideOthers(el);
      else if (undo) undo();
    });
    onUnmounted(() => {
      if (undo) undo();
    });
  }
  let count = 0;
  function useId(deterministicId, prefix = "reka") {
    if ("useId" in vue) return `${prefix}-${useId$1 == null ? void 0 : useId$1()}`;
    const configProviderContext = injectConfigProviderContext({ useId: void 0 });
    if (configProviderContext.useId) return `${prefix}-${configProviderContext.useId()}`;
    return `${prefix}-${++count}`;
  }
  function useKbd() {
    return {
      ALT: "Alt",
      ARROW_DOWN: "ArrowDown",
      ARROW_LEFT: "ArrowLeft",
      ARROW_RIGHT: "ArrowRight",
      ARROW_UP: "ArrowUp",
      BACKSPACE: "Backspace",
      CAPS_LOCK: "CapsLock",
      CONTROL: "Control",
      DELETE: "Delete",
      END: "End",
      ENTER: "Enter",
      ESCAPE: "Escape",
      F1: "F1",
      F10: "F10",
      F11: "F11",
      F12: "F12",
      F2: "F2",
      F3: "F3",
      F4: "F4",
      F5: "F5",
      F6: "F6",
      F7: "F7",
      F8: "F8",
      F9: "F9",
      HOME: "Home",
      META: "Meta",
      PAGE_DOWN: "PageDown",
      PAGE_UP: "PageUp",
      SHIFT: "Shift",
      SPACE: " ",
      TAB: "Tab",
      CTRL: "Control",
      ASTERISK: "*",
      SPACE_CODE: "Space"
    };
  }
  function useSize(element) {
    const size2 = ref();
    const width = computed(() => {
      var _a2;
      return ((_a2 = size2.value) == null ? void 0 : _a2.width) ?? 0;
    });
    const height = computed(() => {
      var _a2;
      return ((_a2 = size2.value) == null ? void 0 : _a2.height) ?? 0;
    });
    onMounted(() => {
      const el = unrefElement$1(element);
      if (el) {
        size2.value = {
          width: el.offsetWidth,
          height: el.offsetHeight
        };
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries)) return;
          if (!entries.length) return;
          const entry = entries[0];
          let width$1;
          let height$1;
          if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry.borderBoxSize;
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width$1 = borderSize.inlineSize;
            height$1 = borderSize.blockSize;
          } else {
            width$1 = el.offsetWidth;
            height$1 = el.offsetHeight;
          }
          size2.value = {
            width: width$1,
            height: height$1
          };
        });
        resizeObserver.observe(el, { box: "border-box" });
        return () => resizeObserver.unobserve(el);
      } else size2.value = void 0;
    });
    return {
      width,
      height
    };
  }
  function useStateMachine(initialState, machine) {
    const state = ref(initialState);
    function reducer(event) {
      const nextState = machine[state.value][event];
      return nextState ?? state.value;
    }
    const dispatch = (event) => {
      state.value = reducer(event);
    };
    return {
      state,
      dispatch
    };
  }
  function useTypeahead(callback) {
    const search2 = refAutoReset("", 1e3);
    const handleTypeaheadSearch = (key, items) => {
      search2.value = search2.value + key;
      {
        const currentItem = getActiveElement();
        const itemsWithTextValue = items.map((item) => {
          var _a2, _b2;
          return {
            ...item,
            textValue: ((_a2 = item.value) == null ? void 0 : _a2.textValue) ?? ((_b2 = item.ref.textContent) == null ? void 0 : _b2.trim()) ?? ""
          };
        });
        const currentMatch = itemsWithTextValue.find((item) => item.ref === currentItem);
        const values = itemsWithTextValue.map((item) => item.textValue);
        const nextMatch = getNextMatch(values, search2.value, currentMatch == null ? void 0 : currentMatch.textValue);
        const newItem = itemsWithTextValue.find((item) => item.textValue === nextMatch);
        if (newItem) newItem.ref.focus();
        return newItem == null ? void 0 : newItem.ref;
      }
    };
    const resetTypeahead = () => {
      search2.value = "";
    };
    return {
      search: search2,
      handleTypeaheadSearch,
      resetTypeahead
    };
  }
  function wrapArray(array, startIndex) {
    return array.map((_2, index) => array[(startIndex + index) % array.length]);
  }
  function getNextMatch(values, search2, currentMatch) {
    const isRepeated = search2.length > 1 && Array.from(search2).every((char) => char === search2[0]);
    const normalizedSearch = isRepeated ? search2[0] : search2;
    const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
    let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));
    const excludeCurrentMatch = normalizedSearch.length === 1;
    if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v2) => v2 !== currentMatch);
    const nextMatch = wrappedValues.find((value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));
    return nextMatch !== currentMatch ? nextMatch : void 0;
  }
  function usePresence(present, node) {
    var _a2;
    const stylesRef = ref({});
    const prevAnimationNameRef = ref("none");
    const prevPresentRef = ref(present);
    const initialState = present.value ? "mounted" : "unmounted";
    let timeoutId;
    const ownerWindow = ((_a2 = node.value) == null ? void 0 : _a2.ownerDocument.defaultView) ?? defaultWindow$1;
    const { state, dispatch } = useStateMachine(initialState, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: { MOUNT: "mounted" }
    });
    const dispatchCustomEvent = (name) => {
      var _a3;
      if (isClient$1) {
        const customEvent = new CustomEvent(name, {
          bubbles: false,
          cancelable: false
        });
        (_a3 = node.value) == null ? void 0 : _a3.dispatchEvent(customEvent);
      }
    };
    watch(present, async (currentPresent, prevPresent) => {
      var _a3;
      const hasPresentChanged = prevPresent !== currentPresent;
      await nextTick();
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.value;
        const currentAnimationName = getAnimationName(node.value);
        if (currentPresent) {
          dispatch("MOUNT");
          dispatchCustomEvent("enter");
          if (currentAnimationName === "none") dispatchCustomEvent("after-enter");
        } else if (currentAnimationName === "none" || currentAnimationName === "undefined" || ((_a3 = stylesRef.value) == null ? void 0 : _a3.display) === "none") {
          dispatch("UNMOUNT");
          dispatchCustomEvent("leave");
          dispatchCustomEvent("after-leave");
        } else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (prevPresent && isAnimating) {
            dispatch("ANIMATION_OUT");
            dispatchCustomEvent("leave");
          } else {
            dispatch("UNMOUNT");
            dispatchCustomEvent("after-leave");
          }
        }
      }
    }, { immediate: true });
    const handleAnimationEnd = (event) => {
      const currentAnimationName = getAnimationName(node.value);
      const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
      const directionName = state.value === "mounted" ? "enter" : "leave";
      if (event.target === node.value && isCurrentAnimation) {
        dispatchCustomEvent(`after-${directionName}`);
        dispatch("ANIMATION_END");
        if (!prevPresentRef.value) {
          const currentFillMode = node.value.style.animationFillMode;
          node.value.style.animationFillMode = "forwards";
          timeoutId = ownerWindow == null ? void 0 : ownerWindow.setTimeout(() => {
            var _a3;
            if (((_a3 = node.value) == null ? void 0 : _a3.style.animationFillMode) === "forwards") node.value.style.animationFillMode = currentFillMode;
          });
        }
      }
      if (event.target === node.value && currentAnimationName === "none") dispatch("ANIMATION_END");
    };
    const handleAnimationStart = (event) => {
      if (event.target === node.value) prevAnimationNameRef.value = getAnimationName(node.value);
    };
    const watcher = watch(node, (newNode, oldNode) => {
      if (newNode) {
        stylesRef.value = getComputedStyle(newNode);
        newNode.addEventListener("animationstart", handleAnimationStart);
        newNode.addEventListener("animationcancel", handleAnimationEnd);
        newNode.addEventListener("animationend", handleAnimationEnd);
      } else {
        dispatch("ANIMATION_END");
        if (timeoutId !== void 0) ownerWindow == null ? void 0 : ownerWindow.clearTimeout(timeoutId);
        oldNode == null ? void 0 : oldNode.removeEventListener("animationstart", handleAnimationStart);
        oldNode == null ? void 0 : oldNode.removeEventListener("animationcancel", handleAnimationEnd);
        oldNode == null ? void 0 : oldNode.removeEventListener("animationend", handleAnimationEnd);
      }
    }, { immediate: true });
    const stateWatcher = watch(state, () => {
      const currentAnimationName = getAnimationName(node.value);
      prevAnimationNameRef.value = state.value === "mounted" ? currentAnimationName : "none";
    });
    onUnmounted(() => {
      watcher();
      stateWatcher();
    });
    const isPresent = computed(() => ["mounted", "unmountSuspended"].includes(state.value));
    return { isPresent };
  }
  function getAnimationName(node) {
    return node ? getComputedStyle(node).animationName || "none" : "none";
  }
  var Presence_default = /* @__PURE__ */ defineComponent({
    name: "Presence",
    props: {
      present: {
        type: Boolean,
        required: true
      },
      forceMount: { type: Boolean }
    },
    slots: {},
    setup(props, { slots, expose }) {
      var _a2;
      const { present, forceMount } = toRefs(props);
      const node = ref();
      const { isPresent } = usePresence(present, node);
      expose({ present: isPresent });
      let children = slots.default({ present: isPresent.value });
      children = renderSlotFragments(children || []);
      const instance = getCurrentInstance();
      if (children && (children == null ? void 0 : children.length) > 1) {
        const componentName = ((_a2 = instance == null ? void 0 : instance.parent) == null ? void 0 : _a2.type.name) ? `<${instance.parent.type.name} />` : "component";
        throw new Error([
          `Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((line) => `  - ${line}`).join("\n")
        ].join("\n"));
      }
      return () => {
        if (forceMount.value || present.value || isPresent.value) return h$2(slots.default({ present: isPresent.value })[0], { ref: (v2) => {
          const el = unrefElement$1(v2);
          if (typeof (el == null ? void 0 : el.hasAttribute) === "undefined") return el;
          if (el == null ? void 0 : el.hasAttribute("data-reka-popper-content-wrapper")) node.value = el.firstElementChild;
          else node.value = el;
          return el;
        } });
        else return null;
      };
    }
  });
  const Slot = /* @__PURE__ */ defineComponent({
    name: "PrimitiveSlot",
    inheritAttrs: false,
    setup(_2, { attrs: attrs2, slots }) {
      return () => {
        var _a2;
        if (!slots.default) return null;
        const children = renderSlotFragments(slots.default());
        const firstNonCommentChildrenIndex = children.findIndex((child) => child.type !== Comment);
        if (firstNonCommentChildrenIndex === -1) return children;
        const firstNonCommentChildren = children[firstNonCommentChildrenIndex];
        (_a2 = firstNonCommentChildren.props) == null ? true : delete _a2.ref;
        const mergedProps = firstNonCommentChildren.props ? mergeProps(attrs2, firstNonCommentChildren.props) : attrs2;
        const cloned = cloneVNode({
          ...firstNonCommentChildren,
          props: {}
        }, mergedProps);
        if (children.length === 1) return cloned;
        children[firstNonCommentChildrenIndex] = cloned;
        return children;
      };
    }
  });
  const SELF_CLOSING_TAGS = [
    "area",
    "img",
    "input"
  ];
  const Primitive = /* @__PURE__ */ defineComponent({
    name: "Primitive",
    inheritAttrs: false,
    props: {
      asChild: {
        type: Boolean,
        default: false
      },
      as: {
        type: [String, Object],
        default: "div"
      }
    },
    setup(props, { attrs: attrs2, slots }) {
      const asTag = props.asChild ? "template" : props.as;
      if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag)) return () => h$2(asTag, attrs2);
      if (asTag !== "template") return () => h$2(props.as, attrs2, { default: slots.default });
      return () => h$2(Slot, attrs2, { default: slots.default });
    }
  });
  function usePrimitiveElement() {
    const primitiveElement = ref();
    const currentElement = computed(() => {
      var _a2, _b2;
      return ["#text", "#comment"].includes((_a2 = primitiveElement.value) == null ? void 0 : _a2.$el.nodeName) ? (_b2 = primitiveElement.value) == null ? void 0 : _b2.$el.nextElementSibling : unrefElement$1(primitiveElement);
    });
    return {
      primitiveElement,
      currentElement
    };
  }
  const [injectDialogRootContext, provideDialogRootContext] = createContext("DialogRoot");
  var DialogRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    inheritAttrs: false,
    __name: "DialogRoot",
    props: {
      open: {
        type: Boolean,
        required: false,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        required: false,
        default: false
      },
      modal: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    emits: ["update:open"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      const open = useVModel(props, "open", emit2, {
        defaultValue: props.defaultOpen,
        passive: props.open === void 0
      });
      const triggerElement = ref();
      const contentElement = ref();
      const { modal } = toRefs(props);
      provideDialogRootContext({
        open,
        modal,
        openModal: () => {
          open.value = true;
        },
        onOpenChange: (value) => {
          open.value = value;
        },
        onOpenToggle: () => {
          open.value = !open.value;
        },
        contentId: "",
        titleId: "",
        descriptionId: "",
        triggerElement,
        contentElement
      });
      return (_ctx, _cache2) => {
        return renderSlot(_ctx.$slots, "default", {
          open: unref(open),
          close: () => open.value = false
        });
      };
    }
  });
  var DialogRoot_default = DialogRoot_vue_vue_type_script_setup_true_lang_default;
  const POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  const FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  function isLayerExist(layerElement, targetElement) {
    const targetLayer = targetElement.closest("[data-dismissable-layer]");
    const mainLayer = layerElement.dataset.dismissableLayer === "" ? layerElement : layerElement.querySelector("[data-dismissable-layer]");
    const nodeList = Array.from(layerElement.ownerDocument.querySelectorAll("[data-dismissable-layer]"));
    if (targetLayer && (mainLayer === targetLayer || nodeList.indexOf(mainLayer) < nodeList.indexOf(targetLayer))) return true;
    else return false;
  }
  function usePointerDownOutside(onPointerDownOutside, element, enabled2 = true) {
    var _a2;
    const ownerDocument = ((_a2 = element == null ? void 0 : element.value) == null ? void 0 : _a2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const isPointerInsideDOMTree = ref(false);
    const handleClickRef = ref(() => {
    });
    watchEffect((cleanupFn) => {
      if (!isClient$1 || !toValue$3(enabled2)) return;
      const handlePointerDown = async (event) => {
        const target2 = event.target;
        if (!(element == null ? void 0 : element.value) || !target2) return;
        if (isLayerExist(element.value, target2)) {
          isPointerInsideDOMTree.value = false;
          return;
        }
        if (event.target && !isPointerInsideDOMTree.value) {
          let handleAndDispatchPointerDownOutsideEvent = function() {
            handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, onPointerDownOutside, eventDetail);
          };
          const eventDetail = { originalEvent: event };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.value);
            handleClickRef.value = handleAndDispatchPointerDownOutsideEvent;
            ownerDocument.addEventListener("click", handleClickRef.value, { once: true });
          } else handleAndDispatchPointerDownOutsideEvent();
        } else ownerDocument.removeEventListener("click", handleClickRef.value);
        isPointerInsideDOMTree.value = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      cleanupFn(() => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.value);
      });
    });
    return { onPointerDownCapture: () => {
      if (!toValue$3(enabled2)) return;
      isPointerInsideDOMTree.value = true;
    } };
  }
  function useFocusOutside(onFocusOutside, element, enabled2 = true) {
    var _a2;
    const ownerDocument = ((_a2 = element == null ? void 0 : element.value) == null ? void 0 : _a2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document);
    const isFocusInsideDOMTree = ref(false);
    watchEffect((cleanupFn) => {
      if (!isClient$1 || !toValue$3(enabled2)) return;
      const handleFocus = async (event) => {
        if (!(element == null ? void 0 : element.value)) return;
        await nextTick();
        await nextTick();
        const target2 = event.target;
        if (!element.value || !target2 || isLayerExist(element.value, target2)) return;
        if (event.target && !isFocusInsideDOMTree.value) {
          const eventDetail = { originalEvent: event };
          handleAndDispatchCustomEvent(FOCUS_OUTSIDE, onFocusOutside, eventDetail);
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      cleanupFn(() => ownerDocument.removeEventListener("focusin", handleFocus));
    });
    return {
      onFocusCapture: () => {
        if (!toValue$3(enabled2)) return;
        isFocusInsideDOMTree.value = true;
      },
      onBlurCapture: () => {
        if (!toValue$3(enabled2)) return;
        isFocusInsideDOMTree.value = false;
      }
    };
  }
  const context = reactive({
    layersRoot: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var DismissableLayer_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DismissableLayer",
    props: {
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false,
        default: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "dismiss"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { forwardRef, currentElement: layerElement } = useForwardExpose();
      const ownerDocument = computed(() => {
        var _a2;
        return ((_a2 = layerElement.value) == null ? void 0 : _a2.ownerDocument) ?? globalThis.document;
      });
      const layers = computed(() => context.layersRoot);
      const index = computed(() => {
        return layerElement.value ? Array.from(layers.value).indexOf(layerElement.value) : -1;
      });
      const isBodyPointerEventsDisabled = computed(() => {
        return context.layersWithOutsidePointerEventsDisabled.size > 0;
      });
      const isPointerEventsEnabled = computed(() => {
        const localLayers = Array.from(layers.value);
        const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
        const highestLayerWithOutsidePointerEventsDisabledIndex = localLayers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
        return index.value >= highestLayerWithOutsidePointerEventsDisabledIndex;
      });
      const pointerDownOutside = usePointerDownOutside(async (event) => {
        const isPointerDownOnBranch = [...context.branches].some((branch) => branch == null ? void 0 : branch.contains(event.target));
        if (!isPointerEventsEnabled.value || isPointerDownOnBranch) return;
        emits("pointerDownOutside", event);
        emits("interactOutside", event);
        await nextTick();
        if (!event.defaultPrevented) emits("dismiss");
      }, layerElement);
      const focusOutside = useFocusOutside((event) => {
        const isFocusInBranch = [...context.branches].some((branch) => branch == null ? void 0 : branch.contains(event.target));
        if (isFocusInBranch) return;
        emits("focusOutside", event);
        emits("interactOutside", event);
        if (!event.defaultPrevented) emits("dismiss");
      }, layerElement);
      onKeyStroke("Escape", (event) => {
        const isHighestLayer = index.value === layers.value.size - 1;
        if (!isHighestLayer) return;
        emits("escapeKeyDown", event);
        if (!event.defaultPrevented) emits("dismiss");
      });
      let originalBodyPointerEvents;
      watchEffect((cleanupFn) => {
        if (!layerElement.value) return;
        if (props.disableOutsidePointerEvents) {
          if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
            originalBodyPointerEvents = ownerDocument.value.body.style.pointerEvents;
            ownerDocument.value.body.style.pointerEvents = "none";
          }
          context.layersWithOutsidePointerEventsDisabled.add(layerElement.value);
        }
        layers.value.add(layerElement.value);
        cleanupFn(() => {
          if (props.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) ownerDocument.value.body.style.pointerEvents = originalBodyPointerEvents;
        });
      });
      watchEffect((cleanupFn) => {
        cleanupFn(() => {
          if (!layerElement.value) return;
          layers.value.delete(layerElement.value);
          context.layersWithOutsidePointerEventsDisabled.delete(layerElement.value);
        });
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          ref: unref(forwardRef),
          "as-child": _ctx.asChild,
          as: _ctx.as,
          "data-dismissable-layer": "",
          style: normalizeStyle({ pointerEvents: isBodyPointerEventsDisabled.value ? isPointerEventsEnabled.value ? "auto" : "none" : void 0 }),
          onFocusCapture: unref(focusOutside).onFocusCapture,
          onBlurCapture: unref(focusOutside).onBlurCapture,
          onPointerdownCapture: unref(pointerDownOutside).onPointerDownCapture
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as-child",
          "as",
          "style",
          "onFocusCapture",
          "onBlurCapture",
          "onPointerdownCapture"
        ]);
      };
    }
  });
  var DismissableLayer_default = DismissableLayer_vue_vue_type_script_setup_true_lang_default;
  const useFocusStackState = createGlobalState(() => {
    const stack2 = ref([]);
    return stack2;
  });
  function createFocusScopesStack() {
    const stack2 = useFocusStackState();
    return {
      add(focusScope) {
        const activeFocusScope = stack2.value[0];
        if (focusScope !== activeFocusScope) activeFocusScope == null ? void 0 : activeFocusScope.pause();
        stack2.value = arrayRemove(stack2.value, focusScope);
        stack2.value.unshift(focusScope);
      },
      remove(focusScope) {
        var _a2;
        stack2.value = arrayRemove(stack2.value, focusScope);
        (_a2 = stack2.value[0]) == null ? void 0 : _a2.resume();
      }
    };
  }
  function arrayRemove(array, item) {
    const updatedArray = [...array];
    const index = updatedArray.indexOf(item);
    if (index !== -1) updatedArray.splice(index, 1);
    return updatedArray;
  }
  function removeLinks(items) {
    return items.filter((item) => item.tagName !== "A");
  }
  const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  const AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  const EVENT_OPTIONS$1 = {
    bubbles: false,
    cancelable: true
  };
  function focusFirst$2(candidates, { select = false } = {}) {
    const previouslyFocusedElement = getActiveElement();
    for (const candidate of candidates) {
      focus(candidate, { select });
      if (getActiveElement() !== previouslyFocusedElement) return true;
    }
  }
  function getTabbableEdges(container) {
    const candidates = getTabbableCandidates(container);
    const first = findVisible(candidates, container);
    const last = findVisible(candidates.reverse(), container);
    return [first, last];
  }
  function getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    } });
    while (walker.nextNode()) nodes.push(walker.currentNode);
    return nodes;
  }
  function findVisible(elements, container) {
    for (const element of elements) if (!isHidden(element, { upTo: container })) return element;
  }
  function isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden") return true;
    while (node) {
      if (upTo !== void 0 && node === upTo) return false;
      if (getComputedStyle(node).display === "none") return true;
      node = node.parentElement;
    }
    return false;
  }
  function isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = getActiveElement();
      element.focus({ preventScroll: true });
      if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();
    }
  }
  var FocusScope_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "FocusScope",
    props: {
      loop: {
        type: Boolean,
        required: false,
        default: false
      },
      trapped: {
        type: Boolean,
        required: false,
        default: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: ["mountAutoFocus", "unmountAutoFocus"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { currentRef, currentElement } = useForwardExpose();
      const lastFocusedElementRef = ref(null);
      const focusScopesStack = createFocusScopesStack();
      const focusScope = reactive({
        paused: false,
        pause() {
          this.paused = true;
        },
        resume() {
          this.paused = false;
        }
      });
      watchEffect((cleanupFn) => {
        if (!isClient$1) return;
        const container = currentElement.value;
        if (!props.trapped) return;
        function handleFocusIn(event) {
          if (focusScope.paused || !container) return;
          const target2 = event.target;
          if (container.contains(target2)) lastFocusedElementRef.value = target2;
          else focus(lastFocusedElementRef.value, { select: true });
        }
        function handleFocusOut(event) {
          if (focusScope.paused || !container) return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null) return;
          if (!container.contains(relatedTarget)) focus(lastFocusedElementRef.value, { select: true });
        }
        function handleMutations2(mutations2) {
          const isLastFocusedElementExist = container.contains(lastFocusedElementRef.value);
          if (!isLastFocusedElementExist) focus(container);
        }
        document.addEventListener("focusin", handleFocusIn);
        document.addEventListener("focusout", handleFocusOut);
        const mutationObserver = new MutationObserver(handleMutations2);
        if (container) mutationObserver.observe(container, {
          childList: true,
          subtree: true
        });
        cleanupFn(() => {
          document.removeEventListener("focusin", handleFocusIn);
          document.removeEventListener("focusout", handleFocusOut);
          mutationObserver.disconnect();
        });
      });
      watchEffect(async (cleanupFn) => {
        const container = currentElement.value;
        await nextTick();
        if (!container) return;
        focusScopesStack.add(focusScope);
        const previouslyFocusedElement = getActiveElement();
        const hasFocusedCandidate = container.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
          container.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            focusFirst$2(removeLinks(getTabbableCandidates(container)), { select: true });
            if (getActiveElement() === previouslyFocusedElement) focus(container);
          }
        }
        cleanupFn(() => {
          container.removeEventListener(AUTOFOCUS_ON_MOUNT, (ev) => emits("mountAutoFocus", ev));
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          const unmountEventHandler = (ev) => {
            emits("unmountAutoFocus", ev);
          };
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
          container.dispatchEvent(unmountEvent);
          setTimeout(() => {
            if (!unmountEvent.defaultPrevented) focus(previouslyFocusedElement ?? document.body, { select: true });
            container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, unmountEventHandler);
            focusScopesStack.remove(focusScope);
          }, 0);
        });
      });
      function handleKeyDown(event) {
        if (!props.loop && !props.trapped) return;
        if (focusScope.paused) return;
        const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = getActiveElement();
        if (isTabKey && focusedElement) {
          const container = event.currentTarget;
          const [first, last] = getTabbableEdges(container);
          const hasTabbableElementsInside = first && last;
          if (!hasTabbableElementsInside) {
            if (focusedElement === container) event.preventDefault();
          } else if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (props.loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (props.loop) focus(last, { select: true });
          }
        }
      }
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          ref_key: "currentRef",
          ref: currentRef,
          tabindex: "-1",
          "as-child": _ctx.asChild,
          as: _ctx.as,
          onKeydown: handleKeyDown
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, ["as-child", "as"]);
      };
    }
  });
  var FocusScope_default = FocusScope_vue_vue_type_script_setup_true_lang_default;
  const ITEM_SELECT = "menu.itemSelect";
  const SELECTION_KEYS = ["Enter", " "];
  const FIRST_KEYS = [
    "ArrowDown",
    "PageUp",
    "Home"
  ];
  const LAST_KEYS = [
    "ArrowUp",
    "PageDown",
    "End"
  ];
  const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
  ({
    ltr: [...SELECTION_KEYS, "ArrowRight"],
    rtl: [...SELECTION_KEYS, "ArrowLeft"]
  });
  function getOpenState(open) {
    return open ? "open" : "closed";
  }
  function focusFirst$1(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
      candidate.focus();
      if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
  }
  function isPointInPolygon(point, polygon) {
    const { x: x2, y: y2 } = point;
    let inside = false;
    for (let i2 = 0, j2 = polygon.length - 1; i2 < polygon.length; j2 = i2++) {
      const xi = polygon[i2].x;
      const yi = polygon[i2].y;
      const xj = polygon[j2].x;
      const yj = polygon[j2].y;
      const intersect = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }
    return inside;
  }
  function isPointerInGraceArea(event, area) {
    if (!area) return false;
    const cursorPos = {
      x: event.clientX,
      y: event.clientY
    };
    return isPointInPolygon(cursorPos, area);
  }
  function isMouseEvent(event) {
    return event.pointerType === "mouse";
  }
  var DialogContentImpl_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogContentImpl",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      trapFocus: {
        type: Boolean,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectDialogRootContext();
      const { forwardRef, currentElement: contentElement } = useForwardExpose();
      rootContext.titleId || (rootContext.titleId = useId(void 0, "reka-dialog-title"));
      rootContext.descriptionId || (rootContext.descriptionId = useId(void 0, "reka-dialog-description"));
      onMounted(() => {
        rootContext.contentElement = contentElement;
        if (getActiveElement() !== document.body) rootContext.triggerElement.value = getActiveElement();
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(FocusScope_default), {
          "as-child": "",
          loop: "",
          trapped: props.trapFocus,
          onMountAutoFocus: _cache2[5] || (_cache2[5] = ($event) => emits("openAutoFocus", $event)),
          onUnmountAutoFocus: _cache2[6] || (_cache2[6] = ($event) => emits("closeAutoFocus", $event))
        }, {
          default: withCtx(() => [createVNode(unref(DismissableLayer_default), mergeProps({
            id: unref(rootContext).contentId,
            ref: unref(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            role: "dialog",
            "aria-describedby": unref(rootContext).descriptionId,
            "aria-labelledby": unref(rootContext).titleId,
            "data-state": unref(getOpenState)(unref(rootContext).open.value)
          }, _ctx.$attrs, {
            onDismiss: _cache2[0] || (_cache2[0] = ($event) => unref(rootContext).onOpenChange(false)),
            onEscapeKeyDown: _cache2[1] || (_cache2[1] = ($event) => emits("escapeKeyDown", $event)),
            onFocusOutside: _cache2[2] || (_cache2[2] = ($event) => emits("focusOutside", $event)),
            onInteractOutside: _cache2[3] || (_cache2[3] = ($event) => emits("interactOutside", $event)),
            onPointerDownOutside: _cache2[4] || (_cache2[4] = ($event) => emits("pointerDownOutside", $event))
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "as",
            "as-child",
            "disable-outside-pointer-events",
            "aria-describedby",
            "aria-labelledby",
            "data-state"
          ])]),
          _: 3
        }, 8, ["trapped"]);
      };
    }
  });
  var DialogContentImpl_default = DialogContentImpl_vue_vue_type_script_setup_true_lang_default;
  var DialogContentModal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogContentModal",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      trapFocus: {
        type: Boolean,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectDialogRootContext();
      const emitsAsProps = useEmitAsProps(emits);
      const { forwardRef, currentElement } = useForwardExpose();
      useHideOthers(currentElement);
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(DialogContentImpl_default, mergeProps({
          ...props,
          ...unref(emitsAsProps)
        }, {
          ref: unref(forwardRef),
          "trap-focus": unref(rootContext).open.value,
          "disable-outside-pointer-events": true,
          onCloseAutoFocus: _cache2[0] || (_cache2[0] = (event) => {
            var _a2;
            if (!event.defaultPrevented) {
              event.preventDefault();
              (_a2 = unref(rootContext).triggerElement.value) == null ? void 0 : _a2.focus();
            }
          }),
          onPointerDownOutside: _cache2[1] || (_cache2[1] = (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (isRightClick) event.preventDefault();
          }),
          onFocusOutside: _cache2[2] || (_cache2[2] = (event) => {
            event.preventDefault();
          })
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["trap-focus"]);
      };
    }
  });
  var DialogContentModal_default = DialogContentModal_vue_vue_type_script_setup_true_lang_default;
  var DialogContentNonModal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogContentNonModal",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      trapFocus: {
        type: Boolean,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const emitsAsProps = useEmitAsProps(emits);
      useForwardExpose();
      const rootContext = injectDialogRootContext();
      const hasInteractedOutsideRef = ref(false);
      const hasPointerDownOutsideRef = ref(false);
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(DialogContentImpl_default, mergeProps({
          ...props,
          ...unref(emitsAsProps)
        }, {
          "trap-focus": false,
          "disable-outside-pointer-events": false,
          onCloseAutoFocus: _cache2[0] || (_cache2[0] = (event) => {
            var _a2;
            if (!event.defaultPrevented) {
              if (!hasInteractedOutsideRef.value) (_a2 = unref(rootContext).triggerElement.value) == null ? void 0 : _a2.focus();
              event.preventDefault();
            }
            hasInteractedOutsideRef.value = false;
            hasPointerDownOutsideRef.value = false;
          }),
          onInteractOutside: _cache2[1] || (_cache2[1] = (event) => {
            var _a2;
            if (!event.defaultPrevented) {
              hasInteractedOutsideRef.value = true;
              if (event.detail.originalEvent.type === "pointerdown") hasPointerDownOutsideRef.value = true;
            }
            const target2 = event.target;
            const targetIsTrigger = (_a2 = unref(rootContext).triggerElement.value) == null ? void 0 : _a2.contains(target2);
            if (targetIsTrigger) event.preventDefault();
            if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.value) event.preventDefault();
          })
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var DialogContentNonModal_default = DialogContentNonModal_vue_vue_type_script_setup_true_lang_default;
  var DialogContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogContent",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectDialogRootContext();
      const emitsAsProps = useEmitAsProps(emits);
      const { forwardRef } = useForwardExpose();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || unref(rootContext).open.value }, {
          default: withCtx(() => [unref(rootContext).modal.value ? (openBlock(), createBlock(DialogContentModal_default, mergeProps({
            key: 0,
            ref: unref(forwardRef)
          }, {
            ...props,
            ...unref(emitsAsProps),
            ..._ctx.$attrs
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16)) : (openBlock(), createBlock(DialogContentNonModal_default, mergeProps({
            key: 1,
            ref: unref(forwardRef)
          }, {
            ...props,
            ...unref(emitsAsProps),
            ..._ctx.$attrs
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16))]),
          _: 3
        }, 8, ["present"]);
      };
    }
  });
  var DialogContent_default = DialogContent_vue_vue_type_script_setup_true_lang_default;
  var DialogDescription_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogDescription",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "p"
      }
    },
    setup(__props) {
      const props = __props;
      useForwardExpose();
      const rootContext = injectDialogRootContext();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), mergeProps(props, { id: unref(rootContext).descriptionId }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["id"]);
      };
    }
  });
  var DialogDescription_default = DialogDescription_vue_vue_type_script_setup_true_lang_default;
  var DialogOverlayImpl_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogOverlayImpl",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const rootContext = injectDialogRootContext();
      useBodyScrollLock(true);
      useForwardExpose();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-state": unref(rootContext).open.value ? "open" : "closed",
          style: { "pointer-events": "auto" }
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "data-state"
        ]);
      };
    }
  });
  var DialogOverlayImpl_default = DialogOverlayImpl_vue_vue_type_script_setup_true_lang_default;
  var DialogOverlay_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogOverlay",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const rootContext = injectDialogRootContext();
      const { forwardRef } = useForwardExpose();
      return (_ctx, _cache2) => {
        var _a2;
        return ((_a2 = unref(rootContext)) == null ? void 0 : _a2.modal.value) ? (openBlock(), createBlock(unref(Presence_default), {
          key: 0,
          present: _ctx.forceMount || unref(rootContext).open.value
        }, {
          default: withCtx(() => [createVNode(DialogOverlayImpl_default, mergeProps(_ctx.$attrs, {
            ref: unref(forwardRef),
            as: _ctx.as,
            "as-child": _ctx.asChild
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16, ["as", "as-child"])]),
          _: 3
        }, 8, ["present"])) : createCommentVNode("v-if", true);
      };
    }
  });
  var DialogOverlay_default = DialogOverlay_vue_vue_type_script_setup_true_lang_default;
  var Teleport_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "Teleport",
    props: {
      to: {
        type: null,
        required: false,
        default: "body"
      },
      disabled: {
        type: Boolean,
        required: false
      },
      defer: {
        type: Boolean,
        required: false
      },
      forceMount: {
        type: Boolean,
        required: false
      }
    },
    setup(__props) {
      const isMounted = useMounted$1();
      return (_ctx, _cache2) => {
        return unref(isMounted) || _ctx.forceMount ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: _ctx.to,
          disabled: _ctx.disabled,
          defer: _ctx.defer
        }, [renderSlot(_ctx.$slots, "default")], 8, [
          "to",
          "disabled",
          "defer"
        ])) : createCommentVNode("v-if", true);
      };
    }
  });
  var Teleport_default = Teleport_vue_vue_type_script_setup_true_lang_default;
  var DialogPortal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogPortal",
    props: {
      to: {
        type: null,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      defer: {
        type: Boolean,
        required: false
      },
      forceMount: {
        type: Boolean,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Teleport_default), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var DialogPortal_default = DialogPortal_vue_vue_type_script_setup_true_lang_default;
  var DialogTitle_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogTitle",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "h2"
      }
    },
    setup(__props) {
      const props = __props;
      const rootContext = injectDialogRootContext();
      useForwardExpose();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), mergeProps(props, { id: unref(rootContext).titleId }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["id"]);
      };
    }
  });
  var DialogTitle_default = DialogTitle_vue_vue_type_script_setup_true_lang_default;
  var DialogTrigger_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DialogTrigger",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "button"
      }
    },
    setup(__props) {
      const props = __props;
      const rootContext = injectDialogRootContext();
      const { forwardRef, currentElement } = useForwardExpose();
      rootContext.contentId || (rootContext.contentId = useId(void 0, "reka-dialog-content"));
      onMounted(() => {
        rootContext.triggerElement.value = currentElement.value;
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
          ref: unref(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": unref(rootContext).open.value || false,
          "aria-controls": unref(rootContext).open.value ? unref(rootContext).contentId : void 0,
          "data-state": unref(rootContext).open.value ? "open" : "closed",
          onClick: unref(rootContext).onOpenToggle
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "type",
          "aria-expanded",
          "aria-controls",
          "data-state",
          "onClick"
        ]);
      };
    }
  });
  var DialogTrigger_default = DialogTrigger_vue_vue_type_script_setup_true_lang_default;
  const ITEM_DATA_ATTR = "data-reka-collection-item";
  function useCollection(options2 = {}) {
    const { key = "", isProvider = false } = options2;
    const injectionKey = `${key}CollectionProvider`;
    let context2;
    if (isProvider) {
      const itemMap = ref(/* @__PURE__ */ new Map());
      const collectionRef = ref();
      context2 = {
        collectionRef,
        itemMap
      };
      provide(injectionKey, context2);
    } else context2 = inject(injectionKey);
    const getItems = (includeDisabledItem = false) => {
      const collectionNode = context2.collectionRef.value;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context2.itemMap.value.values());
      const orderedItems = items.sort((a2, b2) => orderedNodes.indexOf(a2.ref) - orderedNodes.indexOf(b2.ref));
      if (includeDisabledItem) return orderedItems;
      else return orderedItems.filter((i2) => i2.ref.dataset.disabled !== "");
    };
    const CollectionSlot = /* @__PURE__ */ defineComponent({
      name: "CollectionSlot",
      setup(_2, { slots }) {
        const { primitiveElement, currentElement } = usePrimitiveElement();
        watch(currentElement, () => {
          context2.collectionRef.value = currentElement.value;
        });
        return () => h$2(Slot, { ref: primitiveElement }, slots);
      }
    });
    const CollectionItem = /* @__PURE__ */ defineComponent({
      name: "CollectionItem",
      inheritAttrs: false,
      props: { value: { validator: () => true } },
      setup(props, { slots, attrs: attrs2 }) {
        const { primitiveElement, currentElement } = usePrimitiveElement();
        watchEffect((cleanupFn) => {
          if (currentElement.value) {
            const key$1 = markRaw(currentElement.value);
            context2.itemMap.value.set(key$1, {
              ref: currentElement.value,
              value: props.value
            });
            cleanupFn(() => context2.itemMap.value.delete(key$1));
          }
        });
        return () => h$2(Slot, {
          ...attrs2,
          [ITEM_DATA_ATTR]: "",
          ref: primitiveElement
        }, slots);
      }
    });
    const reactiveItems = computed(() => Array.from(context2.itemMap.value.values()));
    const itemMapSize = computed(() => context2.itemMap.value.size);
    return {
      getItems,
      reactiveItems,
      itemMapSize,
      CollectionSlot,
      CollectionItem
    };
  }
  const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
  const EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
  };
  const MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function getDirectionAwareKey(key, dir) {
    if (dir !== "rtl") return key;
    return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
  }
  function getFocusIntent(event, orientation, dir) {
    const key = getDirectionAwareKey(event.key, dir);
    if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
    if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
    return MAP_KEY_TO_FOCUS_INTENT[key];
  }
  function focusFirst(candidates, preventScroll = false) {
    const PREVIOUSLY_FOCUSED_ELEMENT = getActiveElement();
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
      candidate.focus({ preventScroll });
      if (getActiveElement() !== PREVIOUSLY_FOCUSED_ELEMENT) return;
    }
  }
  const [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext("RovingFocusGroup");
  var RovingFocusGroup_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "RovingFocusGroup",
    props: {
      orientation: {
        type: String,
        required: false,
        default: void 0
      },
      dir: {
        type: String,
        required: false
      },
      loop: {
        type: Boolean,
        required: false,
        default: false
      },
      currentTabStopId: {
        type: [String, null],
        required: false
      },
      defaultCurrentTabStopId: {
        type: String,
        required: false
      },
      preventScrollOnEntryFocus: {
        type: Boolean,
        required: false,
        default: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: ["entryFocus", "update:currentTabStopId"],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { loop, orientation, dir: propDir } = toRefs(props);
      const dir = useDirection(propDir);
      const currentTabStopId = useVModel(props, "currentTabStopId", emits, {
        defaultValue: props.defaultCurrentTabStopId,
        passive: props.currentTabStopId === void 0
      });
      const isTabbingBackOut = ref(false);
      const isClickFocus = ref(false);
      const focusableItemsCount = ref(0);
      const { getItems, CollectionSlot } = useCollection({ isProvider: true });
      function handleFocus(event) {
        const isKeyboardFocus = !isClickFocus.value;
        if (event.currentTarget && event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut.value) {
          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          emits("entryFocus", entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().map((i2) => i2.ref).filter((i2) => i2.dataset.disabled !== "");
            const activeItem = items.find((item) => item.getAttribute("data-active") === "");
            const highlightedItem = items.find((item) => item.getAttribute("data-highlighted") === "");
            const currentItem = items.find((item) => item.id === currentTabStopId.value);
            const candidateItems = [
              activeItem,
              highlightedItem,
              currentItem,
              ...items
            ].filter(Boolean);
            focusFirst(candidateItems, props.preventScrollOnEntryFocus);
          }
        }
        isClickFocus.value = false;
      }
      function handleMouseUp() {
        setTimeout(() => {
          isClickFocus.value = false;
        }, 1);
      }
      __expose({ getItems });
      provideRovingFocusGroupContext({
        loop,
        dir,
        orientation,
        currentTabStopId,
        onItemFocus: (tabStopId) => {
          currentTabStopId.value = tabStopId;
        },
        onItemShiftTab: () => {
          isTabbingBackOut.value = true;
        },
        onFocusableItemAdd: () => {
          focusableItemsCount.value++;
        },
        onFocusableItemRemove: () => {
          focusableItemsCount.value--;
        }
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(CollectionSlot), null, {
          default: withCtx(() => [createVNode(unref(Primitive), {
            tabindex: isTabbingBackOut.value || focusableItemsCount.value === 0 ? -1 : 0,
            "data-orientation": unref(orientation),
            as: _ctx.as,
            "as-child": _ctx.asChild,
            dir: unref(dir),
            style: { "outline": "none" },
            onMousedown: _cache2[0] || (_cache2[0] = ($event) => isClickFocus.value = true),
            onMouseup: handleMouseUp,
            onFocus: handleFocus,
            onBlur: _cache2[1] || (_cache2[1] = ($event) => isTabbingBackOut.value = false)
          }, {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 8, [
            "tabindex",
            "data-orientation",
            "as",
            "as-child",
            "dir"
          ])]),
          _: 3
        });
      };
    }
  });
  var RovingFocusGroup_default = RovingFocusGroup_vue_vue_type_script_setup_true_lang_default;
  var VisuallyHidden_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "VisuallyHidden",
    props: {
      feature: {
        type: String,
        required: false,
        default: "focusable"
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "span"
      }
    },
    setup(__props) {
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "aria-hidden": _ctx.feature === "focusable" ? "true" : void 0,
          "data-hidden": _ctx.feature === "fully-hidden" ? "" : void 0,
          tabindex: _ctx.feature === "fully-hidden" ? "-1" : void 0,
          style: {
            position: "absolute",
            border: 0,
            width: "1px",
            height: "1px",
            padding: 0,
            margin: "-1px",
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            clipPath: "inset(50%)",
            whiteSpace: "nowrap",
            wordWrap: "normal",
            top: "-1px",
            left: "-1px"
          }
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "aria-hidden",
          "data-hidden",
          "tabindex"
        ]);
      };
    }
  });
  var VisuallyHidden_default = VisuallyHidden_vue_vue_type_script_setup_true_lang_default;
  var VisuallyHiddenInputBubble_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    inheritAttrs: false,
    __name: "VisuallyHiddenInputBubble",
    props: {
      name: {
        type: String,
        required: true
      },
      value: {
        type: null,
        required: true
      },
      checked: {
        type: Boolean,
        required: false,
        default: void 0
      },
      required: {
        type: Boolean,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      feature: {
        type: String,
        required: false,
        default: "fully-hidden"
      }
    },
    setup(__props) {
      const props = __props;
      const { primitiveElement, currentElement } = usePrimitiveElement();
      const valueState = computed(() => props.checked ?? props.value);
      watch(valueState, (cur, prev) => {
        if (!currentElement.value) return;
        const input = currentElement.value;
        const inputProto = window.HTMLInputElement.prototype;
        const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
        const setValue = descriptor.set;
        if (setValue && cur !== prev) {
          const inputEvent = new Event("input", { bubbles: true });
          const changeEvent = new Event("change", { bubbles: true });
          setValue.call(input, cur);
          input.dispatchEvent(inputEvent);
          input.dispatchEvent(changeEvent);
        }
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(VisuallyHidden_default, mergeProps({
          ref_key: "primitiveElement",
          ref: primitiveElement
        }, {
          ...props,
          ..._ctx.$attrs
        }, { as: "input" }), null, 16);
      };
    }
  });
  var VisuallyHiddenInputBubble_default = VisuallyHiddenInputBubble_vue_vue_type_script_setup_true_lang_default;
  var VisuallyHiddenInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    inheritAttrs: false,
    __name: "VisuallyHiddenInput",
    props: {
      name: {
        type: String,
        required: true
      },
      value: {
        type: null,
        required: true
      },
      checked: {
        type: Boolean,
        required: false,
        default: void 0
      },
      required: {
        type: Boolean,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      feature: {
        type: String,
        required: false,
        default: "fully-hidden"
      }
    },
    setup(__props) {
      const props = __props;
      const isFormArrayEmptyAndRequired = computed(() => typeof props.value === "object" && Array.isArray(props.value) && props.value.length === 0 && props.required);
      const parsedValue = computed(() => {
        if (typeof props.value === "string" || typeof props.value === "number" || typeof props.value === "boolean" || props.value === null || props.value === void 0) return [{
          name: props.name,
          value: props.value
        }];
        else if (typeof props.value === "object" && Array.isArray(props.value)) return props.value.flatMap((obj, index) => {
          if (typeof obj === "object") return Object.entries(obj).map(([key, value]) => ({
            name: `${props.name}[${index}][${key}]`,
            value
          }));
          else return {
            name: `${props.name}[${index}]`,
            value: obj
          };
        });
        else if (props.value !== null && typeof props.value === "object" && !Array.isArray(props.value)) return Object.entries(props.value).map(([key, value]) => ({
          name: `${props.name}[${key}]`,
          value
        }));
        return [];
      });
      return (_ctx, _cache2) => {
        return openBlock(), createElementBlock(Fragment, null, [createCommentVNode(" We render single input if it's required "), isFormArrayEmptyAndRequired.value ? (openBlock(), createBlock(VisuallyHiddenInputBubble_default, mergeProps({ key: _ctx.name }, {
          ...props,
          ..._ctx.$attrs
        }, {
          name: _ctx.name,
          value: _ctx.value
        }), null, 16, ["name", "value"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(parsedValue.value, (parsed) => {
          return openBlock(), createBlock(VisuallyHiddenInputBubble_default, mergeProps({ key: parsed.name }, { ref_for: true }, {
            ...props,
            ..._ctx.$attrs
          }, {
            name: parsed.name,
            value: parsed.value
          }), null, 16, ["name", "value"]);
        }), 128))], 2112);
      };
    }
  });
  var VisuallyHiddenInput_default = VisuallyHiddenInput_vue_vue_type_script_setup_true_lang_default;
  const [injectPopperRootContext, providePopperRootContext] = createContext("PopperRoot");
  var PopperRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    inheritAttrs: false,
    __name: "PopperRoot",
    setup(__props) {
      const anchor = ref();
      providePopperRootContext({
        anchor,
        onAnchorChange: (element) => anchor.value = element
      });
      return (_ctx, _cache2) => {
        return renderSlot(_ctx.$slots, "default");
      };
    }
  });
  var PopperRoot_default = PopperRoot_vue_vue_type_script_setup_true_lang_default;
  var PopperAnchor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "PopperAnchor",
    props: {
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      const { forwardRef, currentElement } = useForwardExpose();
      const rootContext = injectPopperRootContext();
      watchPostEffect(() => {
        rootContext.onAnchorChange(props.reference ?? currentElement.value);
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          ref: unref(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, ["as", "as-child"]);
      };
    }
  });
  var PopperAnchor_default = PopperAnchor_vue_vue_type_script_setup_true_lang_default;
  function isNotNull(value) {
    return value !== null;
  }
  function transformOrigin(options2) {
    return {
      name: "transformOrigin",
      options: options2,
      fn(data) {
        var _a2, _b2, _c2;
        const { placement, rects, middlewareData } = data;
        const cannotCenterArrow = ((_a2 = middlewareData.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
        const isArrowHidden = cannotCenterArrow;
        const arrowWidth = isArrowHidden ? 0 : options2.arrowWidth;
        const arrowHeight = isArrowHidden ? 0 : options2.arrowHeight;
        const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
        const noArrowAlign = {
          start: "0%",
          center: "50%",
          end: "100%"
        }[placedAlign];
        const arrowXCenter = (((_b2 = middlewareData.arrow) == null ? void 0 : _b2.x) ?? 0) + arrowWidth / 2;
        const arrowYCenter = (((_c2 = middlewareData.arrow) == null ? void 0 : _c2.y) ?? 0) + arrowHeight / 2;
        let x2 = "";
        let y2 = "";
        if (placedSide === "bottom") {
          x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
          y2 = `${-arrowHeight}px`;
        } else if (placedSide === "top") {
          x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
          y2 = `${rects.floating.height + arrowHeight}px`;
        } else if (placedSide === "right") {
          x2 = `${-arrowHeight}px`;
          y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
        } else if (placedSide === "left") {
          x2 = `${rects.floating.width + arrowHeight}px`;
          y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
        }
        return { data: {
          x: x2,
          y: y2
        } };
      }
    };
  }
  function getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [side, align];
  }
  const sides = ["top", "right", "bottom", "left"];
  const min = Math.min;
  const max = Math.max;
  const round = Math.round;
  const floor = Math.floor;
  const createCoords = (v2) => ({
    x: v2,
    y: v2
  });
  const oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  const oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end2) {
    return max(start, min(value, end2));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rl : lr;
        return isStart ? lr : rl;
      case "left":
      case "right":
        return isStart ? tb : bt;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y2,
      left: x2,
      right: x2 + width,
      bottom: y2 + height,
      x: x2,
      y: y2
    };
  }
  function computeCoordsFromPlacement(_ref2, placement, rtl) {
    let {
      reference,
      floating
    } = _ref2;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords2;
    switch (side) {
      case "top":
        coords2 = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords2 = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords2 = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords2 = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords2 = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords2[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords2[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords2;
  }
  const computePosition$1 = async (reference, floating, config2) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config2;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn({
        x: x2,
        y: y2,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y2 = nextY != null ? nextY : y2;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y: y2
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
      }
    }
    return {
      x: x2,
      y: y2,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options2) {
    var _await$platform$isEle;
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      x: x2,
      y: y2,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options2, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y2,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  const arrow$2 = (options2) => ({
    name: "arrow",
    options: options2,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options2, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords2 = {
        x: x2,
        y: y2
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords2[axis] - rects.floating[length];
      const startDiff = coords2[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
      return {
        [axis]: coords2[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  const flip$1 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "flip",
      options: options2,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options2, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const initialSideAxis = getSideAxis(initialPlacement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
        if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$filter2;
                const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                  if (hasFallbackAxisSideDirection) {
                    const currentSideAxis = getSideAxis(d2.placement);
                    return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    currentSideAxis === "y";
                  }
                  return true;
                }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  const hide$1 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "hide",
      options: options2,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options2, state);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  async function convertValueToCoords(state, options2) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options2, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  const offset$1 = function(options2) {
    if (options2 === void 0) {
      options2 = 0;
    }
    return {
      name: "offset",
      options: options2,
      async fn(state) {
        var _middlewareData$offse, _middlewareData$arrow;
        const {
          x: x2,
          y: y2,
          placement,
          middlewareData
        } = state;
        const diffCoords = await convertValueToCoords(state, options2);
        if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        return {
          x: x2 + diffCoords.x,
          y: y2 + diffCoords.y,
          data: {
            ...diffCoords,
            placement
          }
        };
      }
    };
  };
  const shift$1 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "shift",
      options: options2,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref2) => {
              let {
                x: x3,
                y: y3
              } = _ref2;
              return {
                x: x3,
                y: y3
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options2, state);
        const coords2 = {
          x: x2,
          y: y2
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords2[mainAxis];
        let crossAxisCoord = coords2[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y2,
            enabled: {
              [mainAxis]: checkMainAxis,
              [crossAxis]: checkCrossAxis
            }
          }
        };
      }
    };
  };
  const limitShift$1 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      options: options2,
      fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset: offset2 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options2, state);
        const coords2 = {
          x: x2,
          y: y2
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords2[mainAxis];
        let crossAxisCoord = coords2[crossAxis];
        const rawOffset = evaluate(offset2, state);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = ["top", "left"].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  const size$1 = function(options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    return {
      name: "size",
      options: options2,
      async fn(state) {
        var _state$middlewareData, _state$middlewareData2;
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply: apply2 = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options2, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const maximumClippingHeight = height - overflow.top - overflow.bottom;
        const maximumClippingWidth = width - overflow.left - overflow.right;
        const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
        const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
          availableWidth = maximumClippingWidth;
        }
        if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
          availableHeight = maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply2({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref2;
    return (_ref2 = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref2.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle$1(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isTopLayer(element) {
    return [":popover-open", ":modal"].some((selector) => {
      try {
        return element.matches(selector);
      } catch (e2) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css2 = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
    return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node.assignedSlot || // DOM Element detected.
      node.parentNode || // ShadowRoot detected.
      isShadowRoot(node) && node.host || // Fallback.
      getDocumentElement(node)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  function getCssDimensions(element) {
    const css2 = getComputedStyle$1(element);
    let width = parseFloat(css2.width) || 0;
    let height = parseFloat(css2.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement$1(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement$1(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $
    } = getCssDimensions(domElement);
    let x2 = ($ ? round(rect.width) : rect.width) / width;
    let y2 = ($ ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y2 || !Number.isFinite(y2)) {
      y2 = 1;
    }
    return {
      x: x2,
      y: y2
    };
  }
  const noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement$1(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale.x;
    let y2 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css2 = getComputedStyle$1(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y2 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y2 += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y2
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
    if (ignoreScrollbarX === void 0) {
      ignoreScrollbarX = false;
    }
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
      // RTL <body> scrollbar.
      getWindowScrollBarX(documentElement, htmlRect)
    ));
    const y2 = htmlRect.top + scroll.scrollTop;
    return {
      x: x2,
      y: y2
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref2) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref2;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y2 = -scroll.scrollTop;
    if (getComputedStyle$1(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y2 = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle$1(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle$1(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref2) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref2;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y: y2,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle$1(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  const getElementRects = async function(data) {
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    const floatingDimensions = await getDimensionsFn(data.floating);
    return {
      reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
      floating: {
        x: 0,
        y: 0,
        width: floatingDimensions.width,
        height: floatingDimensions.height
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle$1(element).direction === "rtl";
  }
  const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function rectsAreEqual(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element);
    function cleanup() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options2 = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options2,
          // Handle <iframe>s
          root: root2.ownerDocument
        });
      } catch (e2) {
        io = new IntersectionObserver(handleObserve, options2);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options2;
    const referenceEl = unwrapElement$1(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref2) => {
        let [firstEntry] = _ref2;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  const offset = offset$1;
  const shift = shift$1;
  const flip = flip$1;
  const size = size$1;
  const hide = hide$1;
  const arrow$1 = arrow$2;
  const limitShift = limitShift$1;
  const computePosition = (reference, floating, options2) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options2
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition$1(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };
  function isComponentPublicInstance(target2) {
    return target2 != null && typeof target2 === "object" && "$el" in target2;
  }
  function unwrapElement(target2) {
    if (isComponentPublicInstance(target2)) {
      const element = target2.$el;
      return isNode(element) && getNodeName(element) === "#comment" ? null : element;
    }
    return target2;
  }
  function toValue$1(source) {
    return typeof source === "function" ? source() : unref(source);
  }
  function arrow(options2) {
    return {
      name: "arrow",
      options: options2,
      fn(args) {
        const element = unwrapElement(toValue$1(options2.element));
        if (element == null) {
          return {};
        }
        return arrow$1({
          element,
          padding: options2.padding
        }).fn(args);
      }
    };
  }
  function getDPR(element) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }
  function useFloating(reference, floating, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    const whileElementsMountedOption = options2.whileElementsMounted;
    const openOption = computed(() => {
      var _toValue;
      return (_toValue = toValue$1(options2.open)) != null ? _toValue : true;
    });
    const middlewareOption = computed(() => toValue$1(options2.middleware));
    const placementOption = computed(() => {
      var _toValue2;
      return (_toValue2 = toValue$1(options2.placement)) != null ? _toValue2 : "bottom";
    });
    const strategyOption = computed(() => {
      var _toValue3;
      return (_toValue3 = toValue$1(options2.strategy)) != null ? _toValue3 : "absolute";
    });
    const transformOption = computed(() => {
      var _toValue4;
      return (_toValue4 = toValue$1(options2.transform)) != null ? _toValue4 : true;
    });
    const referenceElement = computed(() => unwrapElement(reference.value));
    const floatingElement = computed(() => unwrapElement(floating.value));
    const x2 = ref(0);
    const y2 = ref(0);
    const strategy = ref(strategyOption.value);
    const placement = ref(placementOption.value);
    const middlewareData = shallowRef({});
    const isPositioned = ref(false);
    const floatingStyles = computed(() => {
      const initialStyles = {
        position: strategy.value,
        left: "0",
        top: "0"
      };
      if (!floatingElement.value) {
        return initialStyles;
      }
      const xVal = roundByDPR(floatingElement.value, x2.value);
      const yVal = roundByDPR(floatingElement.value, y2.value);
      if (transformOption.value) {
        return {
          ...initialStyles,
          transform: "translate(" + xVal + "px, " + yVal + "px)",
          ...getDPR(floatingElement.value) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy.value,
        left: xVal + "px",
        top: yVal + "px"
      };
    });
    let whileElementsMountedCleanup;
    function update() {
      if (referenceElement.value == null || floatingElement.value == null) {
        return;
      }
      const open = openOption.value;
      computePosition(referenceElement.value, floatingElement.value, {
        middleware: middlewareOption.value,
        placement: placementOption.value,
        strategy: strategyOption.value
      }).then((position) => {
        x2.value = position.x;
        y2.value = position.y;
        strategy.value = position.strategy;
        placement.value = position.placement;
        middlewareData.value = position.middlewareData;
        isPositioned.value = open !== false;
      });
    }
    function cleanup() {
      if (typeof whileElementsMountedCleanup === "function") {
        whileElementsMountedCleanup();
        whileElementsMountedCleanup = void 0;
      }
    }
    function attach() {
      cleanup();
      if (whileElementsMountedOption === void 0) {
        update();
        return;
      }
      if (referenceElement.value != null && floatingElement.value != null) {
        whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);
        return;
      }
    }
    function reset() {
      if (!openOption.value) {
        isPositioned.value = false;
      }
    }
    watch([middlewareOption, placementOption, strategyOption, openOption], update, {
      flush: "sync"
    });
    watch([referenceElement, floatingElement], attach, {
      flush: "sync"
    });
    watch(openOption, reset, {
      flush: "sync"
    });
    if (getCurrentScope()) {
      onScopeDispose(cleanup);
    }
    return {
      x: shallowReadonly(x2),
      y: shallowReadonly(y2),
      strategy: shallowReadonly(strategy),
      placement: shallowReadonly(placement),
      middlewareData: shallowReadonly(middlewareData),
      isPositioned: shallowReadonly(isPositioned),
      floatingStyles,
      update
    };
  }
  const PopperContentPropsDefaultValue = {
    side: "bottom",
    sideOffset: 0,
    sideFlip: true,
    align: "center",
    alignOffset: 0,
    alignFlip: true,
    arrowPadding: 0,
    avoidCollisions: true,
    collisionBoundary: () => [],
    collisionPadding: 0,
    sticky: "partial",
    hideWhenDetached: false,
    positionStrategy: "fixed",
    updatePositionStrategy: "optimized",
    prioritizePosition: false
  };
  const [injectPopperContentContext, providePopperContentContext] = createContext("PopperContent");
  var PopperContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    inheritAttrs: false,
    __name: "PopperContent",
    props: /* @__PURE__ */ mergeDefaults({
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    }, { ...PopperContentPropsDefaultValue }),
    emits: ["placed"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectPopperRootContext();
      const { forwardRef, currentElement: contentElement } = useForwardExpose();
      const floatingRef = ref();
      const arrow$12 = ref();
      const { width: arrowWidth, height: arrowHeight } = useSize(arrow$12);
      const desiredPlacement = computed(() => props.side + (props.align !== "center" ? `-${props.align}` : ""));
      const collisionPadding = computed(() => {
        return typeof props.collisionPadding === "number" ? props.collisionPadding : {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...props.collisionPadding
        };
      });
      const boundary = computed(() => {
        return Array.isArray(props.collisionBoundary) ? props.collisionBoundary : [props.collisionBoundary];
      });
      const detectOverflowOptions = computed(() => {
        return {
          padding: collisionPadding.value,
          boundary: boundary.value.filter(isNotNull),
          altBoundary: boundary.value.length > 0
        };
      });
      const flipOptions = computed(() => {
        return {
          mainAxis: props.sideFlip,
          crossAxis: props.alignFlip
        };
      });
      const computedMiddleware = computedEager(() => {
        return [
          offset({
            mainAxis: props.sideOffset + arrowHeight.value,
            alignmentAxis: props.alignOffset
          }),
          props.prioritizePosition && props.avoidCollisions && flip({
            ...detectOverflowOptions.value,
            ...flipOptions.value
          }),
          props.avoidCollisions && shift({
            mainAxis: true,
            crossAxis: !!props.prioritizePosition,
            limiter: props.sticky === "partial" ? limitShift() : void 0,
            ...detectOverflowOptions.value
          }),
          !props.prioritizePosition && props.avoidCollisions && flip({
            ...detectOverflowOptions.value,
            ...flipOptions.value
          }),
          size({
            ...detectOverflowOptions.value,
            apply: ({ elements, rects, availableWidth, availableHeight }) => {
              const { width: anchorWidth, height: anchorHeight } = rects.reference;
              const contentStyle = elements.floating.style;
              contentStyle.setProperty("--reka-popper-available-width", `${availableWidth}px`);
              contentStyle.setProperty("--reka-popper-available-height", `${availableHeight}px`);
              contentStyle.setProperty("--reka-popper-anchor-width", `${anchorWidth}px`);
              contentStyle.setProperty("--reka-popper-anchor-height", `${anchorHeight}px`);
            }
          }),
          arrow$12.value && arrow({
            element: arrow$12.value,
            padding: props.arrowPadding
          }),
          transformOrigin({
            arrowWidth: arrowWidth.value,
            arrowHeight: arrowHeight.value
          }),
          props.hideWhenDetached && hide({
            strategy: "referenceHidden",
            ...detectOverflowOptions.value
          })
        ];
      });
      const reference = computed(() => props.reference ?? rootContext.anchor.value);
      const { floatingStyles, placement, isPositioned, middlewareData, update } = useFloating(reference, floatingRef, {
        strategy: props.positionStrategy,
        placement: desiredPlacement,
        whileElementsMounted: (...args) => {
          const cleanup = autoUpdate(...args, {
            layoutShift: !props.disableUpdateOnLayoutShift,
            animationFrame: props.updatePositionStrategy === "always"
          });
          return cleanup;
        },
        middleware: computedMiddleware
      });
      const placedSide = computed(() => getSideAndAlignFromPlacement(placement.value)[0]);
      const placedAlign = computed(() => getSideAndAlignFromPlacement(placement.value)[1]);
      watchPostEffect(() => {
        if (isPositioned.value) emits("placed");
      });
      const cannotCenterArrow = computed(() => {
        var _a2;
        return ((_a2 = middlewareData.value.arrow) == null ? void 0 : _a2.centerOffset) !== 0;
      });
      const contentZIndex = ref("");
      watchEffect(() => {
        if (contentElement.value) contentZIndex.value = window.getComputedStyle(contentElement.value).zIndex;
      });
      const arrowX = computed(() => {
        var _a2;
        return ((_a2 = middlewareData.value.arrow) == null ? void 0 : _a2.x) ?? 0;
      });
      const arrowY = computed(() => {
        var _a2;
        return ((_a2 = middlewareData.value.arrow) == null ? void 0 : _a2.y) ?? 0;
      });
      providePopperContentContext({
        placedSide,
        onArrowChange: (element) => arrow$12.value = element,
        arrowX,
        arrowY,
        shouldHideArrow: cannotCenterArrow
      });
      return (_ctx, _cache2) => {
        var _a2, _b2, _c2;
        return openBlock(), createElementBlock("div", {
          ref_key: "floatingRef",
          ref: floatingRef,
          "data-reka-popper-content-wrapper": "",
          style: normalizeStyle({
            ...unref(floatingStyles),
            transform: unref(isPositioned) ? unref(floatingStyles).transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: contentZIndex.value,
            ["--reka-popper-transform-origin"]: [(_a2 = unref(middlewareData).transformOrigin) == null ? void 0 : _a2.x, (_b2 = unref(middlewareData).transformOrigin) == null ? void 0 : _b2.y].join(" "),
            ...((_c2 = unref(middlewareData).hide) == null ? void 0 : _c2.referenceHidden) && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          })
        }, [createVNode(unref(Primitive), mergeProps({ ref: unref(forwardRef) }, _ctx.$attrs, {
          "as-child": props.asChild,
          as: _ctx.as,
          "data-side": placedSide.value,
          "data-align": placedAlign.value,
          style: { animation: !unref(isPositioned) ? "none" : void 0 }
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "as-child",
          "as",
          "data-side",
          "data-align",
          "style"
        ])], 4);
      };
    }
  });
  var PopperContent_default = PopperContent_vue_vue_type_script_setup_true_lang_default;
  var ComboboxAnchor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxAnchor",
    props: {
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const { forwardRef } = useForwardExpose();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(PopperAnchor_default), {
          "as-child": "",
          reference: _ctx.reference
        }, {
          default: withCtx(() => [createVNode(unref(Primitive), mergeProps({
            ref: unref(forwardRef),
            "as-child": _ctx.asChild,
            as: _ctx.as
          }, _ctx.$attrs), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16, ["as-child", "as"])]),
          _: 3
        }, 8, ["reference"]);
      };
    }
  });
  var ComboboxAnchor_default = ComboboxAnchor_vue_vue_type_script_setup_true_lang_default;
  function valueComparator(value, currentValue, comparator) {
    if (value === void 0) return false;
    else if (Array.isArray(value)) return value.some((val) => compare(val, currentValue, comparator));
    else return compare(value, currentValue, comparator);
  }
  function compare(value, currentValue, comparator) {
    if (value === void 0 || currentValue === void 0) return false;
    if (typeof value === "string") return value === currentValue;
    if (typeof comparator === "function") return comparator(value, currentValue);
    if (typeof comparator === "string") return (value == null ? void 0 : value[comparator]) === (currentValue == null ? void 0 : currentValue[comparator]);
    return isEqual(value, currentValue);
  }
  const [injectListboxRootContext, provideListboxRootContext] = createContext("ListboxRoot");
  var ListboxRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ListboxRoot",
    props: {
      modelValue: {
        type: null,
        required: false
      },
      defaultValue: {
        type: null,
        required: false
      },
      multiple: {
        type: Boolean,
        required: false
      },
      orientation: {
        type: String,
        required: false,
        default: "vertical"
      },
      dir: {
        type: String,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      selectionBehavior: {
        type: String,
        required: false,
        default: "toggle"
      },
      highlightOnHover: {
        type: Boolean,
        required: false
      },
      by: {
        type: [String, Function],
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      },
      name: {
        type: String,
        required: false
      },
      required: {
        type: Boolean,
        required: false
      }
    },
    emits: [
      "update:modelValue",
      "highlight",
      "entryFocus",
      "leave"
    ],
    setup(__props, { expose: __expose, emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { multiple, highlightOnHover, orientation, disabled: disabled2, selectionBehavior, dir: propDir } = toRefs(props);
      const { getItems } = useCollection({ isProvider: true });
      const { handleTypeaheadSearch } = useTypeahead();
      const { primitiveElement, currentElement } = usePrimitiveElement();
      const kbd = useKbd();
      const dir = useDirection(propDir);
      const isFormControl = useFormControl(currentElement);
      const firstValue = ref();
      const isUserAction = ref(false);
      const focusable = ref(true);
      const modelValue = useVModel(props, "modelValue", emits, {
        defaultValue: props.defaultValue ?? (multiple.value ? [] : void 0),
        passive: props.modelValue === void 0,
        deep: true
      });
      function onValueChange(val) {
        isUserAction.value = true;
        if (props.multiple) {
          const modelArray = Array.isArray(modelValue.value) ? [...modelValue.value] : [];
          const index = modelArray.findIndex((i2) => compare(i2, val, props.by));
          if (props.selectionBehavior === "toggle") {
            index === -1 ? modelArray.push(val) : modelArray.splice(index, 1);
            modelValue.value = modelArray;
          } else {
            modelValue.value = [val];
            firstValue.value = val;
          }
        } else if (props.selectionBehavior === "toggle") if (compare(modelValue.value, val, props.by)) modelValue.value = void 0;
        else modelValue.value = val;
        else modelValue.value = val;
        setTimeout(() => {
          isUserAction.value = false;
        }, 1);
      }
      const highlightedElement = ref(null);
      const previousElement = ref(null);
      const isVirtual = ref(false);
      const isComposing = ref(false);
      const virtualFocusHook = createEventHook();
      const virtualKeydownHook = createEventHook();
      const virtualHighlightHook = createEventHook();
      function getCollectionItem() {
        return getItems().map((i2) => i2.ref).filter((i2) => i2.dataset.disabled !== "");
      }
      function changeHighlight(el, scrollIntoView = true) {
        if (!el) return;
        highlightedElement.value = el;
        if (focusable.value) highlightedElement.value.focus();
        if (scrollIntoView) highlightedElement.value.scrollIntoView({ block: "nearest" });
        const highlightedItem = getItems().find((i2) => i2.ref === el);
        emits("highlight", highlightedItem);
      }
      function highlightItem(value) {
        if (isVirtual.value) virtualHighlightHook.trigger(value);
        else {
          const item = getItems().find((i2) => compare(i2.value, value, props.by));
          if (item) {
            highlightedElement.value = item.ref;
            changeHighlight(item.ref);
          }
        }
      }
      function onKeydownEnter(event) {
        if (highlightedElement.value && highlightedElement.value.isConnected) {
          event.preventDefault();
          event.stopPropagation();
          if (!isComposing.value) highlightedElement.value.click();
        }
      }
      function onKeydownTypeAhead(event) {
        if (!focusable.value) return;
        isUserAction.value = true;
        if (isVirtual.value) virtualKeydownHook.trigger(event);
        else {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          if (isMetaKey && event.key === "a" && multiple.value) {
            const collection = getItems();
            const values = collection.map((i2) => i2.value);
            modelValue.value = [...values];
            event.preventDefault();
            changeHighlight(collection[collection.length - 1].ref);
          } else if (!isMetaKey) {
            const el = handleTypeaheadSearch(event.key, getItems());
            if (el) changeHighlight(el);
          }
        }
        setTimeout(() => {
          isUserAction.value = false;
        }, 1);
      }
      function onCompositionStart2() {
        isComposing.value = true;
      }
      function onCompositionEnd2() {
        nextTick(() => {
          isComposing.value = false;
        });
      }
      function highlightFirstItem() {
        nextTick(() => {
          const event = new KeyboardEvent("keydown", { key: "PageUp" });
          onKeydownNavigation(event);
        });
      }
      function onLeave(event) {
        const el = highlightedElement.value;
        if (el == null ? void 0 : el.isConnected) previousElement.value = el;
        highlightedElement.value = null;
        emits("leave", event);
      }
      function onEnter(event) {
        var _a2, _b2;
        const entryFocusEvent = new CustomEvent("listbox.entryFocus", {
          bubbles: false,
          cancelable: true
        });
        (_a2 = event.currentTarget) == null ? void 0 : _a2.dispatchEvent(entryFocusEvent);
        emits("entryFocus", entryFocusEvent);
        if (entryFocusEvent.defaultPrevented) return;
        if (previousElement.value) changeHighlight(previousElement.value);
        else {
          const el = (_b2 = getCollectionItem()) == null ? void 0 : _b2[0];
          changeHighlight(el);
        }
      }
      function onKeydownNavigation(event) {
        const intent = getFocusIntent(event, orientation.value, dir.value);
        if (!intent) return;
        let collection = getCollectionItem();
        if (highlightedElement.value) {
          if (intent === "last") collection.reverse();
          else if (intent === "prev" || intent === "next") {
            if (intent === "prev") collection.reverse();
            const currentIndex = collection.indexOf(highlightedElement.value);
            collection = collection.slice(currentIndex + 1);
          }
          handleMultipleReplace(event, collection[0]);
        }
        if (collection.length) {
          const index = !highlightedElement.value && intent === "prev" ? collection.length - 1 : 0;
          changeHighlight(collection[index]);
        }
        if (isVirtual.value) return virtualKeydownHook.trigger(event);
      }
      function handleMultipleReplace(event, targetEl) {
        var _a2;
        if (isVirtual.value || props.selectionBehavior !== "replace" || !multiple.value || !Array.isArray(modelValue.value)) return;
        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
        if (isMetaKey && !event.shiftKey) return;
        if (event.shiftKey) {
          const collection = getItems().filter((i2) => i2.ref.dataset.disabled !== "");
          let lastValue = (_a2 = collection.find((i2) => i2.ref === targetEl)) == null ? void 0 : _a2.value;
          if (event.key === kbd.END) lastValue = collection[collection.length - 1].value;
          else if (event.key === kbd.HOME) lastValue = collection[0].value;
          if (!lastValue || !firstValue.value) return;
          const values = findValuesBetween(collection.map((i2) => i2.value), firstValue.value, lastValue);
          modelValue.value = values;
        }
      }
      async function highlightSelected(event) {
        await nextTick();
        if (isVirtual.value) virtualFocusHook.trigger(event);
        else {
          const collection = getCollectionItem();
          const item = collection.find((i2) => i2.dataset.state === "checked");
          if (item) changeHighlight(item);
          else if (collection.length) changeHighlight(collection[0]);
        }
      }
      watch(modelValue, () => {
        if (!isUserAction.value) nextTick(() => {
          highlightSelected();
        });
      }, {
        immediate: true,
        deep: true
      });
      __expose({
        highlightedElement,
        highlightItem,
        highlightFirstItem,
        highlightSelected,
        getItems
      });
      provideListboxRootContext({
        modelValue,
        onValueChange,
        multiple,
        orientation,
        dir,
        disabled: disabled2,
        highlightOnHover,
        highlightedElement,
        isVirtual,
        virtualFocusHook,
        virtualKeydownHook,
        virtualHighlightHook,
        by: props.by,
        firstValue,
        selectionBehavior,
        focusable,
        onLeave,
        onEnter,
        changeHighlight,
        onKeydownEnter,
        onKeydownNavigation,
        onKeydownTypeAhead,
        onCompositionStart: onCompositionStart2,
        onCompositionEnd: onCompositionEnd2,
        highlightFirstItem
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          ref_key: "primitiveElement",
          ref: primitiveElement,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          dir: unref(dir),
          "data-disabled": unref(disabled2) ? "" : void 0,
          onPointerleave: onLeave,
          onFocusout: _cache2[0] || (_cache2[0] = async (event) => {
            const target2 = event.relatedTarget || event.target;
            await nextTick();
            if (highlightedElement.value && unref(currentElement) && !unref(currentElement).contains(target2)) onLeave(event);
          })
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) }), unref(isFormControl) && _ctx.name ? (openBlock(), createBlock(unref(VisuallyHiddenInput_default), {
            key: 0,
            name: _ctx.name,
            value: unref(modelValue),
            disabled: unref(disabled2),
            required: _ctx.required
          }, null, 8, [
            "name",
            "value",
            "disabled",
            "required"
          ])) : createCommentVNode("v-if", true)]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "dir",
          "data-disabled"
        ]);
      };
    }
  });
  var ListboxRoot_default = ListboxRoot_vue_vue_type_script_setup_true_lang_default;
  var ListboxContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ListboxContent",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const { CollectionSlot } = useCollection();
      const rootContext = injectListboxRootContext();
      const isClickFocus = refAutoReset(false, 10);
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(CollectionSlot), null, {
          default: withCtx(() => [createVNode(unref(Primitive), {
            role: "listbox",
            as: _ctx.as,
            "as-child": _ctx.asChild,
            tabindex: unref(rootContext).focusable.value ? unref(rootContext).highlightedElement.value ? "-1" : "0" : "-1",
            "aria-orientation": unref(rootContext).orientation.value,
            "aria-multiselectable": !!unref(rootContext).multiple.value,
            "data-orientation": unref(rootContext).orientation.value,
            onMousedown: _cache2[0] || (_cache2[0] = withModifiers(($event) => isClickFocus.value = true, ["left"])),
            onFocus: _cache2[1] || (_cache2[1] = (ev) => {
              if (unref(isClickFocus)) return;
              unref(rootContext).onEnter(ev);
            }),
            onKeydown: [
              _cache2[2] || (_cache2[2] = withKeys((event) => {
                if (unref(rootContext).orientation.value === "vertical" && (event.key === "ArrowLeft" || event.key === "ArrowRight") || unref(rootContext).orientation.value === "horizontal" && (event.key === "ArrowUp" || event.key === "ArrowDown")) return;
                event.preventDefault();
                unref(rootContext).focusable.value && unref(rootContext).onKeydownNavigation(event);
              }, [
                "down",
                "up",
                "left",
                "right",
                "home",
                "end"
              ])),
              withKeys(unref(rootContext).onKeydownEnter, ["enter"]),
              unref(rootContext).onKeydownTypeAhead
            ]
          }, {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 8, [
            "as",
            "as-child",
            "tabindex",
            "aria-orientation",
            "aria-multiselectable",
            "data-orientation",
            "onKeydown"
          ])]),
          _: 3
        });
      };
    }
  });
  var ListboxContent_default = ListboxContent_vue_vue_type_script_setup_true_lang_default;
  var ListboxFilter_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ListboxFilter",
    props: {
      modelValue: {
        type: String,
        required: false
      },
      autoFocus: {
        type: Boolean,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "input"
      }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const modelValue = useVModel(props, "modelValue", emits, {
        defaultValue: "",
        passive: props.modelValue === void 0
      });
      const rootContext = injectListboxRootContext();
      const { primitiveElement, currentElement } = usePrimitiveElement();
      const disabled2 = computed(() => props.disabled || rootContext.disabled.value || false);
      const activedescendant = ref();
      watchSyncEffect(() => {
        var _a2;
        return activedescendant.value = (_a2 = rootContext.highlightedElement.value) == null ? void 0 : _a2.id;
      });
      onMounted(() => {
        rootContext.focusable.value = false;
        setTimeout(() => {
          var _a2;
          if (props.autoFocus) (_a2 = currentElement.value) == null ? void 0 : _a2.focus();
        }, 1);
      });
      onUnmounted(() => {
        rootContext.focusable.value = true;
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), {
          ref_key: "primitiveElement",
          ref: primitiveElement,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          value: unref(modelValue),
          disabled: disabled2.value ? "" : void 0,
          "data-disabled": disabled2.value ? "" : void 0,
          "aria-disabled": disabled2.value ?? void 0,
          "aria-activedescendant": activedescendant.value,
          type: "text",
          onKeydown: [withKeys(withModifiers(unref(rootContext).onKeydownNavigation, ["prevent"]), [
            "down",
            "up",
            "home",
            "end"
          ]), withKeys(unref(rootContext).onKeydownEnter, ["enter"])],
          onInput: _cache2[0] || (_cache2[0] = (event) => {
            modelValue.value = event.target.value;
            unref(rootContext).highlightFirstItem();
          }),
          onCompositionstart: unref(rootContext).onCompositionStart,
          onCompositionend: unref(rootContext).onCompositionEnd
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })]),
          _: 3
        }, 8, [
          "as",
          "as-child",
          "value",
          "disabled",
          "data-disabled",
          "aria-disabled",
          "aria-activedescendant",
          "onKeydown",
          "onCompositionstart",
          "onCompositionend"
        ]);
      };
    }
  });
  var ListboxFilter_default = ListboxFilter_vue_vue_type_script_setup_true_lang_default;
  const LISTBOX_SELECT = "listbox.select";
  const [injectListboxItemContext, provideListboxItemContext] = createContext("ListboxItem");
  var ListboxItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ListboxItem",
    props: {
      value: {
        type: null,
        required: true
      },
      disabled: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "div"
      }
    },
    emits: ["select"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const id = useId(void 0, "reka-listbox-item");
      const { CollectionItem } = useCollection();
      const { forwardRef, currentElement } = useForwardExpose();
      const rootContext = injectListboxRootContext();
      const isHighlighted = computed(() => currentElement.value === rootContext.highlightedElement.value);
      const isSelected = computed(() => valueComparator(rootContext.modelValue.value, props.value, rootContext.by));
      const disabled2 = computed(() => rootContext.disabled.value || props.disabled);
      async function handleSelect(ev) {
        emits("select", ev);
        if (ev == null ? void 0 : ev.defaultPrevented) return;
        if (!disabled2.value && ev) {
          rootContext.onValueChange(props.value);
          rootContext.changeHighlight(currentElement.value);
        }
      }
      function handleSelectCustomEvent(ev) {
        const eventDetail = {
          originalEvent: ev,
          value: props.value
        };
        handleAndDispatchCustomEvent(LISTBOX_SELECT, handleSelect, eventDetail);
      }
      provideListboxItemContext({ isSelected });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(CollectionItem), { value: _ctx.value }, {
          default: withCtx(() => [withMemo([isHighlighted.value, isSelected.value], () => createVNode(unref(Primitive), mergeProps({ id: unref(id) }, _ctx.$attrs, {
            ref: unref(forwardRef),
            role: "option",
            tabindex: unref(rootContext).focusable.value ? isHighlighted.value ? "0" : "-1" : -1,
            "aria-selected": isSelected.value,
            as: _ctx.as,
            "as-child": _ctx.asChild,
            disabled: disabled2.value ? "" : void 0,
            "data-disabled": disabled2.value ? "" : void 0,
            "data-highlighted": isHighlighted.value ? "" : void 0,
            "data-state": isSelected.value ? "checked" : "unchecked",
            onClick: handleSelectCustomEvent,
            onKeydown: withKeys(withModifiers(handleSelectCustomEvent, ["prevent"]), ["space"]),
            onPointermove: _cache2[0] || (_cache2[0] = () => {
              if (unref(rootContext).highlightedElement.value === unref(currentElement)) return;
              if (unref(rootContext).highlightOnHover.value && !unref(rootContext).focusable.value) unref(rootContext).changeHighlight(unref(currentElement), false);
            })
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16, [
            "id",
            "tabindex",
            "aria-selected",
            "as",
            "as-child",
            "disabled",
            "data-disabled",
            "data-highlighted",
            "data-state",
            "onKeydown"
          ]), _cache2, 1)]),
          _: 3
        }, 8, ["value"]);
      };
    }
  });
  var ListboxItem_default = ListboxItem_vue_vue_type_script_setup_true_lang_default;
  var ListboxItemIndicator_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ListboxItemIndicator",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "span"
      }
    },
    setup(__props) {
      const props = __props;
      useForwardExpose();
      const itemContext = injectListboxItemContext();
      return (_ctx, _cache2) => {
        return unref(itemContext).isSelected.value ? (openBlock(), createBlock(unref(Primitive), mergeProps({
          key: 0,
          "aria-hidden": "true"
        }, props), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16)) : createCommentVNode("v-if", true);
      };
    }
  });
  var ListboxItemIndicator_default = ListboxItemIndicator_vue_vue_type_script_setup_true_lang_default;
  const [injectComboboxRootContext, provideComboboxRootContext] = createContext("ComboboxRoot");
  var ComboboxRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxRoot",
    props: {
      open: {
        type: Boolean,
        required: false,
        default: void 0
      },
      defaultOpen: {
        type: Boolean,
        required: false
      },
      resetSearchTermOnBlur: {
        type: Boolean,
        required: false,
        default: true
      },
      resetSearchTermOnSelect: {
        type: Boolean,
        required: false,
        default: true
      },
      openOnFocus: {
        type: Boolean,
        required: false,
        default: false
      },
      openOnClick: {
        type: Boolean,
        required: false,
        default: false
      },
      ignoreFilter: {
        type: Boolean,
        required: false
      },
      resetModelValueOnClear: {
        type: Boolean,
        required: false,
        default: false
      },
      modelValue: {
        type: null,
        required: false
      },
      defaultValue: {
        type: null,
        required: false
      },
      multiple: {
        type: Boolean,
        required: false
      },
      dir: {
        type: String,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      highlightOnHover: {
        type: Boolean,
        required: false,
        default: true
      },
      by: {
        type: [String, Function],
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      },
      name: {
        type: String,
        required: false
      },
      required: {
        type: Boolean,
        required: false
      }
    },
    emits: [
      "update:modelValue",
      "highlight",
      "update:open"
    ],
    setup(__props, { expose: __expose, emit: __emit }) {
      var _a2, _b2, _c2;
      const props = __props;
      const emits = __emit;
      const { primitiveElement, currentElement: parentElement } = usePrimitiveElement();
      const { multiple, disabled: disabled2, ignoreFilter, resetSearchTermOnSelect, openOnFocus, openOnClick, dir: propDir, resetModelValueOnClear, highlightOnHover } = toRefs(props);
      const dir = useDirection(propDir);
      const modelValue = useVModel(props, "modelValue", emits, {
        defaultValue: props.defaultValue ?? (multiple.value ? [] : void 0),
        passive: props.modelValue === void 0,
        deep: true
      });
      const open = useVModel(props, "open", emits, {
        defaultValue: props.defaultOpen,
        passive: props.open === void 0
      });
      async function onOpenChange(val) {
        var _a3, _b3;
        open.value = val;
        filterSearch.value = "";
        if (val) {
          await nextTick();
          (_a3 = primitiveElement.value) == null ? void 0 : _a3.highlightSelected();
          isUserInputted.value = true;
        } else isUserInputted.value = false;
        (_b3 = inputElement.value) == null ? void 0 : _b3.focus();
        setTimeout(() => {
          if (!val && props.resetSearchTermOnBlur) resetSearchTerm.trigger();
        }, 1);
      }
      const resetSearchTerm = createEventHook();
      const isUserInputted = ref(false);
      const isVirtual = ref(false);
      const inputElement = ref();
      const triggerElement = ref();
      const highlightedElement = computed(() => {
        var _a3;
        return ((_a3 = primitiveElement.value) == null ? void 0 : _a3.highlightedElement) ?? void 0;
      });
      const allItems = ref(/* @__PURE__ */ new Map());
      const allGroups = ref(/* @__PURE__ */ new Map());
      const { contains } = useFilter({ sensitivity: "base" });
      const filterSearch = ref("");
      const filterState = computed((oldValue) => {
        if (!filterSearch.value || props.ignoreFilter || isVirtual.value) return {
          count: allItems.value.size,
          items: (oldValue == null ? void 0 : oldValue.items) ?? /* @__PURE__ */ new Map(),
          groups: (oldValue == null ? void 0 : oldValue.groups) ?? new Set(allGroups.value.keys())
        };
        let itemCount = 0;
        const filteredItems = /* @__PURE__ */ new Map();
        const filteredGroups = /* @__PURE__ */ new Set();
        for (const [id, value] of allItems.value) {
          const score = contains(value, filterSearch.value);
          filteredItems.set(id, score ? 1 : 0);
          if (score) itemCount++;
        }
        for (const [groupId, group] of allGroups.value) for (const itemId of group) if (filteredItems.get(itemId) > 0) {
          filteredGroups.add(groupId);
          break;
        }
        return {
          count: itemCount,
          items: filteredItems,
          groups: filteredGroups
        };
      });
      const inst = getCurrentInstance();
      onMounted(() => {
        var _a3, _b3, _c3;
        if (inst == null ? void 0 : inst.exposed) {
          inst.exposed.highlightItem = (_a3 = primitiveElement.value) == null ? void 0 : _a3.highlightItem;
          inst.exposed.highlightFirstItem = (_b3 = primitiveElement.value) == null ? void 0 : _b3.highlightFirstItem;
          inst.exposed.highlightSelected = (_c3 = primitiveElement.value) == null ? void 0 : _c3.highlightSelected;
        }
      });
      __expose({
        filtered: filterState,
        highlightedElement,
        highlightItem: (_a2 = primitiveElement.value) == null ? void 0 : _a2.highlightItem,
        highlightFirstItem: (_b2 = primitiveElement.value) == null ? void 0 : _b2.highlightFirstItem,
        highlightSelected: (_c2 = primitiveElement.value) == null ? void 0 : _c2.highlightSelected
      });
      provideComboboxRootContext({
        modelValue,
        multiple,
        disabled: disabled2,
        open,
        onOpenChange,
        contentId: "",
        isUserInputted,
        isVirtual,
        inputElement,
        highlightedElement,
        onInputElementChange: (val) => inputElement.value = val,
        triggerElement,
        onTriggerElementChange: (val) => triggerElement.value = val,
        parentElement,
        resetSearchTermOnSelect,
        onResetSearchTerm: resetSearchTerm.on,
        allItems,
        allGroups,
        filterSearch,
        filterState,
        ignoreFilter,
        openOnFocus,
        openOnClick,
        resetModelValueOnClear
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(PopperRoot_default), null, {
          default: withCtx(() => [createVNode(unref(ListboxRoot_default), mergeProps({
            ref_key: "primitiveElement",
            ref: primitiveElement
          }, _ctx.$attrs, {
            modelValue: unref(modelValue),
            "onUpdate:modelValue": _cache2[0] || (_cache2[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
            style: { pointerEvents: unref(open) ? "auto" : void 0 },
            as: _ctx.as,
            "as-child": _ctx.asChild,
            dir: unref(dir),
            multiple: unref(multiple),
            name: _ctx.name,
            required: _ctx.required,
            disabled: unref(disabled2),
            "highlight-on-hover": unref(highlightOnHover),
            by: props.by,
            onHighlight: _cache2[1] || (_cache2[1] = ($event) => emits("highlight", $event))
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
              open: unref(open),
              modelValue: unref(modelValue)
            })]),
            _: 3
          }, 16, [
            "modelValue",
            "style",
            "as",
            "as-child",
            "dir",
            "multiple",
            "name",
            "required",
            "disabled",
            "highlight-on-hover",
            "by"
          ])]),
          _: 3
        });
      };
    }
  });
  var ComboboxRoot_default = ComboboxRoot_vue_vue_type_script_setup_true_lang_default;
  const [injectComboboxContentContext, provideComboboxContentContext] = createContext("ComboboxContent");
  var ComboboxContentImpl_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxContentImpl",
    props: {
      position: {
        type: String,
        required: false,
        default: "inline"
      },
      bodyLock: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { position } = toRefs(props);
      const rootContext = injectComboboxRootContext();
      const { forwardRef, currentElement } = useForwardExpose();
      useBodyScrollLock(props.bodyLock);
      useHideOthers(rootContext.parentElement);
      const pickedProps = computed(() => {
        if (props.position === "popper") return props;
        else return {};
      });
      const forwardedProps = useForwardProps(pickedProps.value);
      const popperStyle = {
        "boxSizing": "border-box",
        "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
        "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
        "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
      };
      provideComboboxContentContext({ position });
      const isInputWithinContent = ref(false);
      onMounted(() => {
        if (rootContext.inputElement.value) {
          isInputWithinContent.value = currentElement.value.contains(rootContext.inputElement.value);
          if (isInputWithinContent.value) rootContext.inputElement.value.focus();
        }
      });
      onUnmounted(() => {
        var _a2;
        if (isInputWithinContent.value) (_a2 = rootContext.triggerElement.value) == null ? void 0 : _a2.focus();
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(ListboxContent_default), { "as-child": "" }, {
          default: withCtx(() => [createVNode(unref(DismissableLayer_default), {
            "as-child": "",
            "disable-outside-pointer-events": _ctx.disableOutsidePointerEvents,
            onDismiss: _cache2[0] || (_cache2[0] = ($event) => unref(rootContext).onOpenChange(false)),
            onFocusOutside: _cache2[1] || (_cache2[1] = (ev) => {
              var _a2;
              if ((_a2 = unref(rootContext).parentElement.value) == null ? void 0 : _a2.contains(ev.target)) ev.preventDefault();
              emits("focusOutside", ev);
            }),
            onInteractOutside: _cache2[2] || (_cache2[2] = ($event) => emits("interactOutside", $event)),
            onEscapeKeyDown: _cache2[3] || (_cache2[3] = ($event) => emits("escapeKeyDown", $event)),
            onPointerDownOutside: _cache2[4] || (_cache2[4] = (ev) => {
              var _a2;
              if ((_a2 = unref(rootContext).parentElement.value) == null ? void 0 : _a2.contains(ev.target)) ev.preventDefault();
              emits("pointerDownOutside", ev);
            })
          }, {
            default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(position) === "popper" ? unref(PopperContent_default) : unref(Primitive)), mergeProps({
              ..._ctx.$attrs,
              ...unref(forwardedProps)
            }, {
              id: unref(rootContext).contentId,
              ref: unref(forwardRef),
              "data-state": unref(rootContext).open.value ? "open" : "closed",
              style: {
                display: "flex",
                flexDirection: "column",
                outline: "none",
                ...unref(position) === "popper" ? popperStyle : {}
              }
            }), {
              default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
              _: 3
            }, 16, [
              "id",
              "data-state",
              "style"
            ]))]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])]),
          _: 3
        });
      };
    }
  });
  var ComboboxContentImpl_default = ComboboxContentImpl_vue_vue_type_script_setup_true_lang_default;
  var ComboboxContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxContent",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      position: {
        type: String,
        required: false
      },
      bodyLock: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const forwarded = useForwardPropsEmits(props, emits);
      const { forwardRef } = useForwardExpose();
      const rootContext = injectComboboxRootContext();
      rootContext.contentId || (rootContext.contentId = useId(void 0, "reka-combobox-content"));
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || unref(rootContext).open.value }, {
          default: withCtx(() => [createVNode(ComboboxContentImpl_default, mergeProps({
            ...unref(forwarded),
            ..._ctx.$attrs
          }, { ref: unref(forwardRef) }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16)]),
          _: 3
        }, 8, ["present"]);
      };
    }
  });
  var ComboboxContent_default = ComboboxContent_vue_vue_type_script_setup_true_lang_default;
  var ComboboxEmpty_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxEmpty",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      const rootContext = injectComboboxRootContext();
      const isRender = computed(() => rootContext.ignoreFilter.value ? rootContext.allItems.value.size === 0 : rootContext.filterState.value.count === 0);
      return (_ctx, _cache2) => {
        return isRender.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, props)), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [_cache2[0] || (_cache2[0] = createTextVNode("No options"))])]),
          _: 3
        }, 16)) : createCommentVNode("v-if", true);
      };
    }
  });
  var ComboboxEmpty_default = ComboboxEmpty_vue_vue_type_script_setup_true_lang_default;
  const [injectComboboxGroupContext, provideComboboxGroupContext] = createContext("ComboboxGroup");
  var ComboboxInput_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxInput",
    props: {
      displayValue: {
        type: Function,
        required: false
      },
      modelValue: {
        type: String,
        required: false
      },
      autoFocus: {
        type: Boolean,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "input"
      }
    },
    emits: ["update:modelValue"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const rootContext = injectComboboxRootContext();
      const listboxContext = injectListboxRootContext();
      const { primitiveElement, currentElement } = usePrimitiveElement();
      const modelValue = useVModel(props, "modelValue", emits, { passive: props.modelValue === void 0 });
      onMounted(() => {
        if (currentElement.value) rootContext.onInputElementChange(currentElement.value);
      });
      function handleKeyDown(ev) {
        if (!rootContext.open.value) rootContext.onOpenChange(true);
      }
      function handleInput(event) {
        const target2 = event.target;
        if (!rootContext.open.value) {
          rootContext.onOpenChange(true);
          nextTick(() => {
            if (target2.value) {
              rootContext.filterSearch.value = target2.value;
              listboxContext.highlightFirstItem();
            }
          });
        } else rootContext.filterSearch.value = target2.value;
      }
      function handleFocus() {
        if (rootContext.openOnFocus.value && !rootContext.open.value) rootContext.onOpenChange(true);
      }
      function handleClick() {
        if (rootContext.openOnClick.value && !rootContext.open.value) rootContext.onOpenChange(true);
      }
      function resetSearchTerm() {
        const rootModelValue = rootContext.modelValue.value;
        if (props.displayValue) modelValue.value = props.displayValue(rootModelValue);
        else if (!rootContext.multiple.value && rootModelValue && !Array.isArray(rootModelValue)) if (typeof rootModelValue !== "object") modelValue.value = rootModelValue.toString();
        else modelValue.value = "";
        else modelValue.value = "";
        nextTick(() => {
          modelValue.value = modelValue.value;
        });
      }
      rootContext.onResetSearchTerm(() => {
        resetSearchTerm();
      });
      watch(rootContext.modelValue, async () => {
        if (!rootContext.isUserInputted.value && rootContext.resetSearchTermOnSelect.value) resetSearchTerm();
      }, {
        immediate: true,
        deep: true
      });
      watch(rootContext.filterState, () => {
        if (!rootContext.isVirtual.value && !rootContext.highlightedElement.value) listboxContext.highlightFirstItem();
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(ListboxFilter_default), {
          ref_key: "primitiveElement",
          ref: primitiveElement,
          modelValue: unref(modelValue),
          "onUpdate:modelValue": _cache2[0] || (_cache2[0] = ($event) => isRef(modelValue) ? modelValue.value = $event : null),
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "auto-focus": _ctx.autoFocus,
          disabled: _ctx.disabled,
          "aria-expanded": unref(rootContext).open.value,
          "aria-controls": unref(rootContext).contentId,
          "aria-autocomplete": "list",
          role: "combobox",
          autocomplete: "off",
          onClick: handleClick,
          onInput: handleInput,
          onKeydown: withKeys(withModifiers(handleKeyDown, ["prevent"]), ["down", "up"]),
          onFocus: handleFocus
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, [
          "modelValue",
          "as",
          "as-child",
          "auto-focus",
          "disabled",
          "aria-expanded",
          "aria-controls",
          "onKeydown"
        ]);
      };
    }
  });
  var ComboboxInput_default = ComboboxInput_vue_vue_type_script_setup_true_lang_default;
  var ComboboxItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxItem",
    props: {
      textValue: {
        type: String,
        required: false
      },
      value: {
        type: null,
        required: true
      },
      disabled: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: ["select"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const id = useId(void 0, "reka-combobox-item");
      const rootContext = injectComboboxRootContext();
      const groupContext = injectComboboxGroupContext(null);
      const { primitiveElement, currentElement } = usePrimitiveElement();
      if (props.value === "") throw new Error("A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.");
      const isRender = computed(() => {
        if (rootContext.isVirtual.value || rootContext.ignoreFilter.value || !rootContext.filterSearch.value) return true;
        else {
          const filteredCurrentItem = rootContext.filterState.value.items.get(id);
          if (filteredCurrentItem === void 0) return true;
          return filteredCurrentItem > 0;
        }
      });
      onMounted(() => {
        var _a2;
        rootContext.allItems.value.set(id, props.textValue || currentElement.value.textContent || currentElement.value.innerText);
        const groupId = groupContext == null ? void 0 : groupContext.id;
        if (groupId) if (!rootContext.allGroups.value.has(groupId)) rootContext.allGroups.value.set(groupId, /* @__PURE__ */ new Set([id]));
        else (_a2 = rootContext.allGroups.value.get(groupId)) == null ? void 0 : _a2.add(id);
      });
      onUnmounted(() => {
        rootContext.allItems.value.delete(id);
      });
      return (_ctx, _cache2) => {
        return isRender.value ? (openBlock(), createBlock(unref(ListboxItem_default), mergeProps({ key: 0 }, props, {
          id: unref(id),
          ref_key: "primitiveElement",
          ref: primitiveElement,
          disabled: unref(rootContext).disabled.value || _ctx.disabled,
          onSelect: _cache2[0] || (_cache2[0] = (event) => {
            emits("select", event);
            if (event.defaultPrevented) return;
            if (!unref(rootContext).multiple.value && !_ctx.disabled && !unref(rootContext).disabled.value) {
              event.preventDefault();
              unref(rootContext).onOpenChange(false);
              unref(rootContext).modelValue.value = props.value;
            }
          })
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(toDisplayString(_ctx.value), 1)])]),
          _: 3
        }, 16, ["id", "disabled"])) : createCommentVNode("v-if", true);
      };
    }
  });
  var ComboboxItem_default = ComboboxItem_vue_vue_type_script_setup_true_lang_default;
  var ComboboxItemIndicator_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxItemIndicator",
    props: {
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "span"
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(ListboxItemIndicator_default), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var ComboboxItemIndicator_default = ComboboxItemIndicator_vue_vue_type_script_setup_true_lang_default;
  var ComboboxTrigger_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxTrigger",
    props: {
      disabled: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "button"
      }
    },
    setup(__props) {
      const props = __props;
      const { forwardRef, currentElement } = useForwardExpose();
      const rootContext = injectComboboxRootContext();
      const disabled2 = computed(() => props.disabled || rootContext.disabled.value || false);
      onMounted(() => {
        if (currentElement.value) rootContext.onTriggerElementChange(currentElement.value);
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
          ref: unref(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0,
          tabindex: "-1",
          "aria-label": "Show popup",
          "aria-haspopup": "listbox",
          "aria-expanded": unref(rootContext).open.value,
          "aria-controls": unref(rootContext).contentId,
          "data-state": unref(rootContext).open.value ? "open" : "closed",
          disabled: disabled2.value,
          "data-disabled": disabled2.value ? "" : void 0,
          "aria-disabled": disabled2.value ?? void 0,
          onClick: _cache2[0] || (_cache2[0] = ($event) => unref(rootContext).onOpenChange(!unref(rootContext).open.value))
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, [
          "type",
          "aria-expanded",
          "aria-controls",
          "data-state",
          "disabled",
          "data-disabled",
          "aria-disabled"
        ]);
      };
    }
  });
  var ComboboxTrigger_default = ComboboxTrigger_vue_vue_type_script_setup_true_lang_default;
  function useNonce(nonce) {
    const context2 = injectConfigProviderContext({ nonce: ref() });
    return computed(() => {
      var _a2;
      return (nonce == null ? void 0 : nonce.value) || ((_a2 = context2.nonce) == null ? void 0 : _a2.value);
    });
  }
  var ComboboxViewport_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "ComboboxViewport",
    props: {
      nonce: {
        type: String,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      const { forwardRef } = useForwardExpose();
      const { nonce: propNonce } = toRefs(props);
      const nonce = useNonce(propNonce);
      const rootContext = injectComboboxRootContext();
      return (_ctx, _cache2) => {
        return openBlock(), createElementBlock(Fragment, null, [createVNode(unref(Primitive), mergeProps({
          ..._ctx.$attrs,
          ...props
        }, {
          ref: unref(forwardRef),
          "data-reka-combobox-viewport": "",
          role: "presentation",
          style: {
            position: "relative",
            flex: unref(rootContext).isVirtual.value ? void 0 : 1,
            overflow: "auto"
          }
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["style"]), createVNode(unref(Primitive), {
          as: "style",
          nonce: unref(nonce)
        }, {
          default: withCtx(() => _cache2[0] || (_cache2[0] = [createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")])),
          _: 1,
          __: [0]
        }, 8, ["nonce"])], 64);
      };
    }
  });
  var ComboboxViewport_default = ComboboxViewport_vue_vue_type_script_setup_true_lang_default;
  var MenuAnchor_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuAnchor",
    props: {
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(PopperAnchor_default), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var MenuAnchor_default = MenuAnchor_vue_vue_type_script_setup_true_lang_default;
  function useIsUsingKeyboardImpl() {
    const isUsingKeyboard = ref(false);
    onMounted(() => {
      useEventListener$1("keydown", () => {
        isUsingKeyboard.value = true;
      }, {
        capture: true,
        passive: true
      });
      useEventListener$1(["pointerdown", "pointermove"], () => {
        isUsingKeyboard.value = false;
      }, {
        capture: true,
        passive: true
      });
    });
    return isUsingKeyboard;
  }
  const useIsUsingKeyboard = createSharedComposable(useIsUsingKeyboardImpl);
  const [injectMenuContext, provideMenuContext] = createContext(["MenuRoot", "MenuSub"], "MenuContext");
  const [injectMenuRootContext, provideMenuRootContext] = createContext("MenuRoot");
  var MenuRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuRoot",
    props: {
      open: {
        type: Boolean,
        required: false,
        default: false
      },
      dir: {
        type: String,
        required: false
      },
      modal: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    emits: ["update:open"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { modal, dir: propDir } = toRefs(props);
      const dir = useDirection(propDir);
      const open = useVModel(props, "open", emits);
      const content = ref();
      const isUsingKeyboardRef = useIsUsingKeyboard();
      provideMenuContext({
        open,
        onOpenChange: (value) => {
          open.value = value;
        },
        content,
        onContentChange: (element) => {
          content.value = element;
        }
      });
      provideMenuRootContext({
        onClose: () => {
          open.value = false;
        },
        isUsingKeyboardRef,
        dir,
        modal
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(PopperRoot_default), null, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        });
      };
    }
  });
  var MenuRoot_default = MenuRoot_vue_vue_type_script_setup_true_lang_default;
  const [injectMenuContentContext, provideMenuContentContext] = createContext("MenuContent");
  var MenuContentImpl_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuContentImpl",
    props: /* @__PURE__ */ mergeDefaults({
      loop: {
        type: Boolean,
        required: false
      },
      disableOutsidePointerEvents: {
        type: Boolean,
        required: false
      },
      disableOutsideScroll: {
        type: Boolean,
        required: false
      },
      trapFocus: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    }, { ...PopperContentPropsDefaultValue }),
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "entryFocus",
      "openAutoFocus",
      "closeAutoFocus",
      "dismiss"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const menuContext = injectMenuContext();
      const rootContext = injectMenuRootContext();
      const { trapFocus, disableOutsidePointerEvents, loop } = toRefs(props);
      useFocusGuards();
      useBodyScrollLock(disableOutsidePointerEvents.value);
      const searchRef = ref("");
      const timerRef = ref(0);
      const pointerGraceTimerRef = ref(0);
      const pointerGraceIntentRef = ref(null);
      const pointerDirRef = ref("right");
      const lastPointerXRef = ref(0);
      const currentItemId = ref(null);
      const rovingFocusGroupRef = ref();
      const { forwardRef, currentElement: contentElement } = useForwardExpose();
      const { handleTypeaheadSearch } = useTypeahead();
      watch(contentElement, (el) => {
        menuContext.onContentChange(el);
      });
      onUnmounted(() => {
        window.clearTimeout(timerRef.value);
      });
      function isPointerMovingToSubmenu(event) {
        var _a2, _b2;
        const isMovingTowards = pointerDirRef.value === ((_a2 = pointerGraceIntentRef.value) == null ? void 0 : _a2.side);
        return isMovingTowards && isPointerInGraceArea(event, (_b2 = pointerGraceIntentRef.value) == null ? void 0 : _b2.area);
      }
      async function handleMountAutoFocus(event) {
        var _a2;
        emits("openAutoFocus", event);
        if (event.defaultPrevented) return;
        event.preventDefault();
        (_a2 = contentElement.value) == null ? void 0 : _a2.focus({ preventScroll: true });
      }
      function handleKeyDown(event) {
        var _a2;
        if (event.defaultPrevented) return;
        const target2 = event.target;
        const isKeyDownInside = target2.closest("[data-reka-menu-content]") === event.currentTarget;
        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
        const isCharacterKey = event.key.length === 1;
        const el = useArrowNavigation(event, getActiveElement(), contentElement.value, {
          loop: loop.value,
          arrowKeyOptions: "vertical",
          dir: rootContext == null ? void 0 : rootContext.dir.value,
          focus: true,
          attributeName: "[data-reka-collection-item]:not([data-disabled])"
        });
        if (el) return el == null ? void 0 : el.focus();
        if (event.code === "Space") return;
        const collectionItems = ((_a2 = rovingFocusGroupRef.value) == null ? void 0 : _a2.getItems()) ?? [];
        if (isKeyDownInside) {
          if (event.key === "Tab") event.preventDefault();
          if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key, collectionItems);
        }
        if (event.target !== contentElement.value) return;
        if (!FIRST_LAST_KEYS.includes(event.key)) return;
        event.preventDefault();
        const candidateNodes = [...collectionItems.map((item) => item.ref)];
        if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
        focusFirst$1(candidateNodes);
      }
      function handleBlur(event) {
        var _a2, _b2;
        if (!((_b2 = (_a2 = event == null ? void 0 : event.currentTarget) == null ? void 0 : _a2.contains) == null ? void 0 : _b2.call(_a2, event.target))) {
          window.clearTimeout(timerRef.value);
          searchRef.value = "";
        }
      }
      function handlePointerMove(event) {
        var _a2;
        if (!isMouseEvent(event)) return;
        const target2 = event.target;
        const pointerXHasChanged = lastPointerXRef.value !== event.clientX;
        if (((_a2 = event == null ? void 0 : event.currentTarget) == null ? void 0 : _a2.contains(target2)) && pointerXHasChanged) {
          const newDir = event.clientX > lastPointerXRef.value ? "right" : "left";
          pointerDirRef.value = newDir;
          lastPointerXRef.value = event.clientX;
        }
      }
      provideMenuContentContext({
        onItemEnter: (event) => {
          if (isPointerMovingToSubmenu(event)) return true;
          else return false;
        },
        onItemLeave: (event) => {
          var _a2;
          if (isPointerMovingToSubmenu(event)) return;
          (_a2 = contentElement.value) == null ? void 0 : _a2.focus();
          currentItemId.value = null;
        },
        onTriggerLeave: (event) => {
          if (isPointerMovingToSubmenu(event)) return true;
          else return false;
        },
        searchRef,
        pointerGraceTimerRef,
        onPointerGraceIntentChange: (intent) => {
          pointerGraceIntentRef.value = intent;
        }
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(FocusScope_default), {
          "as-child": "",
          trapped: unref(trapFocus),
          onMountAutoFocus: handleMountAutoFocus,
          onUnmountAutoFocus: _cache2[7] || (_cache2[7] = ($event) => emits("closeAutoFocus", $event))
        }, {
          default: withCtx(() => [createVNode(unref(DismissableLayer_default), {
            "as-child": "",
            "disable-outside-pointer-events": unref(disableOutsidePointerEvents),
            onEscapeKeyDown: _cache2[2] || (_cache2[2] = ($event) => emits("escapeKeyDown", $event)),
            onPointerDownOutside: _cache2[3] || (_cache2[3] = ($event) => emits("pointerDownOutside", $event)),
            onFocusOutside: _cache2[4] || (_cache2[4] = ($event) => emits("focusOutside", $event)),
            onInteractOutside: _cache2[5] || (_cache2[5] = ($event) => emits("interactOutside", $event)),
            onDismiss: _cache2[6] || (_cache2[6] = ($event) => emits("dismiss"))
          }, {
            default: withCtx(() => [createVNode(unref(RovingFocusGroup_default), {
              ref_key: "rovingFocusGroupRef",
              ref: rovingFocusGroupRef,
              "current-tab-stop-id": currentItemId.value,
              "onUpdate:currentTabStopId": _cache2[0] || (_cache2[0] = ($event) => currentItemId.value = $event),
              "as-child": "",
              orientation: "vertical",
              dir: unref(rootContext).dir.value,
              loop: unref(loop),
              onEntryFocus: _cache2[1] || (_cache2[1] = (event) => {
                emits("entryFocus", event);
                if (!unref(rootContext).isUsingKeyboardRef.value) event.preventDefault();
              })
            }, {
              default: withCtx(() => [createVNode(unref(PopperContent_default), {
                ref: unref(forwardRef),
                role: "menu",
                as: _ctx.as,
                "as-child": _ctx.asChild,
                "aria-orientation": "vertical",
                "data-reka-menu-content": "",
                "data-state": unref(getOpenState)(unref(menuContext).open.value),
                dir: unref(rootContext).dir.value,
                side: _ctx.side,
                "side-offset": _ctx.sideOffset,
                align: _ctx.align,
                "align-offset": _ctx.alignOffset,
                "avoid-collisions": _ctx.avoidCollisions,
                "collision-boundary": _ctx.collisionBoundary,
                "collision-padding": _ctx.collisionPadding,
                "arrow-padding": _ctx.arrowPadding,
                "prioritize-position": _ctx.prioritizePosition,
                "position-strategy": _ctx.positionStrategy,
                "update-position-strategy": _ctx.updatePositionStrategy,
                sticky: _ctx.sticky,
                "hide-when-detached": _ctx.hideWhenDetached,
                reference: _ctx.reference,
                onKeydown: handleKeyDown,
                onBlur: handleBlur,
                onPointermove: handlePointerMove
              }, {
                default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
                _: 3
              }, 8, [
                "as",
                "as-child",
                "data-state",
                "dir",
                "side",
                "side-offset",
                "align",
                "align-offset",
                "avoid-collisions",
                "collision-boundary",
                "collision-padding",
                "arrow-padding",
                "prioritize-position",
                "position-strategy",
                "update-position-strategy",
                "sticky",
                "hide-when-detached",
                "reference"
              ])]),
              _: 3
            }, 8, [
              "current-tab-stop-id",
              "dir",
              "loop"
            ])]),
            _: 3
          }, 8, ["disable-outside-pointer-events"])]),
          _: 3
        }, 8, ["trapped"]);
      };
    }
  });
  var MenuContentImpl_default = MenuContentImpl_vue_vue_type_script_setup_true_lang_default;
  var MenuItemImpl_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    inheritAttrs: false,
    __name: "MenuItemImpl",
    props: {
      disabled: {
        type: Boolean,
        required: false
      },
      textValue: {
        type: String,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      const contentContext = injectMenuContentContext();
      const { forwardRef } = useForwardExpose();
      const { CollectionItem } = useCollection();
      const isFocused = ref(false);
      async function handlePointerMove(event) {
        if (event.defaultPrevented) return;
        if (!isMouseEvent(event)) return;
        if (props.disabled) contentContext.onItemLeave(event);
        else {
          const defaultPrevented = contentContext.onItemEnter(event);
          if (!defaultPrevented) {
            const item = event.currentTarget;
            item == null ? void 0 : item.focus({ preventScroll: true });
          }
        }
      }
      async function handlePointerLeave(event) {
        await nextTick();
        if (event.defaultPrevented) return;
        if (!isMouseEvent(event)) return;
        contentContext.onItemLeave(event);
      }
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(CollectionItem), { value: { textValue: _ctx.textValue } }, {
          default: withCtx(() => [createVNode(unref(Primitive), mergeProps({
            ref: unref(forwardRef),
            role: "menuitem",
            tabindex: "-1"
          }, _ctx.$attrs, {
            as: _ctx.as,
            "as-child": _ctx.asChild,
            "aria-disabled": _ctx.disabled || void 0,
            "data-disabled": _ctx.disabled ? "" : void 0,
            "data-highlighted": isFocused.value ? "" : void 0,
            onPointermove: handlePointerMove,
            onPointerleave: handlePointerLeave,
            onFocus: _cache2[0] || (_cache2[0] = async (event) => {
              await nextTick();
              if (event.defaultPrevented || _ctx.disabled) return;
              isFocused.value = true;
            }),
            onBlur: _cache2[1] || (_cache2[1] = async (event) => {
              await nextTick();
              if (event.defaultPrevented) return;
              isFocused.value = false;
            })
          }), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16, [
            "as",
            "as-child",
            "aria-disabled",
            "data-disabled",
            "data-highlighted"
          ])]),
          _: 3
        }, 8, ["value"]);
      };
    }
  });
  var MenuItemImpl_default = MenuItemImpl_vue_vue_type_script_setup_true_lang_default;
  var MenuItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuItem",
    props: {
      disabled: {
        type: Boolean,
        required: false
      },
      textValue: {
        type: String,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: ["select"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const { forwardRef, currentElement } = useForwardExpose();
      const rootContext = injectMenuRootContext();
      const contentContext = injectMenuContentContext();
      const isPointerDownRef = ref(false);
      async function handleSelect() {
        const menuItem = currentElement.value;
        if (!props.disabled && menuItem) {
          const itemSelectEvent = new CustomEvent(ITEM_SELECT, {
            bubbles: true,
            cancelable: true
          });
          emits("select", itemSelectEvent);
          await nextTick();
          if (itemSelectEvent.defaultPrevented) isPointerDownRef.value = false;
          else rootContext.onClose();
        }
      }
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(MenuItemImpl_default, mergeProps(props, {
          ref: unref(forwardRef),
          onClick: handleSelect,
          onPointerdown: _cache2[0] || (_cache2[0] = () => {
            isPointerDownRef.value = true;
          }),
          onPointerup: _cache2[1] || (_cache2[1] = async (event) => {
            var _a2;
            await nextTick();
            if (event.defaultPrevented) return;
            if (!isPointerDownRef.value) (_a2 = event.currentTarget) == null ? void 0 : _a2.click();
          }),
          onKeydown: _cache2[2] || (_cache2[2] = async (event) => {
            const isTypingAhead = unref(contentContext).searchRef.value !== "";
            if (_ctx.disabled || isTypingAhead && event.key === " ") return;
            if (unref(SELECTION_KEYS).includes(event.key)) {
              event.currentTarget.click();
              event.preventDefault();
            }
          })
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var MenuItem_default = MenuItem_vue_vue_type_script_setup_true_lang_default;
  var MenuRootContentModal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuRootContentModal",
    props: {
      loop: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "entryFocus",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const forwarded = useForwardPropsEmits(props, emits);
      const menuContext = injectMenuContext();
      const { forwardRef, currentElement } = useForwardExpose();
      useHideOthers(currentElement);
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(MenuContentImpl_default, mergeProps(unref(forwarded), {
          ref: unref(forwardRef),
          "trap-focus": unref(menuContext).open.value,
          "disable-outside-pointer-events": unref(menuContext).open.value,
          "disable-outside-scroll": true,
          onDismiss: _cache2[0] || (_cache2[0] = ($event) => unref(menuContext).onOpenChange(false)),
          onFocusOutside: _cache2[1] || (_cache2[1] = withModifiers(($event) => emits("focusOutside", $event), ["prevent"]))
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["trap-focus", "disable-outside-pointer-events"]);
      };
    }
  });
  var MenuRootContentModal_default = MenuRootContentModal_vue_vue_type_script_setup_true_lang_default;
  var MenuRootContentNonModal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuRootContentNonModal",
    props: {
      loop: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "entryFocus",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const forwarded = useForwardPropsEmits(props, emits);
      const menuContext = injectMenuContext();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(MenuContentImpl_default, mergeProps(unref(forwarded), {
          "trap-focus": false,
          "disable-outside-pointer-events": false,
          "disable-outside-scroll": false,
          onDismiss: _cache2[0] || (_cache2[0] = ($event) => unref(menuContext).onOpenChange(false))
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var MenuRootContentNonModal_default = MenuRootContentNonModal_vue_vue_type_script_setup_true_lang_default;
  var MenuContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuContent",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      loop: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "entryFocus",
      "openAutoFocus",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const forwarded = useForwardPropsEmits(props, emits);
      const menuContext = injectMenuContext();
      const rootContext = injectMenuRootContext();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || unref(menuContext).open.value }, {
          default: withCtx(() => [unref(rootContext).modal.value ? (openBlock(), createBlock(MenuRootContentModal_default, normalizeProps(mergeProps({ key: 0 }, {
            ..._ctx.$attrs,
            ...unref(forwarded)
          })), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16)) : (openBlock(), createBlock(MenuRootContentNonModal_default, normalizeProps(mergeProps({ key: 1 }, {
            ..._ctx.$attrs,
            ...unref(forwarded)
          })), {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 16))]),
          _: 3
        }, 8, ["present"]);
      };
    }
  });
  var MenuContent_default = MenuContent_vue_vue_type_script_setup_true_lang_default;
  var MenuPortal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "MenuPortal",
    props: {
      to: {
        type: null,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      defer: {
        type: Boolean,
        required: false
      },
      forceMount: {
        type: Boolean,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(Teleport_default), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var MenuPortal_default = MenuPortal_vue_vue_type_script_setup_true_lang_default;
  const [injectDropdownMenuRootContext, provideDropdownMenuRootContext] = createContext("DropdownMenuRoot");
  var DropdownMenuRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DropdownMenuRoot",
    props: {
      defaultOpen: {
        type: Boolean,
        required: false
      },
      open: {
        type: Boolean,
        required: false,
        default: void 0
      },
      dir: {
        type: String,
        required: false
      },
      modal: {
        type: Boolean,
        required: false,
        default: true
      }
    },
    emits: ["update:open"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emit2 = __emit;
      useForwardExpose();
      const open = useVModel(props, "open", emit2, {
        defaultValue: props.defaultOpen,
        passive: props.open === void 0
      });
      const triggerElement = ref();
      const { modal, dir: propDir } = toRefs(props);
      const dir = useDirection(propDir);
      provideDropdownMenuRootContext({
        open,
        onOpenChange: (value) => {
          open.value = value;
        },
        onOpenToggle: () => {
          open.value = !open.value;
        },
        triggerId: "",
        triggerElement,
        contentId: "",
        modal,
        dir
      });
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(MenuRoot_default), {
          open: unref(open),
          "onUpdate:open": _cache2[0] || (_cache2[0] = ($event) => isRef(open) ? open.value = $event : null),
          dir: unref(dir),
          modal: unref(modal)
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default", { open: unref(open) })]),
          _: 3
        }, 8, [
          "open",
          "dir",
          "modal"
        ]);
      };
    }
  });
  var DropdownMenuRoot_default = DropdownMenuRoot_vue_vue_type_script_setup_true_lang_default;
  var DropdownMenuContent_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DropdownMenuContent",
    props: {
      forceMount: {
        type: Boolean,
        required: false
      },
      loop: {
        type: Boolean,
        required: false
      },
      side: {
        type: null,
        required: false
      },
      sideOffset: {
        type: Number,
        required: false
      },
      sideFlip: {
        type: Boolean,
        required: false
      },
      align: {
        type: null,
        required: false
      },
      alignOffset: {
        type: Number,
        required: false
      },
      alignFlip: {
        type: Boolean,
        required: false
      },
      avoidCollisions: {
        type: Boolean,
        required: false
      },
      collisionBoundary: {
        type: null,
        required: false
      },
      collisionPadding: {
        type: [Number, Object],
        required: false
      },
      arrowPadding: {
        type: Number,
        required: false
      },
      sticky: {
        type: String,
        required: false
      },
      hideWhenDetached: {
        type: Boolean,
        required: false
      },
      positionStrategy: {
        type: String,
        required: false
      },
      updatePositionStrategy: {
        type: String,
        required: false
      },
      disableUpdateOnLayoutShift: {
        type: Boolean,
        required: false
      },
      prioritizePosition: {
        type: Boolean,
        required: false
      },
      reference: {
        type: null,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: [
      "escapeKeyDown",
      "pointerDownOutside",
      "focusOutside",
      "interactOutside",
      "closeAutoFocus"
    ],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const forwarded = useForwardPropsEmits(props, emits);
      useForwardExpose();
      const rootContext = injectDropdownMenuRootContext();
      const hasInteractedOutsideRef = ref(false);
      function handleCloseAutoFocus(event) {
        if (event.defaultPrevented) return;
        if (!hasInteractedOutsideRef.value) setTimeout(() => {
          var _a2;
          (_a2 = rootContext.triggerElement.value) == null ? void 0 : _a2.focus();
        }, 0);
        hasInteractedOutsideRef.value = false;
        event.preventDefault();
      }
      rootContext.contentId || (rootContext.contentId = useId(void 0, "reka-dropdown-menu-content"));
      return (_ctx, _cache2) => {
        var _a2;
        return openBlock(), createBlock(unref(MenuContent_default), mergeProps(unref(forwarded), {
          id: unref(rootContext).contentId,
          "aria-labelledby": (_a2 = unref(rootContext)) == null ? void 0 : _a2.triggerId,
          style: {
            "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
            "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
            "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
            "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
            "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
          },
          onCloseAutoFocus: handleCloseAutoFocus,
          onInteractOutside: _cache2[0] || (_cache2[0] = (event) => {
            var _a3;
            if (event.defaultPrevented) return;
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            if (!unref(rootContext).modal.value || isRightClick) hasInteractedOutsideRef.value = true;
            if ((_a3 = unref(rootContext).triggerElement.value) == null ? void 0 : _a3.contains(event.target)) event.preventDefault();
          })
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["id", "aria-labelledby"]);
      };
    }
  });
  var DropdownMenuContent_default = DropdownMenuContent_vue_vue_type_script_setup_true_lang_default;
  var DropdownMenuItem_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DropdownMenuItem",
    props: {
      disabled: {
        type: Boolean,
        required: false
      },
      textValue: {
        type: String,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false
      }
    },
    emits: ["select"],
    setup(__props, { emit: __emit }) {
      const props = __props;
      const emits = __emit;
      const emitsAsProps = useEmitAsProps(emits);
      useForwardExpose();
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(MenuItem_default), normalizeProps(guardReactiveProps({
          ...props,
          ...unref(emitsAsProps)
        })), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var DropdownMenuItem_default = DropdownMenuItem_vue_vue_type_script_setup_true_lang_default;
  var DropdownMenuPortal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DropdownMenuPortal",
    props: {
      to: {
        type: null,
        required: false
      },
      disabled: {
        type: Boolean,
        required: false
      },
      defer: {
        type: Boolean,
        required: false
      },
      forceMount: {
        type: Boolean,
        required: false
      }
    },
    setup(__props) {
      const props = __props;
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(MenuPortal_default), normalizeProps(guardReactiveProps(props)), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16);
      };
    }
  });
  var DropdownMenuPortal_default = DropdownMenuPortal_vue_vue_type_script_setup_true_lang_default;
  var DropdownMenuTrigger_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
    __name: "DropdownMenuTrigger",
    props: {
      disabled: {
        type: Boolean,
        required: false
      },
      asChild: {
        type: Boolean,
        required: false
      },
      as: {
        type: null,
        required: false,
        default: "button"
      }
    },
    setup(__props) {
      const props = __props;
      const rootContext = injectDropdownMenuRootContext();
      const { forwardRef, currentElement: triggerElement } = useForwardExpose();
      onMounted(() => {
        rootContext.triggerElement = triggerElement;
      });
      rootContext.triggerId || (rootContext.triggerId = useId(void 0, "reka-dropdown-menu-trigger"));
      return (_ctx, _cache2) => {
        return openBlock(), createBlock(unref(MenuAnchor_default), { "as-child": "" }, {
          default: withCtx(() => [createVNode(unref(Primitive), {
            id: unref(rootContext).triggerId,
            ref: unref(forwardRef),
            type: _ctx.as === "button" ? "button" : void 0,
            "as-child": props.asChild,
            as: _ctx.as,
            "aria-haspopup": "menu",
            "aria-expanded": unref(rootContext).open.value,
            "aria-controls": unref(rootContext).open.value ? unref(rootContext).contentId : void 0,
            "data-disabled": _ctx.disabled ? "" : void 0,
            disabled: _ctx.disabled,
            "data-state": unref(rootContext).open.value ? "open" : "closed",
            onClick: _cache2[0] || (_cache2[0] = async (event) => {
              var _a2;
              if (!_ctx.disabled && event.button === 0 && event.ctrlKey === false) {
                (_a2 = unref(rootContext)) == null ? void 0 : _a2.onOpenToggle();
                await nextTick();
                if (unref(rootContext).open.value) event.preventDefault();
              }
            }),
            onKeydown: _cache2[1] || (_cache2[1] = withKeys((event) => {
              if (_ctx.disabled) return;
              if (["Enter", " "].includes(event.key)) unref(rootContext).onOpenToggle();
              if (event.key === "ArrowDown") unref(rootContext).onOpenChange(true);
              if ([
                "Enter",
                " ",
                "ArrowDown"
              ].includes(event.key)) event.preventDefault();
            }, [
              "enter",
              "space",
              "arrow-down"
            ]))
          }, {
            default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
            _: 3
          }, 8, [
            "id",
            "type",
            "as-child",
            "as",
            "aria-expanded",
            "aria-controls",
            "data-disabled",
            "disabled",
            "data-state"
          ])]),
          _: 3
        });
      };
    }
  });
  var DropdownMenuTrigger_default = DropdownMenuTrigger_vue_vue_type_script_setup_true_lang_default;
  const _imports_0 = "/prod/s3fs-public/navigator/pdf-preview.png";
  function tryOnScopeDispose(fn) {
    if (getCurrentScope()) {
      onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function get(obj, key) {
    return unref(obj);
  }
  function toValue(r2) {
    return typeof r2 === "function" ? r2() : unref(r2);
  }
  const isClient = typeof window !== "undefined" && typeof document !== "undefined";
  typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
  const toString = Object.prototype.toString;
  const isObject = (val) => toString.call(val) === "[object Object]";
  const noop$3 = () => {
  };
  function createFilterWrapper(filter, fn) {
    function wrapper(...args) {
      return new Promise((resolve2, reject) => {
        Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve2).catch(reject);
      });
    }
    return wrapper;
  }
  const bypassFilter = (invoke2) => {
    return invoke2();
  };
  function debounceFilter(ms, options2 = {}) {
    let timer;
    let maxTimer;
    let lastRejector = noop$3;
    const _clearTimeout = (timer2) => {
      clearTimeout(timer2);
      lastRejector();
      lastRejector = noop$3;
    };
    const filter = (invoke2) => {
      const duration = toValue(ms);
      const maxDuration = toValue(options2.maxWait);
      if (timer)
        _clearTimeout(timer);
      if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
        if (maxTimer) {
          _clearTimeout(maxTimer);
          maxTimer = null;
        }
        return Promise.resolve(invoke2());
      }
      return new Promise((resolve2, reject) => {
        lastRejector = options2.rejectOnCancel ? reject : resolve2;
        if (maxDuration && !maxTimer) {
          maxTimer = setTimeout(() => {
            if (timer)
              _clearTimeout(timer);
            maxTimer = null;
            resolve2(invoke2());
          }, maxDuration);
        }
        timer = setTimeout(() => {
          if (maxTimer)
            _clearTimeout(maxTimer);
          maxTimer = null;
          resolve2(invoke2());
        }, duration);
      });
    };
    return filter;
  }
  function pausableFilter(extendFilter = bypassFilter) {
    const isActive = ref(true);
    function pause() {
      isActive.value = false;
    }
    function resume() {
      isActive.value = true;
    }
    const eventFilter = (...args) => {
      if (isActive.value)
        extendFilter(...args);
    };
    return { isActive: readonly(isActive), pause, resume, eventFilter };
  }
  function objectEntries(obj) {
    return Object.entries(obj);
  }
  function getLifeCycleTarget(target2) {
    return getCurrentInstance();
  }
  function useDebounceFn(fn, ms = 200, options2 = {}) {
    return createFilterWrapper(
      debounceFilter(ms, options2),
      fn
    );
  }
  function watchWithFilter(source, cb, options2 = {}) {
    const {
      eventFilter = bypassFilter,
      ...watchOptions
    } = options2;
    return watch(
      source,
      createFilterWrapper(
        eventFilter,
        cb
      ),
      watchOptions
    );
  }
  function watchPausable(source, cb, options2 = {}) {
    const {
      eventFilter: filter,
      ...watchOptions
    } = options2;
    const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
    const stop2 = watchWithFilter(
      source,
      cb,
      {
        ...watchOptions,
        eventFilter
      }
    );
    return { stop: stop2, pause, resume, isActive };
  }
  function tryOnMounted(fn, sync = true, target2) {
    const instance = getLifeCycleTarget();
    if (instance)
      onMounted(fn, target2);
    else if (sync)
      fn();
    else
      nextTick(fn);
  }
  function unrefElement(elRef) {
    var _a2;
    const plain = toValue(elRef);
    return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
  }
  const defaultWindow = isClient ? window : void 0;
  function useEventListener(...args) {
    let target2;
    let events2;
    let listeners;
    let options2;
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      [events2, listeners, options2] = args;
      target2 = defaultWindow;
    } else {
      [target2, events2, listeners, options2] = args;
    }
    if (!target2)
      return noop$3;
    if (!Array.isArray(events2))
      events2 = [events2];
    if (!Array.isArray(listeners))
      listeners = [listeners];
    const cleanups = [];
    const cleanup = () => {
      cleanups.forEach((fn) => fn());
      cleanups.length = 0;
    };
    const register2 = (el, event, listener, options22) => {
      el.addEventListener(event, listener, options22);
      return () => el.removeEventListener(event, listener, options22);
    };
    const stopWatch = watch(
      () => [unrefElement(target2), toValue(options2)],
      ([el, options22]) => {
        cleanup();
        if (!el)
          return;
        const optionsClone = isObject(options22) ? { ...options22 } : options22;
        cleanups.push(
          ...events2.flatMap((event) => {
            return listeners.map((listener) => register2(el, event, listener, optionsClone));
          })
        );
      },
      { immediate: true, flush: "post" }
    );
    const stop2 = () => {
      stopWatch();
      cleanup();
    };
    tryOnScopeDispose(stop2);
    return stop2;
  }
  function useMounted() {
    const isMounted = ref(false);
    const instance = getCurrentInstance();
    if (instance) {
      onMounted(() => {
        isMounted.value = true;
      }, instance);
    }
    return isMounted;
  }
  function useSupported(callback) {
    const isMounted = useMounted();
    return computed(() => {
      isMounted.value;
      return Boolean(callback());
    });
  }
  const WRITABLE_PROPERTIES = [
    "hash",
    "host",
    "hostname",
    "href",
    "pathname",
    "port",
    "protocol",
    "search"
  ];
  function useBrowserLocation(options2 = {}) {
    const { window: window2 = defaultWindow } = options2;
    const refs = Object.fromEntries(
      WRITABLE_PROPERTIES.map((key) => [key, ref()])
    );
    for (const [key, ref2] of objectEntries(refs)) {
      watch(ref2, (value) => {
        if (!(window2 == null ? void 0 : window2.location) || window2.location[key] === value)
          return;
        window2.location[key] = value;
      });
    }
    const buildState = (trigger2) => {
      var _a2;
      const { state: state2, length } = (window2 == null ? void 0 : window2.history) || {};
      const { origin } = (window2 == null ? void 0 : window2.location) || {};
      for (const key of WRITABLE_PROPERTIES)
        refs[key].value = (_a2 = window2 == null ? void 0 : window2.location) == null ? void 0 : _a2[key];
      return reactive({
        trigger: trigger2,
        state: state2,
        length,
        origin,
        ...refs
      });
    };
    const state = ref(buildState("load"));
    if (window2) {
      useEventListener(window2, "popstate", () => state.value = buildState("popstate"), { passive: true });
      useEventListener(window2, "hashchange", () => state.value = buildState("hashchange"), { passive: true });
    }
    return state;
  }
  function useResizeObserver(target2, callback, options2 = {}) {
    const { window: window2 = defaultWindow, ...observerOptions } = options2;
    let observer;
    const isSupported = useSupported(() => window2 && "ResizeObserver" in window2);
    const cleanup = () => {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    const targets = computed(() => Array.isArray(target2) ? target2.map((el) => unrefElement(el)) : [unrefElement(target2)]);
    const stopWatch = watch(
      targets,
      (els) => {
        cleanup();
        if (isSupported.value && window2) {
          observer = new ResizeObserver(callback);
          for (const _el of els)
            _el && observer.observe(_el, observerOptions);
        }
      },
      { immediate: true, flush: "post" }
    );
    const stop2 = () => {
      cleanup();
      stopWatch();
    };
    tryOnScopeDispose(stop2);
    return {
      isSupported,
      stop: stop2
    };
  }
  function useElementSize(target2, initialSize = { width: 0, height: 0 }, options2 = {}) {
    const { window: window2 = defaultWindow, box = "content-box" } = options2;
    const isSVG = computed(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = unrefElement(target2)) == null ? void 0 : _a2.namespaceURI) == null ? void 0 : _b2.includes("svg");
    });
    const width = ref(initialSize.width);
    const height = ref(initialSize.height);
    const { stop: stop1 } = useResizeObserver(
      target2,
      ([entry]) => {
        const boxSize = box === "border-box" ? entry.borderBoxSize : box === "content-box" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;
        if (window2 && isSVG.value) {
          const $elem = unrefElement(target2);
          if ($elem) {
            const rect = $elem.getBoundingClientRect();
            width.value = rect.width;
            height.value = rect.height;
          }
        } else {
          if (boxSize) {
            const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];
            width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);
            height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);
          } else {
            width.value = entry.contentRect.width;
            height.value = entry.contentRect.height;
          }
        }
      },
      options2
    );
    tryOnMounted(() => {
      const ele = unrefElement(target2);
      if (ele) {
        width.value = "offsetWidth" in ele ? ele.offsetWidth : initialSize.width;
        height.value = "offsetHeight" in ele ? ele.offsetHeight : initialSize.height;
      }
    });
    const stop2 = watch(
      () => unrefElement(target2),
      (ele) => {
        width.value = ele ? initialSize.width : 0;
        height.value = ele ? initialSize.height : 0;
      }
    );
    function stop3() {
      stop1();
      stop2();
    }
    return {
      width,
      height,
      stop: stop3
    };
  }
  function useUrlSearchParams(mode = "history", options2 = {}) {
    const {
      initialValue = {},
      removeNullishValues = true,
      removeFalsyValues = false,
      write: enableWrite = true,
      window: window2 = defaultWindow
    } = options2;
    if (!window2)
      return reactive(initialValue);
    const state = reactive({});
    function getRawParams() {
      if (mode === "history") {
        return window2.location.search || "";
      } else if (mode === "hash") {
        const hash = window2.location.hash || "";
        const index = hash.indexOf("?");
        return index > 0 ? hash.slice(index) : "";
      } else {
        return (window2.location.hash || "").replace(/^#/, "");
      }
    }
    function constructQuery(params) {
      const stringified = params.toString();
      if (mode === "history")
        return `${stringified ? `?${stringified}` : ""}${window2.location.hash || ""}`;
      if (mode === "hash-params")
        return `${window2.location.search || ""}${stringified ? `#${stringified}` : ""}`;
      const hash = window2.location.hash || "#";
      const index = hash.indexOf("?");
      if (index > 0)
        return `${hash.slice(0, index)}${stringified ? `?${stringified}` : ""}`;
      return `${hash}${stringified ? `?${stringified}` : ""}`;
    }
    function read() {
      return new URLSearchParams(getRawParams());
    }
    function updateState2(params) {
      const unusedKeys = new Set(Object.keys(state));
      for (const key of params.keys()) {
        const paramsForKey = params.getAll(key);
        state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || "";
        unusedKeys.delete(key);
      }
      Array.from(unusedKeys).forEach((key) => delete state[key]);
    }
    const { pause, resume } = watchPausable(
      state,
      () => {
        const params = new URLSearchParams("");
        Object.keys(state).forEach((key) => {
          const mapEntry = state[key];
          if (Array.isArray(mapEntry))
            mapEntry.forEach((value) => params.append(key, value));
          else if (removeNullishValues && mapEntry == null)
            params.delete(key);
          else if (removeFalsyValues && !mapEntry)
            params.delete(key);
          else
            params.set(key, mapEntry);
        });
        write(params);
      },
      { deep: true }
    );
    function write(params, shouldUpdate) {
      pause();
      if (shouldUpdate)
        updateState2(params);
      window2.history.replaceState(
        window2.history.state,
        window2.document.title,
        window2.location.pathname + constructQuery(params)
      );
      resume();
    }
    function onChanged() {
      if (!enableWrite)
        return;
      write(read(), true);
    }
    useEventListener(window2, "popstate", onChanged, false);
    if (mode !== "history")
      useEventListener(window2, "hashchange", onChanged, false);
    const initial2 = read();
    if (initial2.keys().next().value)
      updateState2(initial2);
    else
      Object.assign(state, initialValue);
    return state;
  }
  const _hoisted_1$b = { class: "flex flex-row !flex-wrap gap-4 py-2 md:!flex-nowrap" };
  const _hoisted_2$7 = { class: "flex flex-grow flex-col gap-2" };
  const _hoisted_3$6 = {
    key: 0,
    class: "hs-form-html"
  };
  const _sfc_main$b = /* @__PURE__ */ defineComponent({
    __name: "DownloadModal",
    props: {
      "open": {
        default: false
      },
      "openModifiers": {}
    },
    emits: ["update:open"],
    setup(__props) {
      const isLoaded = ref(true);
      const open = useModel(__props, "open");
      watch(
        () => open.value,
        () => {
          if (open.value) {
            hbspt.forms.create({
              portalId: "146389175",
              formId: "bf84194e-6e5d-4598-a0c4-660eeda5ec95",
              region: "eu1",
              target: ".hs-form-html"
            });
          }
        },
        { immediate: true }
      );
      return (_ctx, _cache2) => {
        const _component_DialogOverlay = DialogOverlay_default;
        const _component_DialogTitle = DialogTitle_default;
        const _component_DialogDescription = DialogDescription_default;
        const _component_DialogTrigger = DialogTrigger_default;
        const _component_DialogContent = DialogContent_default;
        const _component_DialogPortal = DialogPortal_default;
        const _component_DialogRoot = DialogRoot_default;
        return openBlock(), createBlock(_component_DialogRoot, {
          open: open.value,
          "onUpdate:open": _cache2[0] || (_cache2[0] = ($event) => open.value = $event)
        }, {
          default: withCtx(() => [
            createVNode(_component_DialogPortal, null, {
              default: withCtx(() => [
                createVNode(_component_DialogOverlay, { class: "fixed inset-0 z-[15] bg-black bg-opacity-50" }),
                createVNode(_component_DialogContent, { class: "fixed left-1/2 top-1/2 z-[9999] max-h-[90vh] w-max max-w-[90vw] -translate-x-1/2 -translate-y-1/2 transform overflow-y-auto rounded-lg bg-white p-6 shadow-lg" }, {
                  default: withCtx(() => [
                    createVNode(_component_DialogTitle, { class: "sr-only text-lg font-semibold" }, {
                      default: withCtx(() => _cache2[1] || (_cache2[1] = [
                        createTextVNode("Download PDFs")
                      ])),
                      _: 1
                    }),
                    createVNode(_component_DialogDescription, { class: "sr-only" }, {
                      default: withCtx(() => _cache2[2] || (_cache2[2] = [
                        createTextVNode(" Allows you to download PDFs of the countries by filling in the form. ")
                      ])),
                      _: 1
                    }),
                    createBaseVNode("div", _hoisted_1$b, [
                      _cache2[4] || (_cache2[4] = createBaseVNode("div", { class: "w-full max-w-full !p-5 md:max-w-[50%]" }, [
                        createBaseVNode("img", {
                          class: "h-auto max-h-[600px] w-full object-contain max-sm:max-h-[400px]",
                          src: _imports_0,
                          alt: "Preview of the PDF"
                        })
                      ], -1)),
                      createBaseVNode("div", _hoisted_2$7, [
                        _cache2[3] || (_cache2[3] = createBaseVNode("h3", { class: "font-sans text-lg font-semibold !text-primary" }, "Download PDFs", -1)),
                        isLoaded.value ? (openBlock(), createElementBlock("div", _hoisted_3$6)) : createCommentVNode("", true)
                      ])
                    ]),
                    createVNode(_component_DialogTrigger, { class: "absolute right-4 top-4 border-0 bg-transparent" }, {
                      default: withCtx(() => _cache2[5] || (_cache2[5] = [
                        createBaseVNode("i", { class: "fa-regular fa-times text-xl" }, null, -1)
                      ])),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["open"]);
      };
    }
  });
  const __unplugin_components_3 = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-6f37a646"]]);
  function toVal(mix) {
    let k2, y2, str = "";
    if (typeof mix === "string" || typeof mix === "number") {
      str += mix;
    } else if (typeof mix === "object") {
      if (Array.isArray(mix)) {
        const len = mix.length;
        for (k2 = 0; k2 < len; k2++) {
          if (mix[k2]) {
            if (y2 = toVal(mix[k2])) {
              str && (str += " ");
              str += y2;
            }
          }
        }
      } else {
        for (y2 in mix) {
          if (Object.prototype.hasOwnProperty.call(mix, y2) && mix[y2]) {
            str && (str += " ");
            str += y2;
          }
        }
      }
    }
    return str;
  }
  function clsx(...args) {
    let i2 = 0, tmp, x2, str = "", len = args.length;
    for (; i2 < len; i2++) {
      if (tmp = args[i2]) {
        if (x2 = toVal(tmp)) {
          str && (str += " ");
          str += x2;
        }
      }
    }
    return str;
  }
  const _hoisted_1$a = { class: "my-0 truncate font-sans font-bold uppercase !text-primary" };
  const _hoisted_2$6 = { class: "flex max-w-full flex-col gap-2 rounded-[4px] !border !border-solid !border-gray-light bg-white p-2 shadow-md" };
  const _hoisted_3$5 = { class: "indicator h-[20px] w-[20px] rounded-[4px] !border !border-solid !border-gray-light" };
  const _hoisted_4$5 = {
    key: 0,
    class: "my-0 shrink truncate"
  };
  const _hoisted_5$4 = ["innerHTML"];
  const _sfc_main$a = /* @__PURE__ */ defineComponent({
    __name: "MultiSelect",
    props: /* @__PURE__ */ mergeModels({
      anchorClass: { default: "" },
      buttonTitle: {},
      disableSearch: { type: Boolean, default: false },
      displayKey: {},
      handleSelect: {},
      keyField: {},
      maxSelected: { default: 0 },
      options: {},
      placeholder: {},
      sortFn: { type: [Boolean, Function] },
      triggerClass: { default: "" },
      contentClass: { default: "" },
      dangerouslyRenderNameAsHtml: { type: Boolean, default: false }
    }, {
      "selected": {
        required: true
      },
      "selectedModifiers": {},
      "searchTerm": {
        required: false,
        default: ""
      },
      "searchTermModifiers": {}
    }),
    emits: ["update:selected", "update:searchTerm"],
    setup(__props) {
      const props = __props;
      const open = ref(false);
      const selected = useModel(__props, "selected");
      const viewPortRef = ref();
      watch(
        selected,
        () => {
          var _a2;
          if (selected.value.length === 0 || !viewPortRef.value || !props.maxSelected) {
            return;
          }
          if (selected.value.length < props.maxSelected) {
            return;
          }
          (_a2 = viewPortRef.value) == null ? void 0 : _a2.scroll({
            top: 0,
            left: 0,
            behavior: "smooth"
          });
        },
        {
          deep: true,
          immediate: true
        }
      );
      const handleSelectFn = (option) => {
        if (selected.value.find((el) => el[props.keyField] === option[props.keyField])) {
          selected.value = selected.value.filter((el) => el[props.keyField] !== option[props.keyField]);
        } else {
          if (props.maxSelected > 0 && selected.value.length >= props.maxSelected) {
            return;
          }
          selected.value.push(option);
        }
      };
      const triggerRef2 = ref();
      const { width } = useElementSize(
        triggerRef2,
        { width: 100, height: 100 },
        {
          box: "border-box"
        }
      );
      const searchTerm = useModel(__props, "searchTerm");
      const filteredOptions = computed(() => {
        if (searchTerm.value === "") {
          if (props.sortFn) {
            return props.options.toSorted(props.sortFn);
          }
          if (!props.sortFn) {
            return props.options;
          }
          return props.options.toSorted(defaultSortFn);
        }
        const fuse = new Fuse(props.options, {
          keys: [props.displayKey],
          threshold: 0.3
        });
        const searchResults = fuse.search(searchTerm.value);
        const afterFilter = searchResults.map((c2) => c2.item);
        if (props.sortFn) {
          return afterFilter.toSorted(props.sortFn);
        }
        if (!props.sortFn) {
          return afterFilter;
        }
        return afterFilter.toSorted(defaultSortFn);
      });
      const defaultSortFn = (a2, b2) => {
        if (!props.displayKey) return 0;
        const isStrings = typeof a2[props.displayKey] === "string" && typeof b2[props.displayKey] === "string";
        if (isStrings) {
          return a2[props.displayKey].localeCompare(b2[props.displayKey]);
        }
        return 0;
      };
      return (_ctx, _cache2) => {
        const _component_ComboboxTrigger = ComboboxTrigger_default;
        const _component_ComboboxAnchor = ComboboxAnchor_default;
        const _component_ComboboxInput = ComboboxInput_default;
        const _component_ComboboxEmpty = ComboboxEmpty_default;
        const _component_ComboboxItemIndicator = ComboboxItemIndicator_default;
        const _component_ComboboxItem = ComboboxItem_default;
        const _component_ComboboxViewport = ComboboxViewport_default;
        const _component_ComboboxContent = ComboboxContent_default;
        const _component_ComboboxRoot = ComboboxRoot_default;
        const _directive_auto_animate = resolveDirective("auto-animate");
        return openBlock(), createBlock(_component_ComboboxRoot, {
          open: open.value,
          "onUpdate:open": _cache2[0] || (_cache2[0] = ($event) => open.value = $event),
          modelValue: selected.value,
          "onUpdate:modelValue": _cache2[1] || (_cache2[1] = ($event) => selected.value = $event),
          multiple: "",
          searchTerm: searchTerm.value,
          "onUpdate:searchTerm": _cache2[2] || (_cache2[2] = ($event) => searchTerm.value = $event)
        }, {
          default: withCtx(() => [
            createVNode(_component_ComboboxAnchor, {
              as: "div",
              class: normalizeClass(unref(clsx)("flex flex-row items-center", props.anchorClass))
            }, {
              default: withCtx(() => [
                createVNode(_component_ComboboxTrigger, {
                  class: normalizeClass(["multi-select-trigger flex items-center justify-start rounded-[4px] !border !border-solid !border-gray-light bg-white px-2 px-3 py-3", unref(clsx)("min-w-[160px]", props.triggerClass, { "!bg-light-blue": open.value })]),
                  ref_key: "triggerRef",
                  ref: triggerRef2
                }, {
                  default: withCtx(() => {
                    var _a2, _b2;
                    return [
                      createBaseVNode("p", _hoisted_1$a, toDisplayString(props.buttonTitle), 1),
                      withDirectives(createBaseVNode("p", { class: "my-0 inline-block !pl-2 font-sans font-bold !text-primary" }, " (" + toDisplayString((_a2 = selected.value) == null ? void 0 : _a2.length) + ") ", 513), [
                        [vShow, (_b2 = selected.value) == null ? void 0 : _b2.length]
                      ]),
                      _cache2[3] || (_cache2[3] = createBaseVNode("span", { class: "ml-auto inline-flex items-center gap-2 pl-2 text-sm font-semibold text-gray-900" }, [
                        createBaseVNode("i", { class: "fa-regular fa-chevron-down transform rounded-full p-1 text-lg !text-primary transition-transform duration-100 max-sm:text-md" }),
                        createBaseVNode("span", { class: "sr-only" }, "Select")
                      ], -1))
                    ];
                  }),
                  _: 1
                }, 8, ["class"])
              ]),
              _: 1
            }, 8, ["class"]),
            createVNode(_component_ComboboxContent, {
              class: normalizeClass(unref(clsx)("absolute z-[8] w-max pt-2 font-sans !text-primary", props.contentClass)),
              style: normalizeStyle(`width: ${unref(width)}px`)
            }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_2$6, [
                  !props.disableSearch ? (openBlock(), createBlock(_component_ComboboxInput, {
                    key: 0,
                    class: "box-border w-full rounded-[4px] !border !border-solid !border-gray-light p-2 font-sans text-sm !text-primary",
                    placeholder: props.placeholder,
                    "display-value": (v2) => props.displayKey ? v2[props.displayKey] : v2
                  }, null, 8, ["placeholder", "display-value"])) : createCommentVNode("", true),
                  createVNode(_component_ComboboxViewport, { "as-child": "" }, {
                    default: withCtx(() => [
                      withDirectives((openBlock(), createElementBlock("div", {
                        class: "max-h-[200px] overflow-auto",
                        ref: (el) => viewPortRef.value = el
                      }, [
                        createVNode(_component_ComboboxEmpty, { class: "font-sans text-md" }),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(filteredOptions.value, (option) => {
                          return withDirectives((openBlock(), createBlock(_component_ComboboxItem, {
                            key: props.keyField ? option[props.keyField] : option,
                            class: "multi-select-item grid grid-cols-[auto_1fr] items-center gap-2 py-2 hover:bg-gray-100",
                            value: option,
                            onSelect: withModifiers(($event) => _ctx.handleSelect ? _ctx.handleSelect(option) : handleSelectFn(option), ["prevent"]),
                            disabled: props.maxSelected > 0 && selected.value.length >= props.maxSelected
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("span", _hoisted_3$5, [
                                createVNode(_component_ComboboxItemIndicator, { class: "flex h-full w-full items-center justify-center" }, {
                                  default: withCtx(() => _cache2[4] || (_cache2[4] = [
                                    createBaseVNode("i", { class: "fa-regular fa-check text-[12px] !text-primary" }, null, -1),
                                    createBaseVNode("span", { class: "sr-only" }, "Selected", -1)
                                  ])),
                                  _: 1
                                })
                              ]),
                              !_ctx.dangerouslyRenderNameAsHtml ? (openBlock(), createElementBlock("p", _hoisted_4$5, toDisplayString((props.displayKey ? option[props.displayKey] : option) ?? ""), 1)) : (openBlock(), createElementBlock("p", {
                                key: 1,
                                class: "my-0 inline-flex shrink items-center gap-0.5 truncate",
                                innerHTML: (props.displayKey ? option[props.displayKey] : option) ?? ""
                              }, null, 8, _hoisted_5$4))
                            ]),
                            _: 2
                          }, 1032, ["value", "onSelect", "disabled"])), [
                            [_directive_auto_animate]
                          ]);
                        }), 128))
                      ])), [
                        [_directive_auto_animate, { duration: 100 }]
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }, 8, ["class", "style"])
          ]),
          _: 1
        }, 8, ["open", "modelValue", "searchTerm"]);
      };
    }
  });
  const __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-f6a0e96b"]]);
  const _hoisted_1$9 = {
    key: 0,
    class: "fa-regular fa-times-circle text-[22px]"
  };
  const _sfc_main$9 = /* @__PURE__ */ defineComponent({
    __name: "CountryButton",
    props: {
      country: {}
    },
    setup(__props) {
      const countryStore = useCountryStore();
      const countryName = ref();
      const fontSize = ref(23);
      const handleFontSize = useDebounceFn(() => {
        var _a2;
        const height = ((_a2 = countryName.value) == null ? void 0 : _a2.clientHeight) ?? 0;
        if (fontSize.value < 23) {
          return;
        }
        if (height > 75) {
          fontSize.value = 12;
          return;
        }
        if (height > 65) {
          fontSize.value = 18;
          return;
        }
        fontSize.value = 23;
      }, 100);
      useEventListener(window, "resize", handleFontSize);
      onMounted(handleFontSize);
      return (_ctx, _cache2) => {
        return openBlock(), createElementBlock("div", {
          onClick: _cache2[0] || (_cache2[0] = ($event) => unref(countryStore).selectCountry(_ctx.country)),
          class: normalizeClass(["relative flex flex-row box-border !border-solid rounded-lg !border !border-gray-light h-[75px] cursor-pointer items-center justify-center gap-2 bg-white px-4 py-4 font-sans font-bold !text-primary transition-colors duration-200 hover:!bg-gradient-secondary hover:!text-white", { "!bg-primary !text-white !bg-gradient-secondary": unref(countryStore).isSelected(_ctx.country) }])
        }, [
          createBaseVNode("span", {
            ref_key: "countryName",
            ref: countryName,
            class: "text-center",
            style: normalizeStyle(`font-size: ${fontSize.value}px`)
          }, toDisplayString(_ctx.country.name), 5),
          unref(countryStore).isSelected(_ctx.country) ? (openBlock(), createElementBlock("i", _hoisted_1$9)) : createCommentVNode("", true)
        ], 2);
      };
    }
  });
  const _hoisted_1$8 = { class: "flex flex-col gap-2 rounded-[4px] !border !border-solid !border-primary bg-light !p-4 text-right !text-primary" };
  const _sfc_main$8 = /* @__PURE__ */ defineComponent({
    __name: "OrderSelection",
    props: {
      classes: { default: "" }
    },
    setup(__props) {
      const toggleState = ref(false);
      const uiStore = useUiStore();
      const { countryOrderBy } = storeToRefs(uiStore);
      return (_ctx, _cache2) => {
        const _component_DropdownMenuTrigger = DropdownMenuTrigger_default;
        const _component_DropdownMenuItem = DropdownMenuItem_default;
        const _component_DropdownMenuContent = DropdownMenuContent_default;
        const _component_DropdownMenuPortal = DropdownMenuPortal_default;
        const _component_DropdownMenuRoot = DropdownMenuRoot_default;
        return openBlock(), createBlock(_component_DropdownMenuRoot, {
          open: toggleState.value,
          "onUpdate:open": _cache2[2] || (_cache2[2] = ($event) => toggleState.value = $event)
        }, {
          default: withCtx(() => [
            createVNode(_component_DropdownMenuTrigger, {
              class: normalizeClass(
                unref(clsx)(
                  "inline-flex flex-row items-center justify-center gap-2 border-0 bg-transparent font-sans !text-primary",
                  _ctx.classes
                )
              )
            }, {
              default: withCtx(() => [
                _cache2[3] || (_cache2[3] = createBaseVNode("span", null, "Sort by", -1)),
                createBaseVNode("i", {
                  class: normalizeClass(["fa-regular fa-chevron-down transform rounded-full p-1 text-lg text-secondary transition-transform duration-100 max-sm:text-md", { "rotate-180": toggleState.value }])
                }, null, 2)
              ]),
              _: 1
            }, 8, ["class"]),
            createVNode(_component_DropdownMenuPortal, null, {
              default: withCtx(() => [
                createVNode(_component_DropdownMenuContent, { class: "w-[200px] pt-3 font-sans font-bold" }, {
                  default: withCtx(() => [
                    createBaseVNode("div", _hoisted_1$8, [
                      createVNode(_component_DropdownMenuItem, {
                        class: normalizeClass(["cursor-pointer", { underline: unref(countryOrderBy) === "name" }]),
                        onClick: _cache2[0] || (_cache2[0] = ($event) => unref(uiStore).setCountryOrderBy("name"))
                      }, {
                        default: withCtx(() => _cache2[4] || (_cache2[4] = [
                          createTextVNode(" Name ")
                        ])),
                        _: 1
                      }, 8, ["class"]),
                      createVNode(_component_DropdownMenuItem, {
                        class: normalizeClass(["cursor-pointer", { underline: unref(countryOrderBy) === "recently_updated" }]),
                        onClick: _cache2[1] || (_cache2[1] = ($event) => unref(uiStore).setCountryOrderBy("recently_updated"))
                      }, {
                        default: withCtx(() => _cache2[5] || (_cache2[5] = [
                          createTextVNode(" Recently updated ")
                        ])),
                        _: 1
                      }, 8, ["class"])
                    ])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["open"]);
      };
    }
  });
  const _hoisted_1$7 = { id: "country-profiles" };
  const _hoisted_2$5 = { class: "mb-8 flex flex-row items-center gap-4" };
  const _hoisted_3$4 = {
    key: 0,
    class: "flex flex-col justify-center gap-4"
  };
  const _hoisted_4$4 = { class: "flex w-full grow flex-row items-center gap-4" };
  const _hoisted_5$3 = {
    key: 1,
    class: "col-span-2 flex justify-end max-sm:right-0 max-sm:top-40 max-sm:col-span-1 sm:col-span-3 md:col-span-2"
  };
  const _hoisted_6$3 = {
    key: 0,
    class: "flex justify-center"
  };
  const _hoisted_7$2 = { key: 1 };
  const _hoisted_8$2 = { key: 2 };
  const _sfc_main$7 = /* @__PURE__ */ defineComponent({
    __name: "CountryButtons",
    setup(__props) {
      const countryStore = useCountryStore();
      const uiStore = useUiStore();
      countryStore.fetchCountries();
      const loadMore = ref(false);
      const showCountries = computed(() => {
        if (countryStore.selectedCountry !== void 0) {
          return [countryStore.selectedCountry];
        }
        if (countryStore.filteredCountries.length > 20 && !loadMore.value) {
          return countryStore.filteredCountries.slice(0, 20);
        }
        return countryStore.filteredCountries;
      });
      const availableCountries = computed(() => {
        return countryStore.filteredCountries.filter((c2) => {
          var _a2;
          return c2.id !== ((_a2 = countryStore.selectedCountry) == null ? void 0 : _a2.id);
        }).toSorted((a2, b2) => {
          if (countryStore.isSelected(a2) && !countryStore.isSelected(b2)) {
            return -1;
          }
          if (!countryStore.isSelected(a2) && countryStore.isSelected(b2)) {
            return 1;
          }
          if (countryStore.isSelected(a2) && countryStore.isSelected(b2)) {
            return 0;
          }
          return 0;
        }).map((country) => {
          if (!country.taxonomies && !country.taxonomies["regulatory-landscape"]) {
            return country;
          }
          const recentlyUpdated = getTaxonomySlugs(country.taxonomies["regulatory-landscape"]).includes(
            "recentlyenforced"
          );
          if (!recentlyUpdated) {
            return {
              ...country,
              compareName: country.name
            };
          }
          return {
            ...country,
            compareName: `<span>${country.name}</span><span class="text-xs font-semibold ml-1">(Recently updated)</span>`
          };
        });
      });
      const showDownloadModal = ref(false);
      const downloadPDF = () => {
        showDownloadModal.value = true;
      };
      return (_ctx, _cache2) => {
        const _component_OrderSelection = _sfc_main$8;
        const _component_CountryButton = _sfc_main$9;
        const _component_MultiSelect = __unplugin_components_1;
        const _component_DownloadModal = __unplugin_components_3;
        const _component_LoadingSpinner = __unplugin_components_0;
        const _directive_auto_animate = resolveDirective("auto-animate");
        return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$7, [
          createBaseVNode("div", _hoisted_2$5, [
            _cache2[4] || (_cache2[4] = createBaseVNode("h2", { class: "my-0 grow font-sans font-bold !text-primary max-sm:hidden" }, "Country Profiles", -1)),
            !unref(countryStore).selectedCountry ? (openBlock(), createBlock(_component_OrderSelection, {
              key: 0,
              classes: "ml-auto w-fit max-sm:hidden"
            })) : createCommentVNode("", true)
          ]),
          !unref(countryStore).isLoading && unref(countryStore).filteredCountries.length > 0 ? withDirectives((openBlock(), createElementBlock("div", _hoisted_3$4, [
            createBaseVNode("div", _hoisted_4$4, [
              withDirectives((openBlock(), createElementBlock("div", {
                class: normalizeClass(["grid grow grid-cols-2 gap-2 py-2 !pl-0 md:grid-cols-5 lg:grid-cols-5 xl:grid-cols-5", { "flex-wrap max-md:!flex": unref(countryStore).selectedCountry }])
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(showCountries.value, (country) => {
                  return openBlock(), createBlock(_component_CountryButton, {
                    key: country.id,
                    country,
                    class: "col-span-1"
                  }, null, 8, ["country"]);
                }), 128)),
                unref(countryStore).selectedCountry !== void 0 ? (openBlock(), createBlock(_component_MultiSelect, {
                  key: 0,
                  options: availableCountries.value,
                  "sort-fn": false,
                  selected: unref(countryStore).compareCountries,
                  "onUpdate:selected": _cache2[0] || (_cache2[0] = ($event) => unref(countryStore).compareCountries = $event),
                  searchTerm: unref(uiStore).searchText,
                  "onUpdate:searchTerm": _cache2[1] || (_cache2[1] = ($event) => unref(uiStore).searchText = $event),
                  "display-key": "compareName",
                  "key-field": "id",
                  "button-title": "Compare countries",
                  placeholder: "Search countries",
                  "anchor-class": "h-full md:w-max w-full",
                  class: "z-[8] col-span-2",
                  "trigger-class": "h-full w-full",
                  "dangerously-render-name-as-html": "",
                  "max-selected": 2
                }, null, 8, ["options", "selected", "searchTerm"])) : createCommentVNode("", true),
                unref(countryStore).selectedCountry ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
                  createBaseVNode("button", {
                    class: "btn !mb-0 flex w-max items-center justify-center gap-2 rounded-md border-0 bg-secondary px-10 font-sans text-md text-white transition-all duration-200 hover:bg-gradient-secondary max-md:py-4",
                    onClick: downloadPDF
                  }, [
                    createTextVNode(" Download PDF" + toDisplayString(unref(countryStore).compareCountries.length > 0 ? "s" : "") + " ", 1),
                    _cache2[5] || (_cache2[5] = createBaseVNode("i", { class: "fa-regular fa-file-arrow-down fa-xl" }, null, -1))
                  ]),
                  createVNode(_component_DownloadModal, {
                    open: showDownloadModal.value,
                    "onUpdate:open": _cache2[2] || (_cache2[2] = ($event) => showDownloadModal.value = $event)
                  }, null, 8, ["open"])
                ])) : createCommentVNode("", true)
              ], 2)), [
                [_directive_auto_animate]
              ])
            ]),
            !loadMore.value && unref(countryStore).filteredCountries.length > 20 && unref(countryStore).selectedCountry === void 0 ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
              createBaseVNode("button", {
                onClick: _cache2[3] || (_cache2[3] = ($event) => loadMore.value = true),
                class: "inline-flex w-fit cursor-pointer items-center gap-2 rounded-lg border-0 !bg-secondary px-5 py-3 font-sans uppercase !text-white hover:bg-gradient"
              }, _cache2[6] || (_cache2[6] = [
                createTextVNode(" Load more "),
                createBaseVNode("i", { class: "fa-regular fa-plus" }, null, -1)
              ]))
            ])) : createCommentVNode("", true)
          ])), [
            [_directive_auto_animate]
          ]) : unref(countryStore).isLoading ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
            createVNode(_component_LoadingSpinner, { class: "*:text-2xl" })
          ])) : (openBlock(), createElementBlock("div", _hoisted_8$2, _cache2[7] || (_cache2[7] = [
            createBaseVNode("p", { class: "" }, "No countries found.", -1)
          ])))
        ])), [
          [_directive_auto_animate]
        ]);
      };
    }
  });
  const getFilters = async () => {
    const response = await fetch(getApiUrl("/filters/all"), getFetchOptions());
    if (!response.ok) throw new Error(response.statusText);
    const rawData = await response.json();
    if (!rawData.data) throw new Error(rawData.message);
    return rawData.data;
  };
  const _hoisted_1$6 = {
    key: 0,
    class: "mb-4 flex flex-col gap-4"
  };
  const _hoisted_2$4 = { class: "flex flex-row items-center gap-4 max-sm:hidden" };
  const _hoisted_3$3 = { class: "filter-wrapper mb-0 flex list-none flex-row flex-wrap gap-4 !pl-0" };
  const _hoisted_4$3 = { key: 1 };
  const _sfc_main$6 = /* @__PURE__ */ defineComponent({
    __name: "CountryFilters",
    setup(__props) {
      const { data, isFetching } = useQuery({
        queryKey: ["taxonomies"],
        queryFn: getFilters
      });
      const selected = ref({});
      watch(data, (newValue) => {
        if (newValue === void 0) return;
        selected.value = newValue.reduce((acc, filter) => {
          const sanitizedName = sanitizePropertyName(filter.name);
          acc[sanitizedName] = [];
          return acc;
        }, {});
      });
      const countryStore = useCountryStore();
      const getHandleSelect = (index) => (option) => {
        const idObj = data.value[index].options[option];
        const sanitizedName = sanitizePropertyName(data.value[index].name);
        const currentSelected = selected.value[sanitizedName];
        if (!idObj || !currentSelected) return;
        const selectedIdx = currentSelected.findIndex((name) => name === option);
        if (selectedIdx > -1) {
          currentSelected.splice(selectedIdx, 1);
        } else {
          currentSelected.push(option);
        }
        const key = data.value[index].name;
        const entries = Object.entries(idObj);
        countryStore.toggleFilters(key, entries);
      };
      const getSelected = (key) => {
        const filters = countryStore.getFilter(key);
        if (!data.value) {
          return [];
        }
        return data.value.reduce((acc, curr) => {
          if (!curr.options) {
            return acc;
          }
          const keys = Object.keys(curr.options);
          if (keys.length === 0) {
            return acc;
          }
          acc.push(
            ...keys.filter((option) => {
              if (!curr.options[option]) {
                return false;
              }
              if (Object.values(curr.options[option]).length === 0) {
                return false;
              }
              return Object.values(curr.options[option]).some((value) => {
                return filters.includes(value);
              });
            })
          );
          return acc;
        }, []);
      };
      return (_ctx, _cache2) => {
        const _component_MultiSelect = __unplugin_components_1;
        const _component_LoadingSpinner = __unplugin_components_0;
        const _directive_auto_animate = resolveDirective("auto-animate");
        return unref(data) ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
          withDirectives((openBlock(), createElementBlock("div", _hoisted_2$4, _cache2[0] || (_cache2[0] = [
            createBaseVNode("h2", { class: "mb-0 font-sans font-bold !text-primary" }, "Filter countries", -1)
          ]))), [
            [_directive_auto_animate]
          ]),
          createBaseVNode("ul", _hoisted_3$3, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(data), (filter, index) => {
              return openBlock(), createElementBlock("li", {
                key: filter.name,
                class: "max-sm:w-full"
              }, [
                createVNode(_component_MultiSelect, {
                  options: Object.keys(filter.options),
                  selected: getSelected(filter.name),
                  "disable-search": "",
                  "button-title": filter.name,
                  "trigger-class": "min-w-[240px] w-full md:w-0 mobile-filter-trigger",
                  "content-class": "mobile-content",
                  handleSelect: getHandleSelect(index)
                }, null, 8, ["options", "selected", "button-title", "handleSelect"])
              ]);
            }), 128))
          ])
        ])) : unref(isFetching) ? (openBlock(), createElementBlock("div", _hoisted_4$3, [
          createVNode(_component_LoadingSpinner, { class: "*:text-2xl" })
        ])) : createCommentVNode("", true);
      };
    }
  });
  const __vite_glob_1_0 = "/prod/s3fs-public/navigator/africa-light.svg";
  const __vite_glob_1_2 = "/prod/s3fs-public/navigator/asia-light.svg";
  const __vite_glob_1_4 = "/prod/s3fs-public/navigator/europe-islands-light.svg";
  const __vite_glob_1_6 = "/prod/s3fs-public/navigator/europe-light.svg";
  const __vite_glob_1_8 = "/prod/s3fs-public/navigator/latin-light.svg";
  const __vite_glob_1_10 = "/prod/s3fs-public/navigator/na-light.svg";
  const __vite_glob_1_12 = "/prod/s3fs-public/navigator/pacific-light.svg";
  const __vite_glob_1_1 = "/prod/s3fs-public/navigator/africa.svg";
  const __vite_glob_1_3 = "/prod/s3fs-public/navigator/asia.svg";
  const __vite_glob_1_5 = "/prod/s3fs-public/navigator/europe-islands.svg";
  const __vite_glob_1_7 = "/prod/s3fs-public/navigator/europe.svg";
  const __vite_glob_1_9 = "/prod/s3fs-public/navigator/latin.svg";
  const __vite_glob_1_11 = "/prod/s3fs-public/navigator/na.svg";
  const __vite_glob_1_13 = "/prod/s3fs-public/navigator/pacific.svg";
  const getRegions = async () => {
    const response = await fetch(getApiUrl("/regions/all"), getFetchOptions());
    if (!response.ok) throw new Error(response.statusText);
    const rawData = await response.json();
    if (!rawData.data) throw new Error(rawData.message);
    return rawData.data;
  };
  var PERSISTER_KEY_PREFIX = "tanstack-query";
  function experimental_createPersister({
    storage,
    buster = "",
    maxAge = 1e3 * 60 * 60 * 24,
    serialize: serialize2 = JSON.stringify,
    deserialize = JSON.parse,
    prefix = PERSISTER_KEY_PREFIX,
    filters
  }) {
    return async function persisterFn(queryFn, context2, query) {
      const storageKey = `${prefix}-${query.queryHash}`;
      const matchesFilter = filters ? matchQuery(filters, query) : true;
      if (matchesFilter && query.state.data === void 0 && storage != null) {
        try {
          const storedData = await storage.getItem(storageKey);
          if (storedData) {
            const persistedQuery = await deserialize(storedData);
            if (persistedQuery.state.dataUpdatedAt) {
              const queryAge = Date.now() - persistedQuery.state.dataUpdatedAt;
              const expired = queryAge > maxAge;
              const busted = persistedQuery.buster !== buster;
              if (expired || busted) {
                await storage.removeItem(storageKey);
              } else {
                setTimeout(() => {
                  query.setState({
                    dataUpdatedAt: persistedQuery.state.dataUpdatedAt,
                    errorUpdatedAt: persistedQuery.state.errorUpdatedAt
                  });
                  if (query.isStale()) {
                    query.fetch();
                  }
                }, 0);
                return Promise.resolve(persistedQuery.state.data);
              }
            } else {
              await storage.removeItem(storageKey);
            }
          }
        } catch (err) {
          await storage.removeItem(storageKey);
        }
      }
      const queryFnResult = await queryFn(context2);
      if (matchesFilter && storage != null) {
        setTimeout(async () => {
          storage.setItem(
            storageKey,
            await serialize2({
              state: query.state,
              queryKey: query.queryKey,
              queryHash: query.queryHash,
              buster
            })
          );
        }, 0);
      }
      return Promise.resolve(queryFnResult);
    };
  }
  const _hoisted_1$5 = { class: "flex flex-col gap-4 max-sm:hidden" };
  const _hoisted_2$3 = { class: "flex mb-12 flex-row items-center gap-4" };
  const _hoisted_3$2 = { class: "flex gap-4 mt-auto ml-8" };
  const _hoisted_4$2 = {
    key: 0,
    class: "mb-0 mt-0 font-sans text-sm !text-primary"
  };
  const _hoisted_5$2 = {
    key: 0,
    class: "flex flex-row items-center justify-center gap-4"
  };
  const _hoisted_6$2 = {
    key: 1,
    class: "grid list-none grid-cols-2 gap-4 !pl-0 md:grid-cols-3 lg:grid-cols-5 xl:grid-cols-6"
  };
  const _hoisted_7$1 = ["onClick", "onMouseover"];
  const _hoisted_8$1 = {
    key: 0,
    class: "fa-regular fa-times-circle absolute right-1.5 top-1.5 text-[15px]"
  };
  const _hoisted_9 = ["alt", "src", "onError"];
  const _hoisted_10 = { class: "text-center uppercase" };
  const _hoisted_11 = {
    key: 0,
    class: "flex flex-col gap-4 pb-4 !text-primary sm:hidden"
  };
  const _sfc_main$5 = /* @__PURE__ */ defineComponent({
    __name: "RegionButtons",
    setup(__props) {
      const { isPending, data } = useQuery({
        queryKey: ["regions"],
        queryFn: getRegions,
        persister: experimental_createPersister({
          storage: sessionStorage
        })
      });
      const uiStore = useUiStore();
      const countryStore = useCountryStore();
      const regionImages = ref({});
      const hoveredRegion = ref();
      const setHoveredRegion = (region) => {
        hoveredRegion.value = region.term_id;
      };
      const getRegionImage = computed(() => (region) => {
        const light = uiStore.isRegionSelected(region.term_id) || hoveredRegion.value === region.term_id;
        return light ? new URL((/* @__PURE__ */ Object.assign({ "../assets/images/regions/africa-light.svg": __vite_glob_1_0, "../assets/images/regions/asia-light.svg": __vite_glob_1_2, "../assets/images/regions/europe-islands-light.svg": __vite_glob_1_4, "../assets/images/regions/europe-light.svg": __vite_glob_1_6, "../assets/images/regions/latin-light.svg": __vite_glob_1_8, "../assets/images/regions/na-light.svg": __vite_glob_1_10, "../assets/images/regions/pacific-light.svg": __vite_glob_1_12 }))[`../assets/images/regions/${region.slug}-light.svg`], _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.js", document.baseURI).href).href : new URL((/* @__PURE__ */ Object.assign({ "../assets/images/regions/africa-light.svg": __vite_glob_1_0, "../assets/images/regions/africa.svg": __vite_glob_1_1, "../assets/images/regions/asia-light.svg": __vite_glob_1_2, "../assets/images/regions/asia.svg": __vite_glob_1_3, "../assets/images/regions/europe-islands-light.svg": __vite_glob_1_4, "../assets/images/regions/europe-islands.svg": __vite_glob_1_5, "../assets/images/regions/europe-light.svg": __vite_glob_1_6, "../assets/images/regions/europe.svg": __vite_glob_1_7, "../assets/images/regions/latin-light.svg": __vite_glob_1_8, "../assets/images/regions/latin.svg": __vite_glob_1_9, "../assets/images/regions/na-light.svg": __vite_glob_1_10, "../assets/images/regions/na.svg": __vite_glob_1_11, "../assets/images/regions/pacific-light.svg": __vite_glob_1_12, "../assets/images/regions/pacific.svg": __vite_glob_1_13 }))[`../assets/images/regions/${region.slug}.svg`], _documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === "SCRIPT" && _documentCurrentScript.src || new URL("index.js", document.baseURI).href).href;
      });
      const setFallbackImage = (region) => {
        const image = regionImages.value[region.slug];
        if (image) {
          image.remove();
        }
      };
      const convertedSelections = computed(() => {
        if (!data.value) return [];
        return data.value.filter((region) => {
          return uiStore.selectedRegions.includes(region.term_id);
        });
      });
      return (_ctx, _cache2) => {
        const _component_LoadingSpinner = __unplugin_components_0;
        const _component_MultiSelect = __unplugin_components_1;
        const _directive_auto_animate = resolveDirective("auto-animate");
        return openBlock(), createElementBlock(Fragment, null, [
          withDirectives((openBlock(), createElementBlock("div", _hoisted_1$5, [
            withDirectives((openBlock(), createElementBlock("div", _hoisted_2$3, [
              _cache2[3] || (_cache2[3] = createBaseVNode("h2", { class: "mb-0 text-xl font-bold !text-primary" }, "Filter by region", -1)),
              createBaseVNode("div", _hoisted_3$2, [
                unref(countryStore).hasFilters ? (openBlock(), createElementBlock("p", _hoisted_4$2, toDisplayString(unref(countryStore).selectedFilterCount) + " filter" + toDisplayString(unref(countryStore).selectedFilterCount === 1 ? "" : "s") + " selected ", 1)) : createCommentVNode("", true),
                unref(countryStore).hasFilters ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  onClick: _cache2[0] || (_cache2[0] = //@ts-ignore
                  (...args) => unref(countryStore).resetFilters && unref(countryStore).resetFilters(...args)),
                  class: "text-danger border-0 flex items-center gap-2 bg-transparent font-sans text-sm"
                }, _cache2[2] || (_cache2[2] = [
                  createBaseVNode("i", { class: "fa-regular fa-times-circle text-danger" }, null, -1),
                  createTextVNode(" Reset filters ")
                ]))) : createCommentVNode("", true)
              ])
            ])), [
              [_directive_auto_animate]
            ]),
            unref(isPending) ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
              createVNode(_component_LoadingSpinner, { class: "*:text-2xl" })
            ])) : (openBlock(), createElementBlock("ul", _hoisted_6$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(data), (region) => {
                return openBlock(), createElementBlock("li", {
                  key: region.term_id,
                  class: normalizeClass(["!border-solid !border !border-gray-light relative rounded-lg flex cursor-pointer flex-col items-center justify-center gap-2 bg-white px-4 py-4 font-sans hover:!bg-gradient hover:!text-white", [
                    unref(uiStore).isRegionSelected(region.term_id) ? "!bg-gradient !text-light" : "!text-primary"
                  ]]),
                  onClick: ($event) => unref(uiStore).toggleRegion(region.term_id),
                  onMouseover: ($event) => setHoveredRegion(region),
                  onMouseleave: _cache2[1] || (_cache2[1] = ($event) => hoveredRegion.value = void 0)
                }, [
                  unref(uiStore).isRegionSelected(region.term_id) ? (openBlock(), createElementBlock("i", _hoisted_8$1)) : createCommentVNode("", true),
                  createBaseVNode("img", {
                    ref_for: true,
                    ref: (el) => regionImages.value[region.slug] = el,
                    alt: `Illustrative map of ${region.name}`,
                    src: getRegionImage.value(region),
                    class: "h-[120px] w-[120px] object-contain",
                    onError: ($event) => setFallbackImage(region)
                  }, null, 40, _hoisted_9),
                  createBaseVNode("span", _hoisted_10, toDisplayString(region.name), 1)
                ], 42, _hoisted_7$1);
              }), 128))
            ]))
          ])), [
            [_directive_auto_animate]
          ]),
          unref(data) ? (openBlock(), createElementBlock("div", _hoisted_11, [
            createVNode(_component_MultiSelect, {
              selected: convertedSelections.value,
              "disable-search": "",
              "handle-select": (selectedRegion) => unref(uiStore).toggleRegion(selectedRegion.term_id),
              options: unref(data),
              "button-title": "Region",
              "key-field": "term_id",
              "display-key": "name",
              "trigger-class": "min-w-[240px] w-full md:w-0 mobile-filter-trigger",
              "content-class": "mobile-content"
            }, null, 8, ["selected", "handle-select", "options"])
          ])) : createCommentVNode("", true)
        ], 64);
      };
    }
  });
  const _hoisted_1$4 = { class: "px-2 max-sm:flex max-sm:flex-col max-sm:gap-4" };
  const _hoisted_2$2 = { class: "flex flex-row items-center justify-between p-2 sm:hidden" };
  const _hoisted_3$1 = { class: "mb-0 font-sans font-bold !text-primary" };
  const _hoisted_4$1 = { class: "flex flex-col gap-4 max-sm:!gap-0" };
  const _hoisted_5$1 = { class: "country-selector" };
  const _hoisted_6$1 = { class: "country-info" };
  const _sfc_main$4 = /* @__PURE__ */ defineComponent({
    __name: "MainApp",
    setup(__props) {
      const countryStore = useCountryStore();
      const uiStore = useUiStore();
      const showFilters = ref(false);
      return (_ctx, _cache2) => {
        const _component_OrderSelection = _sfc_main$8;
        const _component_RegionButtons = _sfc_main$5;
        const _component_CountryFilters = _sfc_main$6;
        const _component_CountryButtons = _sfc_main$7;
        const _component_CountryCompare = _sfc_main$d;
        const _directive_auto_animate = resolveDirective("auto-animate");
        return openBlock(), createElementBlock("div", _hoisted_1$4, [
          createBaseVNode("div", _hoisted_2$2, [
            !unref(countryStore).selectedCountry && unref(uiStore).searchText.length === 0 ? (openBlock(), createElementBlock("button", {
              key: 0,
              onClick: _cache2[0] || (_cache2[0] = ($event) => showFilters.value = !showFilters.value),
              class: "flex items-center gap-3 border-0 bg-transparent"
            }, [
              _cache2[1] || (_cache2[1] = createBaseVNode("i", { class: "fa-regular fa-sliders text-xl !text-primary" }, null, -1)),
              createBaseVNode("span", _hoisted_3$1, " Filter" + toDisplayString(unref(countryStore).selectedFilterCount <= 1 ? "" : "s") + " " + toDisplayString(unref(countryStore).hasFilters ? `(${unref(countryStore).selectedFilterCount})` : ""), 1)
            ])) : createCommentVNode("", true),
            !unref(countryStore).selectedCountry ? (openBlock(), createBlock(_component_OrderSelection, {
              key: 1,
              classes: "ml-auto w-fit sm:hidden"
            })) : createCommentVNode("", true)
          ]),
          withDirectives((openBlock(), createElementBlock("div", _hoisted_4$1, [
            withDirectives(createBaseVNode("section", {
              class: normalizeClass(["region-selector", showFilters.value ? "block" : "max-sm:hidden"])
            }, [
              createVNode(_component_RegionButtons)
            ], 2), [
              [vShow, !unref(countryStore).selectedCountry && unref(uiStore).searchText.length === 0]
            ]),
            withDirectives(createBaseVNode("section", {
              class: normalizeClass(["country-filters", showFilters.value ? "block" : "max-sm:hidden"])
            }, [
              createVNode(_component_CountryFilters)
            ], 2), [
              [vShow, !unref(countryStore).selectedCountry && unref(uiStore).searchText.length === 0]
            ]),
            createBaseVNode("section", _hoisted_5$1, [
              createVNode(_component_CountryButtons)
            ]),
            createBaseVNode("section", _hoisted_6$1, [
              createVNode(_component_CountryCompare)
            ])
          ])), [
            [_directive_auto_animate]
          ])
        ]);
      };
    }
  });
  const _hoisted_1$3 = { class: "single-column" };
  const _sfc_main$3 = /* @__PURE__ */ defineComponent({
    __name: "SingleCountry",
    props: {
      datacountry: {}
    },
    setup(__props) {
      return (_ctx, _cache2) => {
        const _component_CountrySingle = __unplugin_components_0$1;
        return openBlock(), createElementBlock("div", _hoisted_1$3, [
          createVNode(_component_CountrySingle, {
            country: _ctx.datacountry,
            columnclass: "single",
            size: "full"
          }, null, 8, ["country"])
        ]);
      };
    }
  });
  const _hoisted_1$2 = ["id", "href"];
  const _hoisted_2$1 = { class: "font-sans text-lg font-bold" };
  const _sfc_main$2 = /* @__PURE__ */ defineComponent({
    __name: "CountryDownloadButton",
    props: {
      country: {}
    },
    setup(__props) {
      const props = __props;
      const params = useUrlSearchParams();
      const location = useBrowserLocation();
      const buttonRef = ref(null);
      const buttonId = computed(() => `download-button-${props.country.code}`);
      const downloadUrl = computed(() => {
        return getApiUrl(`/countries/${props.country.code}/download?secret=${params.secret}`);
      });
      const isHighlighted = computed(() => {
        var _a2, _b2;
        const hash = ((_b2 = (_a2 = location.value) == null ? void 0 : _a2.hash) == null ? void 0 : _b2.slice(1)) || "";
        return hash === buttonId.value;
      });
      watch(
        () => isHighlighted.value,
        (newValue) => {
          if (newValue) {
            nextTick(() => {
              var _a2, _b2;
              (_a2 = buttonRef.value) == null ? void 0 : _a2.scrollIntoView({ behavior: "smooth", block: "center" });
              (_b2 = buttonRef.value) == null ? void 0 : _b2.focus();
            });
          }
        },
        { immediate: true }
      );
      return (_ctx, _cache2) => {
        return openBlock(), createElementBlock("a", {
          ref_key: "buttonRef",
          ref: buttonRef,
          id: buttonId.value,
          class: normalizeClass([
            "flex flex-row items-center justify-between rounded-lg !border !border-solid px-4 py-2 !text-primary transition-all duration-300",
            isHighlighted.value ? "scale-[1.002] !border-[#0565FF] bg-[#0565FF]/10 shadow-lg" : "!border-gray-light bg-white"
          ]),
          href: downloadUrl.value,
          target: "_blank",
          onClick: _cache2[0] || (_cache2[0] = //@ts-ignore
          (...args) => _ctx.handleAnalytics && _ctx.handleAnalytics(...args))
        }, [
          createBaseVNode("span", _hoisted_2$1, toDisplayString(_ctx.country.name), 1),
          _cache2[1] || (_cache2[1] = createBaseVNode("i", { class: "fa-regular fa-circle-arrow-down text-lg" }, null, -1))
        ], 10, _hoisted_1$2);
      };
    }
  });
  const _hoisted_1$1 = {
    key: 0,
    class: "flex flex-col gap-y-2"
  };
  const _hoisted_2 = { class: "flex flex-row flex-wrap gap-3" };
  const _hoisted_3 = ["href"];
  const _hoisted_4 = { class: "flex flex-col gap-4 pt-5" };
  const _hoisted_5 = ["id"];
  const _hoisted_6 = { class: "mb-0 mt-0 w-full font-sans text-xl font-semibold !text-primary" };
  const _hoisted_7 = { class: "grid gap-4 sm:grid-cols-2" };
  const _hoisted_8 = {
    key: 1,
    class: "flex flex-col gap-y-2"
  };
  const _sfc_main$1 = /* @__PURE__ */ defineComponent({
    __name: "DownloadCountryList",
    setup(__props) {
      const countryStore = useCountryStore();
      const location = useBrowserLocation();
      onMounted(() => {
        countryStore.fetchCountries();
      });
      const countryAlphabet = computed(() => {
        var _a2;
        if (!((_a2 = countryStore.countries) == null ? void 0 : _a2.length)) return [];
        const alpahbetSet = /* @__PURE__ */ new Set();
        countryStore.countries.forEach((country) => {
          alpahbetSet.add(country.name.charAt(0).toUpperCase());
        });
        return Array.from(alpahbetSet).toSorted((a2, b2) => a2.localeCompare(b2));
      });
      const currentLetter = computed(() => {
        var _a2, _b2;
        const hash = ((_b2 = (_a2 = location.value) == null ? void 0 : _a2.hash) == null ? void 0 : _b2.slice(1)) || "";
        return hash;
      });
      return (_ctx, _cache2) => {
        var _a2;
        const _component_CountryDownloadButton = _sfc_main$2;
        const _component_LoadingSpinner = __unplugin_components_0;
        return ((_a2 = unref(countryStore).countries) == null ? void 0 : _a2.length) ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
          _cache2[0] || (_cache2[0] = createBaseVNode("h2", { class: "font-sans font-bold !text-primary" }, "PDF download", -1)),
          createBaseVNode("div", _hoisted_2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(countryAlphabet), (char) => {
              return openBlock(), createElementBlock("a", {
                key: char,
                href: `#${char}`,
                class: "font-sans text-xl !text-primary no-underline hover:underline"
              }, toDisplayString(char), 9, _hoisted_3);
            }), 128))
          ]),
          createBaseVNode("div", _hoisted_4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(countryAlphabet), (char) => {
              return openBlock(), createElementBlock("div", {
                key: char,
                class: normalizeClass(["relative flex flex-col gap-3 rounded-[8px] p-4", { "border border-solid border-[#0565FF] bg-[#0565FF]/10": char === unref(currentLetter) }])
              }, [
                createBaseVNode("div", {
                  id: char,
                  class: "absolute top-[-150px]"
                }, null, 8, _hoisted_5),
                createBaseVNode("h3", _hoisted_6, toDisplayString(char), 1),
                createBaseVNode("div", _hoisted_7, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(countryStore).getCountriesByFirstLetter(char), (country) => {
                    return openBlock(), createBlock(_component_CountryDownloadButton, {
                      key: country.id,
                      country
                    }, null, 8, ["country"]);
                  }), 128))
                ])
              ], 2);
            }), 128))
          ])
        ])) : (openBlock(), createElementBlock("div", _hoisted_8, [
          createVNode(_component_LoadingSpinner, { class: "p-4 *:text-2xl" })
        ]));
      };
    }
  });
  const _hoisted_1 = {
    key: 1,
    class: "alignfull"
  };
  const _sfc_main = /* @__PURE__ */ defineComponent({
    __name: "DownloadPage",
    setup(__props) {
      const shouldFetch = ref(false);
      const shouldShow = ref(false);
      const params = useUrlSearchParams("history");
      const downloadSecret = useQuery({
        queryKey: ["downloadSecret"],
        queryFn: async () => {
          const response = await fetch(getApiUrl("/countries/downloadSecret"));
          if (!response.ok) throw new Error("Failed fetching downloadSecret");
          const rawData = await response.json();
          if (!rawData.data) throw new Error("Data not found");
          const { data } = rawData;
          if (!data) throw new Error("Data not found");
          const { secret } = data;
          return await decryptApiData(secret, false);
        },
        enabled: shouldFetch
      });
      watchEffect(() => {
        if (shouldFetch.value === true) return;
        if (params.secret && params.userId) {
          shouldFetch.value = true;
        }
      });
      watch(
        () => downloadSecret.data,
        () => {
          if (!params.secret || !params.userId) return;
          const { secret } = params;
          const { data } = downloadSecret;
          if (!data) return;
          const serverSecret = get(data);
          if (!serverSecret) return;
          if (serverSecret === secret) {
            shouldShow.value = true;
          } else {
            params.secret = void 0;
            params.userId = void 0;
            window.location.href = "https://opuscapita.com";
          }
        },
        {
          deep: true,
          immediate: true
        }
      );
      return (_ctx, _cache2) => {
        const _component_LoadingSpinner = __unplugin_components_0;
        const _component_DownloadCountryList = _sfc_main$1;
        return openBlock(), createElementBlock(Fragment, null, [
          unref(downloadSecret).status === "pending" ? (openBlock(), createBlock(_component_LoadingSpinner, {
            key: 0,
            class: "p-5 *:text-2xl"
          })) : createCommentVNode("", true),
          shouldShow.value ? (openBlock(), createElementBlock("div", _hoisted_1, [
            createVNode(_component_DownloadCountryList)
          ])) : createCommentVNode("", true)
        ], 64);
      };
    }
  });
  /*!
   * Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2025 Fonticons, Inc.
   */
  function _arrayLikeToArray(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _arrayWithHoles(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _arrayWithoutHoles(r2) {
    if (Array.isArray(r2)) return _arrayLikeToArray(r2);
  }
  function _classCallCheck(a2, n2) {
    if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }
  function _defineProperties(e2, r2) {
    for (var t2 = 0; t2 < r2.length; t2++) {
      var o2 = r2[t2];
      o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
    }
  }
  function _createClass(e2, r2, t2) {
    return _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", {
      writable: false
    }), e2;
  }
  function _createForOfIteratorHelper(r2, e2) {
    var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (!t2) {
      if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2) {
        t2 && (r2 = t2);
        var n2 = 0, F2 = function() {
        };
        return {
          s: F2,
          n: function() {
            return n2 >= r2.length ? {
              done: true
            } : {
              done: false,
              value: r2[n2++]
            };
          },
          e: function(r3) {
            throw r3;
          },
          f: F2
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o2, a2 = true, u2 = false;
    return {
      s: function() {
        t2 = t2.call(r2);
      },
      n: function() {
        var r3 = t2.next();
        return a2 = r3.done, r3;
      },
      e: function(r3) {
        u2 = true, o2 = r3;
      },
      f: function() {
        try {
          a2 || null == t2.return || t2.return();
        } finally {
          if (u2) throw o2;
        }
      }
    };
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = _toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r2] = t2, e2;
  }
  function _iterableToArray(r2) {
    if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) {
          if (Object(t2) !== t2) return;
          f2 = false;
        } else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2.return && (u2 = t2.return(), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e2, r2) {
    var t2 = Object.keys(e2);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e2);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2(e2) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e2, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e2;
  }
  function _slicedToArray(r2, e2) {
    return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
  }
  function _toConsumableArray(r2) {
    return _arrayWithoutHoles(r2) || _iterableToArray(r2) || _unsupportedIterableToArray(r2) || _nonIterableSpread();
  }
  function _toPrimitive(t2, r2) {
    if ("object" != typeof t2 || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2 || "default");
      if ("object" != typeof i2) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function _toPropertyKey(t2) {
    var i2 = _toPrimitive(t2, "string");
    return "symbol" == typeof i2 ? i2 : i2 + "";
  }
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }
  function _unsupportedIterableToArray(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
    }
  }
  var noop = function noop2() {
  };
  var _WINDOW = {};
  var _DOCUMENT = {};
  var _MUTATION_OBSERVER = null;
  var _PERFORMANCE = {
    mark: noop,
    measure: noop
  };
  try {
    if (typeof window !== "undefined") _WINDOW = window;
    if (typeof document !== "undefined") _DOCUMENT = document;
    if (typeof MutationObserver !== "undefined") _MUTATION_OBSERVER = MutationObserver;
    if (typeof performance !== "undefined") _PERFORMANCE = performance;
  } catch (e2) {
  }
  var _ref = _WINDOW.navigator || {}, _ref$userAgent = _ref.userAgent, userAgent = _ref$userAgent === void 0 ? "" : _ref$userAgent;
  var WINDOW = _WINDOW;
  var DOCUMENT = _DOCUMENT;
  var MUTATION_OBSERVER = _MUTATION_OBSERVER;
  var PERFORMANCE = _PERFORMANCE;
  !!WINDOW.document;
  var IS_DOM = !!DOCUMENT.documentElement && !!DOCUMENT.head && typeof DOCUMENT.addEventListener === "function" && typeof DOCUMENT.createElement === "function";
  var IS_IE = ~userAgent.indexOf("MSIE") || ~userAgent.indexOf("Trident/");
  var _dt;
  var E = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, _ = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i;
  var q = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    },
    slab: {
      "fa-regular": "regular",
      faslr: "regular"
    },
    "slab-press": {
      "fa-regular": "regular",
      faslpr: "regular"
    },
    thumbprint: {
      "fa-light": "light",
      fatl: "light"
    },
    whiteboard: {
      "fa-semibold": "semibold",
      fawsb: "semibold"
    },
    notdog: {
      "fa-solid": "solid",
      fans: "solid"
    },
    "notdog-duo": {
      "fa-solid": "solid",
      fands: "solid"
    },
    etch: {
      "fa-solid": "solid",
      faes: "solid"
    },
    jelly: {
      "fa-regular": "regular",
      fajr: "regular"
    },
    "jelly-fill": {
      "fa-regular": "regular",
      fajfr: "regular"
    },
    "jelly-duo": {
      "fa-regular": "regular",
      fajdr: "regular"
    },
    chisel: {
      "fa-regular": "regular",
      facr: "regular"
    },
    utility: {
      "fa-semibold": "semibold",
      fausb: "semibold"
    },
    "utility-duo": {
      "fa-semibold": "semibold",
      faudsb: "semibold"
    },
    "utility-fill": {
      "fa-semibold": "semibold",
      faufsb: "semibold"
    }
  }, H = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, Q = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"];
  var i = "classic", t = "duotone", d = "sharp", l = "sharp-duotone", f = "chisel", n = "etch", h = "jelly", o = "jelly-duo", u = "jelly-fill", g = "notdog", s = "notdog-duo", y = "slab", m = "slab-press", e = "thumbprint", p = "utility", a = "utility-duo", w = "utility-fill", x = "whiteboard", b = "Classic", c = "Duotone", I = "Sharp", F = "Sharp Duotone", v = "Chisel", S = "Etch", A = "Jelly", P = "Jelly Duo", j = "Jelly Fill", B = "Notdog", N = "Notdog Duo", k = "Slab", D = "Slab Press", T = "Thumbprint", C = "Utility", W = "Utility Duo", K = "Utility Fill", R = "Whiteboard", rt = [i, t, d, l, f, n, h, o, u, g, s, y, m, e, p, a, w, x];
  _dt = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_dt, i, b), t, c), d, I), l, F), f, v), n, S), h, A), o, P), u, j), g, B), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_dt, s, N), y, k), m, D), e, T), p, C), a, W), w, K), x, R);
  var gt = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    slab: {
      400: "faslr"
    },
    "slab-press": {
      400: "faslpr"
    },
    whiteboard: {
      600: "fawsb"
    },
    thumbprint: {
      300: "fatl"
    },
    notdog: {
      900: "fans"
    },
    "notdog-duo": {
      900: "fands"
    },
    etch: {
      900: "faes"
    },
    chisel: {
      400: "facr"
    },
    jelly: {
      400: "fajr"
    },
    "jelly-fill": {
      400: "fajfr"
    },
    "jelly-duo": {
      400: "fajdr"
    },
    utility: {
      600: "fausb"
    },
    "utility-duo": {
      600: "faudsb"
    },
    "utility-fill": {
      600: "faufsb"
    }
  };
  var Ct = {
    "Font Awesome 7 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 7 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 7 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 7 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 7 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 7 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    "Font Awesome 7 Jelly": {
      400: "fajr",
      normal: "fajr"
    },
    "Font Awesome 7 Jelly Fill": {
      400: "fajfr",
      normal: "fajfr"
    },
    "Font Awesome 7 Jelly Duo": {
      400: "fajdr",
      normal: "fajdr"
    },
    "Font Awesome 7 Slab": {
      400: "faslr",
      normal: "faslr"
    },
    "Font Awesome 7 Slab Press": {
      400: "faslpr",
      normal: "faslpr"
    },
    "Font Awesome 7 Thumbprint": {
      300: "fatl",
      normal: "fatl"
    },
    "Font Awesome 7 Notdog": {
      900: "fans",
      normal: "fans"
    },
    "Font Awesome 7 Notdog Duo": {
      900: "fands",
      normal: "fands"
    },
    "Font Awesome 7 Etch": {
      900: "faes",
      normal: "faes"
    },
    "Font Awesome 7 Chisel": {
      400: "facr",
      normal: "facr"
    },
    "Font Awesome 7 Whiteboard": {
      600: "fawsb",
      normal: "fawsb"
    },
    "Font Awesome 7 Utility": {
      600: "fausb",
      normal: "fausb"
    },
    "Font Awesome 7 Utility Duo": {
      600: "faudsb",
      normal: "faudsb"
    },
    "Font Awesome 7 Utility Fill": {
      600: "faufsb",
      normal: "faufsb"
    }
  };
  var Ut = /* @__PURE__ */ new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["chisel", {
    defaultShortPrefixId: "facr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["etch", {
    defaultShortPrefixId: "faes",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["jelly", {
    defaultShortPrefixId: "fajr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-duo", {
    defaultShortPrefixId: "fajdr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-fill", {
    defaultShortPrefixId: "fajfr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["notdog", {
    defaultShortPrefixId: "fans",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["notdog-duo", {
    defaultShortPrefixId: "fands",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["slab", {
    defaultShortPrefixId: "faslr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["slab-press", {
    defaultShortPrefixId: "faslpr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["thumbprint", {
    defaultShortPrefixId: "fatl",
    defaultStyleId: "light",
    styleIds: ["light"],
    futureStyleIds: [],
    defaultFontWeight: 300
  }], ["utility", {
    defaultShortPrefixId: "fausb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["utility-duo", {
    defaultShortPrefixId: "faudsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["utility-fill", {
    defaultShortPrefixId: "faufsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["whiteboard", {
    defaultShortPrefixId: "fawsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }]]), _t = {
    chisel: {
      regular: "facr"
    },
    classic: {
      brands: "fab",
      light: "fal",
      regular: "far",
      solid: "fas",
      thin: "fat"
    },
    duotone: {
      light: "fadl",
      regular: "fadr",
      solid: "fad",
      thin: "fadt"
    },
    etch: {
      solid: "faes"
    },
    jelly: {
      regular: "fajr"
    },
    "jelly-duo": {
      regular: "fajdr"
    },
    "jelly-fill": {
      regular: "fajfr"
    },
    notdog: {
      solid: "fans"
    },
    "notdog-duo": {
      solid: "fands"
    },
    sharp: {
      light: "fasl",
      regular: "fasr",
      solid: "fass",
      thin: "fast"
    },
    "sharp-duotone": {
      light: "fasdl",
      regular: "fasdr",
      solid: "fasds",
      thin: "fasdt"
    },
    slab: {
      regular: "faslr"
    },
    "slab-press": {
      regular: "faslpr"
    },
    thumbprint: {
      light: "fatl"
    },
    utility: {
      semibold: "fausb"
    },
    "utility-duo": {
      semibold: "faudsb"
    },
    "utility-fill": {
      semibold: "faufsb"
    },
    whiteboard: {
      semibold: "fawsb"
    }
  };
  var Yt = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], qt = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  }, Ht = ["kit"];
  var L = "kit", r = "kit-duotone", U = "Kit", J = "Kit Duotone";
  _defineProperty(_defineProperty({}, L, U), r, J);
  var ol = {
    kit: {
      "fa-kit": "fak"
    },
    "kit-duotone": {
      "fa-kit-duotone": "fakd"
    }
  };
  var dl = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  }, fl = {
    kit: {
      fak: "fa-kit"
    },
    "kit-duotone": {
      fakd: "fa-kit-duotone"
    }
  };
  var ul = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  };
  var _ml;
  var l$1 = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, f$1 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"];
  var n$1 = "classic", o$1 = "duotone", u$1 = "sharp", s$1 = "sharp-duotone", h$1 = "chisel", g$1 = "etch", y$1 = "jelly", e$1 = "jelly-duo", m$1 = "jelly-fill", p$1 = "notdog", a$1 = "notdog-duo", w$1 = "slab", b$1 = "slab-press", r$1 = "thumbprint", c$1 = "utility", i$1 = "utility-duo", x$1 = "utility-fill", I$1 = "whiteboard", F$1 = "Classic", v$1 = "Duotone", S$1 = "Sharp", A$1 = "Sharp Duotone", P$1 = "Chisel", j$1 = "Etch", B$1 = "Jelly", N$1 = "Jelly Duo", k$1 = "Jelly Fill", D$1 = "Notdog", C$1 = "Notdog Duo", T$1 = "Slab", L$1 = "Slab Press", W$1 = "Thumbprint", R$1 = "Utility", K$1 = "Utility Duo", U$1 = "Utility Fill", J$1 = "Whiteboard";
  _ml = {}, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ml, n$1, F$1), o$1, v$1), u$1, S$1), s$1, A$1), h$1, P$1), g$1, j$1), y$1, B$1), e$1, N$1), m$1, k$1), p$1, D$1), _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_ml, a$1, C$1), w$1, T$1), b$1, L$1), r$1, W$1), c$1, R$1), i$1, K$1), x$1, U$1), I$1, J$1);
  var E$1 = "kit", d$1 = "kit-duotone", _$1 = "Kit", M$1 = "Kit Duotone";
  _defineProperty(_defineProperty({}, E$1, _$1), d$1, M$1);
  var $t$1 = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    },
    slab: {
      "fa-regular": "faslr"
    },
    "slab-press": {
      "fa-regular": "faslpr"
    },
    whiteboard: {
      "fa-semibold": "fawsb"
    },
    thumbprint: {
      "fa-light": "fatl"
    },
    notdog: {
      "fa-solid": "fans"
    },
    "notdog-duo": {
      "fa-solid": "fands"
    },
    etch: {
      "fa-solid": "faes"
    },
    jelly: {
      "fa-regular": "fajr"
    },
    "jelly-fill": {
      "fa-regular": "fajfr"
    },
    "jelly-duo": {
      "fa-regular": "fajdr"
    },
    chisel: {
      "fa-regular": "facr"
    },
    utility: {
      "fa-semibold": "fausb"
    },
    "utility-duo": {
      "fa-semibold": "faudsb"
    },
    "utility-fill": {
      "fa-semibold": "faufsb"
    }
  }, z = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
    slab: ["faslr"],
    "slab-press": ["faslpr"],
    whiteboard: ["fawsb"],
    thumbprint: ["fatl"],
    notdog: ["fans"],
    "notdog-duo": ["fands"],
    etch: ["faes"],
    jelly: ["fajr"],
    "jelly-fill": ["fajfr"],
    "jelly-duo": ["fajdr"],
    chisel: ["facr"],
    utility: ["fausb"],
    "utility-duo": ["faudsb"],
    "utility-fill": ["faufsb"]
  }, Ht$1 = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    },
    slab: {
      faslr: "fa-regular"
    },
    "slab-press": {
      faslpr: "fa-regular"
    },
    whiteboard: {
      fawsb: "fa-semibold"
    },
    thumbprint: {
      fatl: "fa-light"
    },
    notdog: {
      fans: "fa-solid"
    },
    "notdog-duo": {
      fands: "fa-solid"
    },
    etch: {
      faes: "fa-solid"
    },
    jelly: {
      fajr: "fa-regular"
    },
    "jelly-fill": {
      fajfr: "fa-regular"
    },
    "jelly-duo": {
      fajdr: "fa-regular"
    },
    chisel: {
      facr: "fa-regular"
    },
    utility: {
      fausb: "fa-semibold"
    },
    "utility-duo": {
      faudsb: "fa-semibold"
    },
    "utility-fill": {
      faufsb: "fa-semibold"
    }
  }, Y$1 = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], Zt$1 = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(f$1, Y$1), G$1 = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], O$1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], V$1 = O$1.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), $$1 = ["aw", "fw", "pull-left", "pull-right"], to = [].concat(_toConsumableArray(Object.keys(z)), G$1, $$1, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", l$1.GROUP, l$1.SWAP_OPACITY, l$1.PRIMARY, l$1.SECONDARY]).concat(O$1.map(function(t2) {
    return "".concat(t2, "x");
  })).concat(V$1.map(function(t2) {
    return "w-".concat(t2);
  }));
  var ro = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  };
  var NAMESPACE_IDENTIFIER = "___FONT_AWESOME___";
  var UNITS_IN_GRID = 16;
  var DEFAULT_CSS_PREFIX = "fa";
  var DEFAULT_REPLACEMENT_CLASS = "svg-inline--fa";
  var DATA_FA_I2SVG = "data-fa-i2svg";
  var DATA_FA_PSEUDO_ELEMENT = "data-fa-pseudo-element";
  var DATA_FA_PSEUDO_ELEMENT_PENDING = "data-fa-pseudo-element-pending";
  var DATA_PREFIX = "data-prefix";
  var DATA_ICON = "data-icon";
  var HTML_CLASS_I2SVG_BASE_CLASS = "fontawesome-i2svg";
  var MUTATION_APPROACH_ASYNC = "async";
  var TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS = ["HTML", "HEAD", "STYLE", "SCRIPT"];
  var PSEUDO_ELEMENTS = ["::before", "::after", ":before", ":after"];
  var PRODUCTION = function() {
    try {
      return true;
    } catch (e$$1) {
      return false;
    }
  }();
  function familyProxy(obj) {
    return new Proxy(obj, {
      get: function get2(target2, prop) {
        return prop in target2 ? target2[prop] : target2[i];
      }
    });
  }
  var _PREFIX_TO_STYLE = _objectSpread2({}, q);
  _PREFIX_TO_STYLE[i] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    "fa-duotone": "duotone"
  }), q[i]), qt["kit"]), qt["kit-duotone"]);
  var PREFIX_TO_STYLE = familyProxy(_PREFIX_TO_STYLE);
  var _STYLE_TO_PREFIX = _objectSpread2({}, _t);
  _STYLE_TO_PREFIX[i] = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    duotone: "fad"
  }), _STYLE_TO_PREFIX[i]), ul["kit"]), ul["kit-duotone"]);
  var STYLE_TO_PREFIX = familyProxy(_STYLE_TO_PREFIX);
  var _PREFIX_TO_LONG_STYLE = _objectSpread2({}, Ht$1);
  _PREFIX_TO_LONG_STYLE[i] = _objectSpread2(_objectSpread2({}, _PREFIX_TO_LONG_STYLE[i]), fl["kit"]);
  var PREFIX_TO_LONG_STYLE = familyProxy(_PREFIX_TO_LONG_STYLE);
  var _LONG_STYLE_TO_PREFIX = _objectSpread2({}, $t$1);
  _LONG_STYLE_TO_PREFIX[i] = _objectSpread2(_objectSpread2({}, _LONG_STYLE_TO_PREFIX[i]), ol["kit"]);
  familyProxy(_LONG_STYLE_TO_PREFIX);
  var ICON_SELECTION_SYNTAX_PATTERN = E;
  var LAYERS_TEXT_CLASSNAME = "fa-layers-text";
  var FONT_FAMILY_PATTERN = _;
  var _FONT_WEIGHT_TO_PREFIX = _objectSpread2({}, gt);
  familyProxy(_FONT_WEIGHT_TO_PREFIX);
  var ATTRIBUTES_WATCHED_FOR_MUTATION = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"];
  var DUOTONE_CLASSES = H;
  var RESERVED_CLASSES = [].concat(_toConsumableArray(Ht), _toConsumableArray(to));
  var initial = WINDOW.FontAwesomeConfig || {};
  function getAttrConfig(attr) {
    var element = DOCUMENT.querySelector("script[" + attr + "]");
    if (element) {
      return element.getAttribute(attr);
    }
  }
  function coerce(val) {
    if (val === "") return true;
    if (val === "false") return false;
    if (val === "true") return true;
    return val;
  }
  if (DOCUMENT && typeof DOCUMENT.querySelector === "function") {
    var attrs = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    attrs.forEach(function(_ref2) {
      var _ref22 = _slicedToArray(_ref2, 2), attr = _ref22[0], key = _ref22[1];
      var val = coerce(getAttrConfig(attr));
      if (val !== void 0 && val !== null) {
        initial[key] = val;
      }
    });
  }
  var _default = {
    styleDefault: "solid",
    familyDefault: i,
    cssPrefix: DEFAULT_CSS_PREFIX,
    replacementClass: DEFAULT_REPLACEMENT_CLASS,
    autoReplaceSvg: true,
    autoAddCss: true,
    searchPseudoElements: false,
    searchPseudoElementsWarnings: true,
    searchPseudoElementsFullScan: false,
    observeMutations: true,
    mutateApproach: "async",
    keepOriginalSource: true,
    measurePerformance: false,
    showMissingIcons: true
  };
  if (initial.familyPrefix) {
    initial.cssPrefix = initial.familyPrefix;
  }
  var _config = _objectSpread2(_objectSpread2({}, _default), initial);
  if (!_config.autoReplaceSvg) _config.observeMutations = false;
  var config = {};
  Object.keys(_default).forEach(function(key) {
    Object.defineProperty(config, key, {
      enumerable: true,
      set: function set2(val) {
        _config[key] = val;
        _onChangeCb.forEach(function(cb) {
          return cb(config);
        });
      },
      get: function get2() {
        return _config[key];
      }
    });
  });
  Object.defineProperty(config, "familyPrefix", {
    enumerable: true,
    set: function set(val) {
      _config.cssPrefix = val;
      _onChangeCb.forEach(function(cb) {
        return cb(config);
      });
    },
    get: function get2() {
      return _config.cssPrefix;
    }
  });
  WINDOW.FontAwesomeConfig = config;
  var _onChangeCb = [];
  function onChange(cb) {
    _onChangeCb.push(cb);
    return function() {
      _onChangeCb.splice(_onChangeCb.indexOf(cb), 1);
    };
  }
  var d$2 = UNITS_IN_GRID;
  var meaninglessTransform = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: false,
    flipY: false
  };
  function insertCss(css2) {
    if (!css2 || !IS_DOM) {
      return;
    }
    var style = DOCUMENT.createElement("style");
    style.setAttribute("type", "text/css");
    style.innerHTML = css2;
    var headChildren = DOCUMENT.head.childNodes;
    var beforeChild = null;
    for (var i2 = headChildren.length - 1; i2 > -1; i2--) {
      var child = headChildren[i2];
      var tagName = (child.tagName || "").toUpperCase();
      if (["STYLE", "LINK"].indexOf(tagName) > -1) {
        beforeChild = child;
      }
    }
    DOCUMENT.head.insertBefore(style, beforeChild);
    return css2;
  }
  var idPool = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  function nextUniqueId() {
    var size2 = 12;
    var id = "";
    while (size2-- > 0) {
      id += idPool[Math.random() * 62 | 0];
    }
    return id;
  }
  function toArray(obj) {
    var array = [];
    for (var i2 = (obj || []).length >>> 0; i2--; ) {
      array[i2] = obj[i2];
    }
    return array;
  }
  function classArray(node) {
    if (node.classList) {
      return toArray(node.classList);
    } else {
      return (node.getAttribute("class") || "").split(" ").filter(function(i2) {
        return i2;
      });
    }
  }
  function htmlEscape(str) {
    return "".concat(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function joinAttributes(attributes) {
    return Object.keys(attributes || {}).reduce(function(acc, attributeName) {
      return acc + "".concat(attributeName, '="').concat(htmlEscape(attributes[attributeName]), '" ');
    }, "").trim();
  }
  function joinStyles(styles2) {
    return Object.keys(styles2 || {}).reduce(function(acc, styleName) {
      return acc + "".concat(styleName, ": ").concat(styles2[styleName].trim(), ";");
    }, "");
  }
  function transformIsMeaningful(transform) {
    return transform.size !== meaninglessTransform.size || transform.x !== meaninglessTransform.x || transform.y !== meaninglessTransform.y || transform.rotate !== meaninglessTransform.rotate || transform.flipX || transform.flipY;
  }
  function transformForSvg(_ref2) {
    var transform = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
    var outer = {
      transform: "translate(".concat(containerWidth / 2, " 256)")
    };
    var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
    var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
    var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
    var inner = {
      transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
    };
    var path = {
      transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
    };
    return {
      outer,
      inner,
      path
    };
  }
  function transformForCss(_ref2) {
    var transform = _ref2.transform, _ref2$width = _ref2.width, width = _ref2$width === void 0 ? UNITS_IN_GRID : _ref2$width, _ref2$height = _ref2.height, height = _ref2$height === void 0 ? UNITS_IN_GRID : _ref2$height, _ref2$startCentered = _ref2.startCentered, startCentered = _ref2$startCentered === void 0 ? false : _ref2$startCentered;
    var val = "";
    if (startCentered && IS_IE) {
      val += "translate(".concat(transform.x / d$2 - width / 2, "em, ").concat(transform.y / d$2 - height / 2, "em) ");
    } else if (startCentered) {
      val += "translate(calc(-50% + ".concat(transform.x / d$2, "em), calc(-50% + ").concat(transform.y / d$2, "em)) ");
    } else {
      val += "translate(".concat(transform.x / d$2, "em, ").concat(transform.y / d$2, "em) ");
    }
    val += "scale(".concat(transform.size / d$2 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / d$2 * (transform.flipY ? -1 : 1), ") ");
    val += "rotate(".concat(transform.rotate, "deg) ");
    return val;
  }
  var baseStyles = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
  function css() {
    var dcp = DEFAULT_CSS_PREFIX;
    var drc = DEFAULT_REPLACEMENT_CLASS;
    var fp = config.cssPrefix;
    var rc = config.replacementClass;
    var s2 = baseStyles;
    if (fp !== dcp || rc !== drc) {
      var dPatt = new RegExp("\\.".concat(dcp, "\\-"), "g");
      var customPropPatt = new RegExp("\\--".concat(dcp, "\\-"), "g");
      var rPatt = new RegExp("\\.".concat(drc), "g");
      s2 = s2.replace(dPatt, ".".concat(fp, "-")).replace(customPropPatt, "--".concat(fp, "-")).replace(rPatt, ".".concat(rc));
    }
    return s2;
  }
  var _cssInserted = false;
  function ensureCss() {
    if (config.autoAddCss && !_cssInserted) {
      insertCss(css());
      _cssInserted = true;
    }
  }
  var InjectCSS = {
    mixout: function mixout() {
      return {
        dom: {
          css,
          insertCss: ensureCss
        }
      };
    },
    hooks: function hooks() {
      return {
        beforeDOMElementCreation: function beforeDOMElementCreation() {
          ensureCss();
        },
        beforeI2svg: function beforeI2svg() {
          ensureCss();
        }
      };
    }
  };
  var w$2 = WINDOW || {};
  if (!w$2[NAMESPACE_IDENTIFIER]) w$2[NAMESPACE_IDENTIFIER] = {};
  if (!w$2[NAMESPACE_IDENTIFIER].styles) w$2[NAMESPACE_IDENTIFIER].styles = {};
  if (!w$2[NAMESPACE_IDENTIFIER].hooks) w$2[NAMESPACE_IDENTIFIER].hooks = {};
  if (!w$2[NAMESPACE_IDENTIFIER].shims) w$2[NAMESPACE_IDENTIFIER].shims = [];
  var namespace = w$2[NAMESPACE_IDENTIFIER];
  var functions = [];
  var _listener = function listener() {
    DOCUMENT.removeEventListener("DOMContentLoaded", _listener);
    loaded = 1;
    functions.map(function(fn) {
      return fn();
    });
  };
  var loaded = false;
  if (IS_DOM) {
    loaded = (DOCUMENT.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(DOCUMENT.readyState);
    if (!loaded) DOCUMENT.addEventListener("DOMContentLoaded", _listener);
  }
  function domready(fn) {
    if (!IS_DOM) return;
    loaded ? setTimeout(fn, 0) : functions.push(fn);
  }
  function toHtml(abstractNodes) {
    var tag = abstractNodes.tag, _abstractNodes$attrib = abstractNodes.attributes, attributes = _abstractNodes$attrib === void 0 ? {} : _abstractNodes$attrib, _abstractNodes$childr = abstractNodes.children, children = _abstractNodes$childr === void 0 ? [] : _abstractNodes$childr;
    if (typeof abstractNodes === "string") {
      return htmlEscape(abstractNodes);
    } else {
      return "<".concat(tag, " ").concat(joinAttributes(attributes), ">").concat(children.map(toHtml).join(""), "</").concat(tag, ">");
    }
  }
  function iconFromMapping(mapping, prefix, iconName) {
    if (mapping && mapping[prefix] && mapping[prefix][iconName]) {
      return {
        prefix,
        iconName,
        icon: mapping[prefix][iconName]
      };
    }
  }
  var reduce = function fastReduceObject(subject, fn, initialValue, thisContext) {
    var keys = Object.keys(subject), length = keys.length, iterator2 = fn, i2, key, result;
    if (initialValue === void 0) {
      i2 = 1;
      result = subject[keys[0]];
    } else {
      i2 = 0;
      result = initialValue;
    }
    for (; i2 < length; i2++) {
      key = keys[i2];
      result = iterator2(result, subject[key], key, subject);
    }
    return result;
  };
  function toHex(unicode) {
    if (_toConsumableArray(unicode).length !== 1) return null;
    return unicode.codePointAt(0).toString(16);
  }
  function normalizeIcons(icons) {
    return Object.keys(icons).reduce(function(acc, iconName) {
      var icon3 = icons[iconName];
      var expanded = !!icon3.icon;
      if (expanded) {
        acc[icon3.iconName] = icon3.icon;
      } else {
        acc[iconName] = icon3;
      }
      return acc;
    }, {});
  }
  function defineIcons(prefix, icons) {
    var params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _params$skipHooks = params.skipHooks, skipHooks = _params$skipHooks === void 0 ? false : _params$skipHooks;
    var normalized = normalizeIcons(icons);
    if (typeof namespace.hooks.addPack === "function" && !skipHooks) {
      namespace.hooks.addPack(prefix, normalizeIcons(icons));
    } else {
      namespace.styles[prefix] = _objectSpread2(_objectSpread2({}, namespace.styles[prefix] || {}), normalized);
    }
    if (prefix === "fas") {
      defineIcons("fa", icons);
    }
  }
  var styles = namespace.styles, shims = namespace.shims;
  var FAMILY_NAMES = Object.keys(PREFIX_TO_LONG_STYLE);
  var PREFIXES_FOR_FAMILY = FAMILY_NAMES.reduce(function(acc, familyId) {
    acc[familyId] = Object.keys(PREFIX_TO_LONG_STYLE[familyId]);
    return acc;
  }, {});
  var _defaultUsablePrefix = null;
  var _byUnicode = {};
  var _byLigature = {};
  var _byOldName = {};
  var _byOldUnicode = {};
  var _byAlias = {};
  function isReserved(name) {
    return ~RESERVED_CLASSES.indexOf(name);
  }
  function getIconName(cssPrefix, cls) {
    var parts = cls.split("-");
    var prefix = parts[0];
    var iconName = parts.slice(1).join("-");
    if (prefix === cssPrefix && iconName !== "" && !isReserved(iconName)) {
      return iconName;
    } else {
      return null;
    }
  }
  var build = function build2() {
    var lookup = function lookup2(reducer) {
      return reduce(styles, function(o$$1, style, prefix) {
        o$$1[prefix] = reduce(style, reducer, {});
        return o$$1;
      }, {});
    };
    _byUnicode = lookup(function(acc, icon3, iconName) {
      if (icon3[3]) {
        acc[icon3[3]] = iconName;
      }
      if (icon3[2]) {
        var aliases = icon3[2].filter(function(a$$1) {
          return typeof a$$1 === "number";
        });
        aliases.forEach(function(alias) {
          acc[alias.toString(16)] = iconName;
        });
      }
      return acc;
    });
    _byLigature = lookup(function(acc, icon3, iconName) {
      acc[iconName] = iconName;
      if (icon3[2]) {
        var aliases = icon3[2].filter(function(a$$1) {
          return typeof a$$1 === "string";
        });
        aliases.forEach(function(alias) {
          acc[alias] = iconName;
        });
      }
      return acc;
    });
    _byAlias = lookup(function(acc, icon3, iconName) {
      var aliases = icon3[2];
      acc[iconName] = iconName;
      aliases.forEach(function(alias) {
        acc[alias] = iconName;
      });
      return acc;
    });
    var hasRegular = "far" in styles || config.autoFetchSvg;
    var shimLookups = reduce(shims, function(acc, shim) {
      var maybeNameMaybeUnicode = shim[0];
      var prefix = shim[1];
      var iconName = shim[2];
      if (prefix === "far" && !hasRegular) {
        prefix = "fas";
      }
      if (typeof maybeNameMaybeUnicode === "string") {
        acc.names[maybeNameMaybeUnicode] = {
          prefix,
          iconName
        };
      }
      if (typeof maybeNameMaybeUnicode === "number") {
        acc.unicodes[maybeNameMaybeUnicode.toString(16)] = {
          prefix,
          iconName
        };
      }
      return acc;
    }, {
      names: {},
      unicodes: {}
    });
    _byOldName = shimLookups.names;
    _byOldUnicode = shimLookups.unicodes;
    _defaultUsablePrefix = getCanonicalPrefix(config.styleDefault, {
      family: config.familyDefault
    });
  };
  onChange(function(c$$1) {
    _defaultUsablePrefix = getCanonicalPrefix(c$$1.styleDefault, {
      family: config.familyDefault
    });
  });
  build();
  function byUnicode(prefix, unicode) {
    return (_byUnicode[prefix] || {})[unicode];
  }
  function byLigature(prefix, ligature) {
    return (_byLigature[prefix] || {})[ligature];
  }
  function byAlias(prefix, alias) {
    return (_byAlias[prefix] || {})[alias];
  }
  function byOldName(name) {
    return _byOldName[name] || {
      prefix: null,
      iconName: null
    };
  }
  function byOldUnicode(unicode) {
    var oldUnicode = _byOldUnicode[unicode];
    var newUnicode = byUnicode("fas", unicode);
    return oldUnicode || (newUnicode ? {
      prefix: "fas",
      iconName: newUnicode
    } : null) || {
      prefix: null,
      iconName: null
    };
  }
  function getDefaultUsablePrefix() {
    return _defaultUsablePrefix;
  }
  var emptyCanonicalIcon = function emptyCanonicalIcon2() {
    return {
      prefix: null,
      iconName: null,
      rest: []
    };
  };
  function getFamilyId(values) {
    var family = i;
    var famProps = FAMILY_NAMES.reduce(function(acc, familyId) {
      acc[familyId] = "".concat(config.cssPrefix, "-").concat(familyId);
      return acc;
    }, {});
    rt.forEach(function(familyId) {
      if (values.includes(famProps[familyId]) || values.some(function(v$$1) {
        return PREFIXES_FOR_FAMILY[familyId].includes(v$$1);
      })) {
        family = familyId;
      }
    });
    return family;
  }
  function getCanonicalPrefix(styleOrPrefix) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _params$family = params.family, family = _params$family === void 0 ? i : _params$family;
    var style = PREFIX_TO_STYLE[family][styleOrPrefix];
    if (family === t && !styleOrPrefix) {
      return "fad";
    }
    var prefix = STYLE_TO_PREFIX[family][styleOrPrefix] || STYLE_TO_PREFIX[family][style];
    var defined = styleOrPrefix in namespace.styles ? styleOrPrefix : null;
    var result = prefix || defined || null;
    return result;
  }
  function moveNonFaClassesToRest(classNames) {
    var rest = [];
    var iconName = null;
    classNames.forEach(function(cls) {
      var result = getIconName(config.cssPrefix, cls);
      if (result) {
        iconName = result;
      } else if (cls) {
        rest.push(cls);
      }
    });
    return {
      iconName,
      rest
    };
  }
  function sortedUniqueValues(arr) {
    return arr.sort().filter(function(value, index, arr2) {
      return arr2.indexOf(value) === index;
    });
  }
  var _faCombinedClasses = Zt$1.concat(Yt);
  function getCanonicalIcon(values) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _params$skipLookups = params.skipLookups, skipLookups = _params$skipLookups === void 0 ? false : _params$skipLookups;
    var givenPrefix = null;
    var faStyleOrFamilyClasses = sortedUniqueValues(values.filter(function(cls) {
      return _faCombinedClasses.includes(cls);
    }));
    var nonStyleOrFamilyClasses = sortedUniqueValues(values.filter(function(cls) {
      return !_faCombinedClasses.includes(cls);
    }));
    var faStyles = faStyleOrFamilyClasses.filter(function(cls) {
      givenPrefix = cls;
      return !Q.includes(cls);
    });
    var _faStyles = _slicedToArray(faStyles, 1), _faStyles$ = _faStyles[0], styleFromValues = _faStyles$ === void 0 ? null : _faStyles$;
    var family = getFamilyId(faStyleOrFamilyClasses);
    var canonical = _objectSpread2(_objectSpread2({}, moveNonFaClassesToRest(nonStyleOrFamilyClasses)), {}, {
      prefix: getCanonicalPrefix(styleFromValues, {
        family
      })
    });
    return _objectSpread2(_objectSpread2(_objectSpread2({}, canonical), getDefaultCanonicalPrefix({
      values,
      family,
      styles,
      config,
      canonical,
      givenPrefix
    })), applyShimAndAlias(skipLookups, givenPrefix, canonical));
  }
  function applyShimAndAlias(skipLookups, givenPrefix, canonical) {
    var prefix = canonical.prefix, iconName = canonical.iconName;
    if (skipLookups || !prefix || !iconName) {
      return {
        prefix,
        iconName
      };
    }
    var shim = givenPrefix === "fa" ? byOldName(iconName) : {};
    var aliasIconName = byAlias(prefix, iconName);
    iconName = shim.iconName || aliasIconName || iconName;
    prefix = shim.prefix || prefix;
    if (prefix === "far" && !styles["far"] && styles["fas"] && !config.autoFetchSvg) {
      prefix = "fas";
    }
    return {
      prefix,
      iconName
    };
  }
  var newCanonicalFamilies = rt.filter(function(familyId) {
    return familyId !== i || familyId !== t;
  });
  var newCanonicalStyles = Object.keys(Ht$1).filter(function(key) {
    return key !== i;
  }).map(function(key) {
    return Object.keys(Ht$1[key]);
  }).flat();
  function getDefaultCanonicalPrefix(prefixOptions) {
    var values = prefixOptions.values, family = prefixOptions.family, canonical = prefixOptions.canonical, _prefixOptions$givenP = prefixOptions.givenPrefix, givenPrefix = _prefixOptions$givenP === void 0 ? "" : _prefixOptions$givenP, _prefixOptions$styles = prefixOptions.styles, styles2 = _prefixOptions$styles === void 0 ? {} : _prefixOptions$styles, _prefixOptions$config = prefixOptions.config, config$$1 = _prefixOptions$config === void 0 ? {} : _prefixOptions$config;
    var isDuotoneFamily = family === t;
    var valuesHasDuotone = values.includes("fa-duotone") || values.includes("fad");
    var defaultFamilyIsDuotone = config$$1.familyDefault === "duotone";
    var canonicalPrefixIsDuotone = canonical.prefix === "fad" || canonical.prefix === "fa-duotone";
    if (!isDuotoneFamily && (valuesHasDuotone || defaultFamilyIsDuotone || canonicalPrefixIsDuotone)) {
      canonical.prefix = "fad";
    }
    if (values.includes("fa-brands") || values.includes("fab")) {
      canonical.prefix = "fab";
    }
    if (!canonical.prefix && newCanonicalFamilies.includes(family)) {
      var validPrefix = Object.keys(styles2).find(function(key) {
        return newCanonicalStyles.includes(key);
      });
      if (validPrefix || config$$1.autoFetchSvg) {
        var defaultPrefix = Ut.get(family).defaultShortPrefixId;
        canonical.prefix = defaultPrefix;
        canonical.iconName = byAlias(canonical.prefix, canonical.iconName) || canonical.iconName;
      }
    }
    if (canonical.prefix === "fa" || givenPrefix === "fa") {
      canonical.prefix = getDefaultUsablePrefix() || "fas";
    }
    return canonical;
  }
  var Library = /* @__PURE__ */ function() {
    function Library2() {
      _classCallCheck(this, Library2);
      this.definitions = {};
    }
    return _createClass(Library2, [{
      key: "add",
      value: function add2() {
        var _this = this;
        for (var _len = arguments.length, definitions = new Array(_len), _key = 0; _key < _len; _key++) {
          definitions[_key] = arguments[_key];
        }
        var additions = definitions.reduce(this._pullDefinitions, {});
        Object.keys(additions).forEach(function(key) {
          _this.definitions[key] = _objectSpread2(_objectSpread2({}, _this.definitions[key] || {}), additions[key]);
          defineIcons(key, additions[key]);
          var longPrefix = PREFIX_TO_LONG_STYLE[i][key];
          if (longPrefix) defineIcons(longPrefix, additions[key]);
          build();
        });
      }
    }, {
      key: "reset",
      value: function reset() {
        this.definitions = {};
      }
    }, {
      key: "_pullDefinitions",
      value: function _pullDefinitions(additions, definition) {
        var normalized = definition.prefix && definition.iconName && definition.icon ? {
          0: definition
        } : definition;
        Object.keys(normalized).map(function(key) {
          var _normalized$key = normalized[key], prefix = _normalized$key.prefix, iconName = _normalized$key.iconName, icon3 = _normalized$key.icon;
          var aliases = icon3[2];
          if (!additions[prefix]) additions[prefix] = {};
          if (aliases.length > 0) {
            aliases.forEach(function(alias) {
              if (typeof alias === "string") {
                additions[prefix][alias] = icon3;
              }
            });
          }
          additions[prefix][iconName] = icon3;
        });
        return additions;
      }
    }]);
  }();
  var _plugins = [];
  var _hooks = {};
  var providers = {};
  var defaultProviderKeys = Object.keys(providers);
  function registerPlugins(nextPlugins, _ref2) {
    var obj = _ref2.mixoutsTo;
    _plugins = nextPlugins;
    _hooks = {};
    Object.keys(providers).forEach(function(k2) {
      if (defaultProviderKeys.indexOf(k2) === -1) {
        delete providers[k2];
      }
    });
    _plugins.forEach(function(plugin) {
      var mixout8 = plugin.mixout ? plugin.mixout() : {};
      Object.keys(mixout8).forEach(function(tk) {
        if (typeof mixout8[tk] === "function") {
          obj[tk] = mixout8[tk];
        }
        if (_typeof(mixout8[tk]) === "object") {
          Object.keys(mixout8[tk]).forEach(function(sk) {
            if (!obj[tk]) {
              obj[tk] = {};
            }
            obj[tk][sk] = mixout8[tk][sk];
          });
        }
      });
      if (plugin.hooks) {
        var hooks8 = plugin.hooks();
        Object.keys(hooks8).forEach(function(hook) {
          if (!_hooks[hook]) {
            _hooks[hook] = [];
          }
          _hooks[hook].push(hooks8[hook]);
        });
      }
      if (plugin.provides) {
        plugin.provides(providers);
      }
    });
    return obj;
  }
  function chainHooks(hook, accumulator) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    var hookFns = _hooks[hook] || [];
    hookFns.forEach(function(hookFn) {
      accumulator = hookFn.apply(null, [accumulator].concat(args));
    });
    return accumulator;
  }
  function callHooks(hook) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var hookFns = _hooks[hook] || [];
    hookFns.forEach(function(hookFn) {
      hookFn.apply(null, args);
    });
    return void 0;
  }
  function callProvided() {
    var hook = arguments[0];
    var args = Array.prototype.slice.call(arguments, 1);
    return providers[hook] ? providers[hook].apply(null, args) : void 0;
  }
  function findIconDefinition(iconLookup) {
    if (iconLookup.prefix === "fa") {
      iconLookup.prefix = "fas";
    }
    var iconName = iconLookup.iconName;
    var prefix = iconLookup.prefix || getDefaultUsablePrefix();
    if (!iconName) return;
    iconName = byAlias(prefix, iconName) || iconName;
    return iconFromMapping(library.definitions, prefix, iconName) || iconFromMapping(namespace.styles, prefix, iconName);
  }
  var library = new Library();
  var noAuto = function noAuto2() {
    config.autoReplaceSvg = false;
    config.observeMutations = false;
    callHooks("noAuto");
  };
  var dom = {
    i2svg: function i2svg() {
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (IS_DOM) {
        callHooks("beforeI2svg", params);
        callProvided("pseudoElements2svg", params);
        return callProvided("i2svg", params);
      } else {
        return Promise.reject(new Error("Operation requires a DOM of some kind."));
      }
    },
    watch: function watch2() {
      var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var autoReplaceSvgRoot = params.autoReplaceSvgRoot;
      if (config.autoReplaceSvg === false) {
        config.autoReplaceSvg = true;
      }
      config.observeMutations = true;
      domready(function() {
        autoReplace({
          autoReplaceSvgRoot
        });
        callHooks("watch", params);
      });
    }
  };
  var parse = {
    icon: function icon(_icon) {
      if (_icon === null) {
        return null;
      }
      if (_typeof(_icon) === "object" && _icon.prefix && _icon.iconName) {
        return {
          prefix: _icon.prefix,
          iconName: byAlias(_icon.prefix, _icon.iconName) || _icon.iconName
        };
      }
      if (Array.isArray(_icon) && _icon.length === 2) {
        var iconName = _icon[1].indexOf("fa-") === 0 ? _icon[1].slice(3) : _icon[1];
        var prefix = getCanonicalPrefix(_icon[0]);
        return {
          prefix,
          iconName: byAlias(prefix, iconName) || iconName
        };
      }
      if (typeof _icon === "string" && (_icon.indexOf("".concat(config.cssPrefix, "-")) > -1 || _icon.match(ICON_SELECTION_SYNTAX_PATTERN))) {
        var canonicalIcon = getCanonicalIcon(_icon.split(" "), {
          skipLookups: true
        });
        return {
          prefix: canonicalIcon.prefix || getDefaultUsablePrefix(),
          iconName: byAlias(canonicalIcon.prefix, canonicalIcon.iconName) || canonicalIcon.iconName
        };
      }
      if (typeof _icon === "string") {
        var _prefix = getDefaultUsablePrefix();
        return {
          prefix: _prefix,
          iconName: byAlias(_prefix, _icon) || _icon
        };
      }
    }
  };
  var api = {
    noAuto,
    config,
    dom,
    parse,
    library,
    findIconDefinition,
    toHtml
  };
  var autoReplace = function autoReplace2() {
    var params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var _params$autoReplaceSv = params.autoReplaceSvgRoot, autoReplaceSvgRoot = _params$autoReplaceSv === void 0 ? DOCUMENT : _params$autoReplaceSv;
    if ((Object.keys(namespace.styles).length > 0 || config.autoFetchSvg) && IS_DOM && config.autoReplaceSvg) api.dom.i2svg({
      node: autoReplaceSvgRoot
    });
  };
  function domVariants(val, abstractCreator) {
    Object.defineProperty(val, "abstract", {
      get: abstractCreator
    });
    Object.defineProperty(val, "html", {
      get: function get2() {
        return val.abstract.map(function(a2) {
          return toHtml(a2);
        });
      }
    });
    Object.defineProperty(val, "node", {
      get: function get2() {
        if (!IS_DOM) return void 0;
        var container = DOCUMENT.createElement("div");
        container.innerHTML = val.html;
        return container.children;
      }
    });
    return val;
  }
  function asIcon(_ref2) {
    var children = _ref2.children, main = _ref2.main, mask = _ref2.mask, attributes = _ref2.attributes, styles2 = _ref2.styles, transform = _ref2.transform;
    if (transformIsMeaningful(transform) && main.found && !mask.found) {
      var width = main.width, height = main.height;
      var offset2 = {
        x: width / height / 2,
        y: 0.5
      };
      attributes["style"] = joinStyles(_objectSpread2(_objectSpread2({}, styles2), {}, {
        "transform-origin": "".concat(offset2.x + transform.x / 16, "em ").concat(offset2.y + transform.y / 16, "em")
      }));
    }
    return [{
      tag: "svg",
      attributes,
      children
    }];
  }
  function asSymbol(_ref2) {
    var prefix = _ref2.prefix, iconName = _ref2.iconName, children = _ref2.children, attributes = _ref2.attributes, symbol = _ref2.symbol;
    var id = symbol === true ? "".concat(prefix, "-").concat(config.cssPrefix, "-").concat(iconName) : symbol;
    return [{
      tag: "svg",
      attributes: {
        style: "display: none;"
      },
      children: [{
        tag: "symbol",
        attributes: _objectSpread2(_objectSpread2({}, attributes), {}, {
          id
        }),
        children
      }]
    }];
  }
  function isLabeled(attributes) {
    var labels = ["aria-label", "aria-labelledby", "title", "role"];
    return labels.some(function(label) {
      return label in attributes;
    });
  }
  function makeInlineSvgAbstract(params) {
    var _params$icons = params.icons, main = _params$icons.main, mask = _params$icons.mask, prefix = params.prefix, iconName = params.iconName, transform = params.transform, symbol = params.symbol, maskId = params.maskId, extra = params.extra, _params$watchable = params.watchable, watchable = _params$watchable === void 0 ? false : _params$watchable;
    var _ref2 = mask.found ? mask : main, width = _ref2.width, height = _ref2.height;
    var attrClass = [config.replacementClass, iconName ? "".concat(config.cssPrefix, "-").concat(iconName) : ""].filter(function(c2) {
      return extra.classes.indexOf(c2) === -1;
    }).filter(function(c2) {
      return c2 !== "" || !!c2;
    }).concat(extra.classes).join(" ");
    var content = {
      children: [],
      attributes: _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
        "data-prefix": prefix,
        "data-icon": iconName,
        "class": attrClass,
        "role": extra.attributes.role || "img",
        "viewBox": "0 0 ".concat(width, " ").concat(height)
      })
    };
    if (!isLabeled(extra.attributes) && !extra.attributes["aria-hidden"]) {
      content.attributes["aria-hidden"] = "true";
    }
    if (watchable) {
      content.attributes[DATA_FA_I2SVG] = "";
    }
    var args = _objectSpread2(_objectSpread2({}, content), {}, {
      prefix,
      iconName,
      main,
      mask,
      maskId,
      transform,
      symbol,
      styles: _objectSpread2({}, extra.styles)
    });
    var _ref22 = mask.found && main.found ? callProvided("generateAbstractMask", args) || {
      children: [],
      attributes: {}
    } : callProvided("generateAbstractIcon", args) || {
      children: [],
      attributes: {}
    }, children = _ref22.children, attributes = _ref22.attributes;
    args.children = children;
    args.attributes = attributes;
    if (symbol) {
      return asSymbol(args);
    } else {
      return asIcon(args);
    }
  }
  function makeLayersTextAbstract(params) {
    var content = params.content, width = params.width, height = params.height, transform = params.transform, extra = params.extra, _params$watchable2 = params.watchable, watchable = _params$watchable2 === void 0 ? false : _params$watchable2;
    var attributes = _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      class: extra.classes.join(" ")
    });
    if (watchable) {
      attributes[DATA_FA_I2SVG] = "";
    }
    var styles2 = _objectSpread2({}, extra.styles);
    if (transformIsMeaningful(transform)) {
      styles2["transform"] = transformForCss({
        transform,
        startCentered: true,
        width,
        height
      });
      styles2["-webkit-transform"] = styles2["transform"];
    }
    var styleString = joinStyles(styles2);
    if (styleString.length > 0) {
      attributes["style"] = styleString;
    }
    var val = [];
    val.push({
      tag: "span",
      attributes,
      children: [content]
    });
    return val;
  }
  function makeLayersCounterAbstract(params) {
    var content = params.content, extra = params.extra;
    var attributes = _objectSpread2(_objectSpread2({}, extra.attributes), {}, {
      class: extra.classes.join(" ")
    });
    var styleString = joinStyles(extra.styles);
    if (styleString.length > 0) {
      attributes["style"] = styleString;
    }
    var val = [];
    val.push({
      tag: "span",
      attributes,
      children: [content]
    });
    return val;
  }
  var styles$1 = namespace.styles;
  function asFoundIcon(icon3) {
    var width = icon3[0];
    var height = icon3[1];
    var _icon$slice = icon3.slice(4), _icon$slice2 = _slicedToArray(_icon$slice, 1), vectorData = _icon$slice2[0];
    var element = null;
    if (Array.isArray(vectorData)) {
      element = {
        tag: "g",
        attributes: {
          class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.GROUP)
        },
        children: [{
          tag: "path",
          attributes: {
            class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.SECONDARY),
            fill: "currentColor",
            d: vectorData[0]
          }
        }, {
          tag: "path",
          attributes: {
            class: "".concat(config.cssPrefix, "-").concat(DUOTONE_CLASSES.PRIMARY),
            fill: "currentColor",
            d: vectorData[1]
          }
        }]
      };
    } else {
      element = {
        tag: "path",
        attributes: {
          fill: "currentColor",
          d: vectorData
        }
      };
    }
    return {
      found: true,
      width,
      height,
      icon: element
    };
  }
  var missingIconResolutionMixin = {
    found: false,
    width: 512,
    height: 512
  };
  function maybeNotifyMissing(iconName, prefix) {
    if (!PRODUCTION && !config.showMissingIcons && iconName) {
      console.error('Icon with name "'.concat(iconName, '" and prefix "').concat(prefix, '" is missing.'));
    }
  }
  function findIcon(iconName, prefix) {
    var givenPrefix = prefix;
    if (prefix === "fa" && config.styleDefault !== null) {
      prefix = getDefaultUsablePrefix();
    }
    return new Promise(function(resolve2, reject) {
      if (givenPrefix === "fa") {
        var shim = byOldName(iconName);
        iconName = shim.iconName || iconName;
        prefix = shim.prefix || prefix;
      }
      if (iconName && prefix && styles$1[prefix] && styles$1[prefix][iconName]) {
        var icon3 = styles$1[prefix][iconName];
        return resolve2(asFoundIcon(icon3));
      }
      maybeNotifyMissing(iconName, prefix);
      resolve2(_objectSpread2(_objectSpread2({}, missingIconResolutionMixin), {}, {
        icon: config.showMissingIcons && iconName ? callProvided("missingIconAbstract") || {} : {}
      }));
    });
  }
  var noop$1 = function noop3() {
  };
  var p$2 = config.measurePerformance && PERFORMANCE && PERFORMANCE.mark && PERFORMANCE.measure ? PERFORMANCE : {
    mark: noop$1,
    measure: noop$1
  };
  var preamble = 'FA "7.1.0"';
  var begin = function begin2(name) {
    p$2.mark("".concat(preamble, " ").concat(name, " begins"));
    return function() {
      return end(name);
    };
  };
  var end = function end2(name) {
    p$2.mark("".concat(preamble, " ").concat(name, " ends"));
    p$2.measure("".concat(preamble, " ").concat(name), "".concat(preamble, " ").concat(name, " begins"), "".concat(preamble, " ").concat(name, " ends"));
  };
  var perf = {
    begin,
    end
  };
  var noop$2 = function noop4() {
  };
  function isWatched(node) {
    var i2svg2 = node.getAttribute ? node.getAttribute(DATA_FA_I2SVG) : null;
    return typeof i2svg2 === "string";
  }
  function hasPrefixAndIcon(node) {
    var prefix = node.getAttribute ? node.getAttribute(DATA_PREFIX) : null;
    var icon3 = node.getAttribute ? node.getAttribute(DATA_ICON) : null;
    return prefix && icon3;
  }
  function hasBeenReplaced(node) {
    return node && node.classList && node.classList.contains && node.classList.contains(config.replacementClass);
  }
  function getMutator() {
    if (config.autoReplaceSvg === true) {
      return mutators.replace;
    }
    var mutator = mutators[config.autoReplaceSvg];
    return mutator || mutators.replace;
  }
  function createElementNS(tag) {
    return DOCUMENT.createElementNS("http://www.w3.org/2000/svg", tag);
  }
  function createElement(tag) {
    return DOCUMENT.createElement(tag);
  }
  function convertSVG(abstractObj) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _params$ceFn = params.ceFn, ceFn = _params$ceFn === void 0 ? abstractObj.tag === "svg" ? createElementNS : createElement : _params$ceFn;
    if (typeof abstractObj === "string") {
      return DOCUMENT.createTextNode(abstractObj);
    }
    var tag = ceFn(abstractObj.tag);
    Object.keys(abstractObj.attributes || []).forEach(function(key) {
      tag.setAttribute(key, abstractObj.attributes[key]);
    });
    var children = abstractObj.children || [];
    children.forEach(function(child) {
      tag.appendChild(convertSVG(child, {
        ceFn
      }));
    });
    return tag;
  }
  function nodeAsComment(node) {
    var comment = " ".concat(node.outerHTML, " ");
    comment = "".concat(comment, "Font Awesome fontawesome.com ");
    return comment;
  }
  var mutators = {
    replace: function replace(mutation) {
      var node = mutation[0];
      if (node.parentNode) {
        mutation[1].forEach(function(abstract) {
          node.parentNode.insertBefore(convertSVG(abstract), node);
        });
        if (node.getAttribute(DATA_FA_I2SVG) === null && config.keepOriginalSource) {
          var comment = DOCUMENT.createComment(nodeAsComment(node));
          node.parentNode.replaceChild(comment, node);
        } else {
          node.remove();
        }
      }
    },
    nest: function nest(mutation) {
      var node = mutation[0];
      var abstract = mutation[1];
      if (~classArray(node).indexOf(config.replacementClass)) {
        return mutators.replace(mutation);
      }
      var forSvg = new RegExp("".concat(config.cssPrefix, "-.*"));
      delete abstract[0].attributes.id;
      if (abstract[0].attributes.class) {
        var splitClasses = abstract[0].attributes.class.split(" ").reduce(function(acc, cls) {
          if (cls === config.replacementClass || cls.match(forSvg)) {
            acc.toSvg.push(cls);
          } else {
            acc.toNode.push(cls);
          }
          return acc;
        }, {
          toNode: [],
          toSvg: []
        });
        abstract[0].attributes.class = splitClasses.toSvg.join(" ");
        if (splitClasses.toNode.length === 0) {
          node.removeAttribute("class");
        } else {
          node.setAttribute("class", splitClasses.toNode.join(" "));
        }
      }
      var newInnerHTML = abstract.map(function(a2) {
        return toHtml(a2);
      }).join("\n");
      node.setAttribute(DATA_FA_I2SVG, "");
      node.innerHTML = newInnerHTML;
    }
  };
  function performOperationSync(op) {
    op();
  }
  function perform(mutations2, callback) {
    var callbackFunction = typeof callback === "function" ? callback : noop$2;
    if (mutations2.length === 0) {
      callbackFunction();
    } else {
      var frame = performOperationSync;
      if (config.mutateApproach === MUTATION_APPROACH_ASYNC) {
        frame = WINDOW.requestAnimationFrame || performOperationSync;
      }
      frame(function() {
        var mutator = getMutator();
        var mark = perf.begin("mutate");
        mutations2.map(mutator);
        mark();
        callbackFunction();
      });
    }
  }
  var disabled = false;
  function disableObservation() {
    disabled = true;
  }
  function enableObservation() {
    disabled = false;
  }
  var mo = null;
  function observe(options2) {
    if (!MUTATION_OBSERVER) {
      return;
    }
    if (!config.observeMutations) {
      return;
    }
    var _options$treeCallback = options2.treeCallback, treeCallback = _options$treeCallback === void 0 ? noop$2 : _options$treeCallback, _options$nodeCallback = options2.nodeCallback, nodeCallback = _options$nodeCallback === void 0 ? noop$2 : _options$nodeCallback, _options$pseudoElemen = options2.pseudoElementsCallback, pseudoElementsCallback = _options$pseudoElemen === void 0 ? noop$2 : _options$pseudoElemen, _options$observeMutat = options2.observeMutationsRoot, observeMutationsRoot = _options$observeMutat === void 0 ? DOCUMENT : _options$observeMutat;
    mo = new MUTATION_OBSERVER(function(objects) {
      if (disabled) return;
      var defaultPrefix = getDefaultUsablePrefix();
      toArray(objects).forEach(function(mutationRecord) {
        if (mutationRecord.type === "childList" && mutationRecord.addedNodes.length > 0 && !isWatched(mutationRecord.addedNodes[0])) {
          if (config.searchPseudoElements) {
            pseudoElementsCallback(mutationRecord.target);
          }
          treeCallback(mutationRecord.target);
        }
        if (mutationRecord.type === "attributes" && mutationRecord.target.parentNode && config.searchPseudoElements) {
          pseudoElementsCallback([mutationRecord.target], true);
        }
        if (mutationRecord.type === "attributes" && isWatched(mutationRecord.target) && ~ATTRIBUTES_WATCHED_FOR_MUTATION.indexOf(mutationRecord.attributeName)) {
          if (mutationRecord.attributeName === "class" && hasPrefixAndIcon(mutationRecord.target)) {
            var _getCanonicalIcon = getCanonicalIcon(classArray(mutationRecord.target)), prefix = _getCanonicalIcon.prefix, iconName = _getCanonicalIcon.iconName;
            mutationRecord.target.setAttribute(DATA_PREFIX, prefix || defaultPrefix);
            if (iconName) mutationRecord.target.setAttribute(DATA_ICON, iconName);
          } else if (hasBeenReplaced(mutationRecord.target)) {
            nodeCallback(mutationRecord.target);
          }
        }
      });
    });
    if (!IS_DOM) return;
    mo.observe(observeMutationsRoot, {
      childList: true,
      attributes: true,
      characterData: true,
      subtree: true
    });
  }
  function disconnect() {
    if (!mo) return;
    mo.disconnect();
  }
  function styleParser(node) {
    var style = node.getAttribute("style");
    var val = [];
    if (style) {
      val = style.split(";").reduce(function(acc, style2) {
        var styles2 = style2.split(":");
        var prop = styles2[0];
        var value = styles2.slice(1);
        if (prop && value.length > 0) {
          acc[prop] = value.join(":").trim();
        }
        return acc;
      }, {});
    }
    return val;
  }
  function classParser(node) {
    var existingPrefix = node.getAttribute("data-prefix");
    var existingIconName = node.getAttribute("data-icon");
    var innerText = node.innerText !== void 0 ? node.innerText.trim() : "";
    var val = getCanonicalIcon(classArray(node));
    if (!val.prefix) {
      val.prefix = getDefaultUsablePrefix();
    }
    if (existingPrefix && existingIconName) {
      val.prefix = existingPrefix;
      val.iconName = existingIconName;
    }
    if (val.iconName && val.prefix) {
      return val;
    }
    if (val.prefix && innerText.length > 0) {
      val.iconName = byLigature(val.prefix, node.innerText) || byUnicode(val.prefix, toHex(node.innerText));
    }
    if (!val.iconName && config.autoFetchSvg && node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE) {
      val.iconName = node.firstChild.data;
    }
    return val;
  }
  function attributesParser(node) {
    var extraAttributes = toArray(node.attributes).reduce(function(acc, attr) {
      if (acc.name !== "class" && acc.name !== "style") {
        acc[attr.name] = attr.value;
      }
      return acc;
    }, {});
    return extraAttributes;
  }
  function blankMeta() {
    return {
      iconName: null,
      prefix: null,
      transform: meaninglessTransform,
      symbol: false,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      extra: {
        classes: [],
        styles: {},
        attributes: {}
      }
    };
  }
  function parseMeta(node) {
    var parser = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      styleParser: true
    };
    var _classParser = classParser(node), iconName = _classParser.iconName, prefix = _classParser.prefix, extraClasses = _classParser.rest;
    var extraAttributes = attributesParser(node);
    var pluginMeta = chainHooks("parseNodeAttributes", {}, node);
    var extraStyles = parser.styleParser ? styleParser(node) : [];
    return _objectSpread2({
      iconName,
      prefix,
      transform: meaninglessTransform,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      symbol: false,
      extra: {
        classes: extraClasses,
        styles: extraStyles,
        attributes: extraAttributes
      }
    }, pluginMeta);
  }
  var styles$2 = namespace.styles;
  function generateMutation(node) {
    var nodeMeta = config.autoReplaceSvg === "nest" ? parseMeta(node, {
      styleParser: false
    }) : parseMeta(node);
    if (~nodeMeta.extra.classes.indexOf(LAYERS_TEXT_CLASSNAME)) {
      return callProvided("generateLayersText", node, nodeMeta);
    } else {
      return callProvided("generateSvgReplacementMutation", node, nodeMeta);
    }
  }
  function getKnownPrefixes() {
    return [].concat(_toConsumableArray(Yt), _toConsumableArray(Zt$1));
  }
  function onTree(root2) {
    var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!IS_DOM) return Promise.resolve();
    var htmlClassList = DOCUMENT.documentElement.classList;
    var hclAdd = function hclAdd2(suffix) {
      return htmlClassList.add("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
    };
    var hclRemove = function hclRemove2(suffix) {
      return htmlClassList.remove("".concat(HTML_CLASS_I2SVG_BASE_CLASS, "-").concat(suffix));
    };
    var prefixes2 = config.autoFetchSvg ? getKnownPrefixes() : Q.concat(Object.keys(styles$2));
    if (!prefixes2.includes("fa")) {
      prefixes2.push("fa");
    }
    var prefixesDomQuery = [".".concat(LAYERS_TEXT_CLASSNAME, ":not([").concat(DATA_FA_I2SVG, "])")].concat(prefixes2.map(function(p$$1) {
      return ".".concat(p$$1, ":not([").concat(DATA_FA_I2SVG, "])");
    })).join(", ");
    if (prefixesDomQuery.length === 0) {
      return Promise.resolve();
    }
    var candidates = [];
    try {
      candidates = toArray(root2.querySelectorAll(prefixesDomQuery));
    } catch (e$$1) {
    }
    if (candidates.length > 0) {
      hclAdd("pending");
      hclRemove("complete");
    } else {
      return Promise.resolve();
    }
    var mark = perf.begin("onTree");
    var mutations2 = candidates.reduce(function(acc, node) {
      try {
        var mutation = generateMutation(node);
        if (mutation) {
          acc.push(mutation);
        }
      } catch (e$$1) {
        if (!PRODUCTION) {
          if (e$$1.name === "MissingIcon") {
            console.error(e$$1);
          }
        }
      }
      return acc;
    }, []);
    return new Promise(function(resolve2, reject) {
      Promise.all(mutations2).then(function(resolvedMutations) {
        perform(resolvedMutations, function() {
          hclAdd("active");
          hclAdd("complete");
          hclRemove("pending");
          if (typeof callback === "function") callback();
          mark();
          resolve2();
        });
      }).catch(function(e$$1) {
        mark();
        reject(e$$1);
      });
    });
  }
  function onNode(node) {
    var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    generateMutation(node).then(function(mutation) {
      if (mutation) {
        perform([mutation], callback);
      }
    });
  }
  function resolveIcons(next) {
    return function(maybeIconDefinition) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var iconDefinition = (maybeIconDefinition || {}).icon ? maybeIconDefinition : findIconDefinition(maybeIconDefinition || {});
      var mask = params.mask;
      if (mask) {
        mask = (mask || {}).icon ? mask : findIconDefinition(mask || {});
      }
      return next(iconDefinition, _objectSpread2(_objectSpread2({}, params), {}, {
        mask
      }));
    };
  }
  var render = function render2(iconDefinition) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _params$transform = params.transform, transform = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$symbol = params.symbol, symbol = _params$symbol === void 0 ? false : _params$symbol, _params$mask = params.mask, mask = _params$mask === void 0 ? null : _params$mask, _params$maskId = params.maskId, maskId = _params$maskId === void 0 ? null : _params$maskId, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
    if (!iconDefinition) return;
    var prefix = iconDefinition.prefix, iconName = iconDefinition.iconName, icon3 = iconDefinition.icon;
    return domVariants(_objectSpread2({
      type: "icon"
    }, iconDefinition), function() {
      callHooks("beforeDOMElementCreation", {
        iconDefinition,
        params
      });
      return makeInlineSvgAbstract({
        icons: {
          main: asFoundIcon(icon3),
          mask: mask ? asFoundIcon(mask.icon) : {
            found: false,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix,
        iconName,
        transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
        symbol,
        maskId,
        extra: {
          attributes,
          styles: styles2,
          classes
        }
      });
    });
  };
  var ReplaceElements = {
    mixout: function mixout2() {
      return {
        icon: resolveIcons(render)
      };
    },
    hooks: function hooks2() {
      return {
        mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
          accumulator.treeCallback = onTree;
          accumulator.nodeCallback = onNode;
          return accumulator;
        }
      };
    },
    provides: function provides(providers$$1) {
      providers$$1.i2svg = function(params) {
        var _params$node = params.node, node = _params$node === void 0 ? DOCUMENT : _params$node, _params$callback = params.callback, callback = _params$callback === void 0 ? function() {
        } : _params$callback;
        return onTree(node, callback);
      };
      providers$$1.generateSvgReplacementMutation = function(node, nodeMeta) {
        var iconName = nodeMeta.iconName, prefix = nodeMeta.prefix, transform = nodeMeta.transform, symbol = nodeMeta.symbol, mask = nodeMeta.mask, maskId = nodeMeta.maskId, extra = nodeMeta.extra;
        return new Promise(function(resolve2, reject) {
          Promise.all([findIcon(iconName, prefix), mask.iconName ? findIcon(mask.iconName, mask.prefix) : Promise.resolve({
            found: false,
            width: 512,
            height: 512,
            icon: {}
          })]).then(function(_ref2) {
            var _ref22 = _slicedToArray(_ref2, 2), main = _ref22[0], mask2 = _ref22[1];
            resolve2([node, makeInlineSvgAbstract({
              icons: {
                main,
                mask: mask2
              },
              prefix,
              iconName,
              transform,
              symbol,
              maskId,
              extra,
              watchable: true
            })]);
          }).catch(reject);
        });
      };
      providers$$1.generateAbstractIcon = function(_ref3) {
        var children = _ref3.children, attributes = _ref3.attributes, main = _ref3.main, transform = _ref3.transform, styles2 = _ref3.styles;
        var styleString = joinStyles(styles2);
        if (styleString.length > 0) {
          attributes["style"] = styleString;
        }
        var nextChild;
        if (transformIsMeaningful(transform)) {
          nextChild = callProvided("generateAbstractTransformGrouping", {
            main,
            transform,
            containerWidth: main.width,
            iconWidth: main.width
          });
        }
        children.push(nextChild || main.icon);
        return {
          children,
          attributes
        };
      };
    }
  };
  var Layers = {
    mixout: function mixout3() {
      return {
        layer: function layer2(assembler) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes;
          return domVariants({
            type: "layer"
          }, function() {
            callHooks("beforeDOMElementCreation", {
              assembler,
              params
            });
            var children = [];
            assembler(function(args) {
              Array.isArray(args) ? args.map(function(a2) {
                children = children.concat(a2.abstract);
              }) : children = children.concat(args.abstract);
            });
            return [{
              tag: "span",
              attributes: {
                class: ["".concat(config.cssPrefix, "-layers")].concat(_toConsumableArray(classes)).join(" ")
              },
              children
            }];
          });
        }
      };
    }
  };
  var LayersCounter = {
    mixout: function mixout4() {
      return {
        counter: function counter2(content) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var _params$title = params.title, title = _params$title === void 0 ? null : _params$title, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
          return domVariants({
            type: "counter",
            content
          }, function() {
            callHooks("beforeDOMElementCreation", {
              content,
              params
            });
            return makeLayersCounterAbstract({
              content: content.toString(),
              title,
              extra: {
                attributes,
                styles: styles2,
                classes: ["".concat(config.cssPrefix, "-layers-counter")].concat(_toConsumableArray(classes))
              }
            });
          });
        }
      };
    }
  };
  var LayersText = {
    mixout: function mixout5() {
      return {
        text: function text2(content) {
          var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var _params$transform = params.transform, transform = _params$transform === void 0 ? meaninglessTransform : _params$transform, _params$classes = params.classes, classes = _params$classes === void 0 ? [] : _params$classes, _params$attributes = params.attributes, attributes = _params$attributes === void 0 ? {} : _params$attributes, _params$styles = params.styles, styles2 = _params$styles === void 0 ? {} : _params$styles;
          return domVariants({
            type: "text",
            content
          }, function() {
            callHooks("beforeDOMElementCreation", {
              content,
              params
            });
            return makeLayersTextAbstract({
              content,
              transform: _objectSpread2(_objectSpread2({}, meaninglessTransform), transform),
              extra: {
                attributes,
                styles: styles2,
                classes: ["".concat(config.cssPrefix, "-layers-text")].concat(_toConsumableArray(classes))
              }
            });
          });
        }
      };
    },
    provides: function provides2(providers$$1) {
      providers$$1.generateLayersText = function(node, nodeMeta) {
        var transform = nodeMeta.transform, extra = nodeMeta.extra;
        var width = null;
        var height = null;
        if (IS_IE) {
          var computedFontSize = parseInt(getComputedStyle(node).fontSize, 10);
          var boundingClientRect = node.getBoundingClientRect();
          width = boundingClientRect.width / computedFontSize;
          height = boundingClientRect.height / computedFontSize;
        }
        return Promise.resolve([node, makeLayersTextAbstract({
          content: node.innerHTML,
          width,
          height,
          transform,
          extra,
          watchable: true
        })]);
      };
    }
  };
  var CLEAN_CONTENT_PATTERN = new RegExp('"', "ug");
  var SECONDARY_UNICODE_RANGE = [1105920, 1112319];
  var _FONT_FAMILY_WEIGHT_TO_PREFIX = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, {
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  }), Ct), ro), dl);
  var FONT_FAMILY_WEIGHT_TO_PREFIX = Object.keys(_FONT_FAMILY_WEIGHT_TO_PREFIX).reduce(function(acc, key) {
    acc[key.toLowerCase()] = _FONT_FAMILY_WEIGHT_TO_PREFIX[key];
    return acc;
  }, {});
  var FONT_FAMILY_WEIGHT_FALLBACK = Object.keys(FONT_FAMILY_WEIGHT_TO_PREFIX).reduce(function(acc, fontFamily) {
    var weights = FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamily];
    acc[fontFamily] = weights[900] || _toConsumableArray(Object.entries(weights))[0][1];
    return acc;
  }, {});
  function hexValueFromContent(content) {
    var cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
    return toHex(_toConsumableArray(cleaned)[0] || "");
  }
  function isSecondaryLayer(styles2) {
    var hasStylisticSet = styles2.getPropertyValue("font-feature-settings").includes("ss01");
    var content = styles2.getPropertyValue("content");
    var cleaned = content.replace(CLEAN_CONTENT_PATTERN, "");
    var codePoint = cleaned.codePointAt(0);
    var isPrependTen = codePoint >= SECONDARY_UNICODE_RANGE[0] && codePoint <= SECONDARY_UNICODE_RANGE[1];
    var isDoubled = cleaned.length === 2 ? cleaned[0] === cleaned[1] : false;
    return isPrependTen || isDoubled || hasStylisticSet;
  }
  function getPrefix(fontFamily, fontWeight) {
    var fontFamilySanitized = fontFamily.replace(/^['"]|['"]$/g, "").toLowerCase();
    var fontWeightInteger = parseInt(fontWeight);
    var fontWeightSanitized = isNaN(fontWeightInteger) ? "normal" : fontWeightInteger;
    return (FONT_FAMILY_WEIGHT_TO_PREFIX[fontFamilySanitized] || {})[fontWeightSanitized] || FONT_FAMILY_WEIGHT_FALLBACK[fontFamilySanitized];
  }
  function replaceForPosition(node, position) {
    var pendingAttribute = "".concat(DATA_FA_PSEUDO_ELEMENT_PENDING).concat(position.replace(":", "-"));
    return new Promise(function(resolve2, reject) {
      if (node.getAttribute(pendingAttribute) !== null) {
        return resolve2();
      }
      var children = toArray(node.children);
      var alreadyProcessedPseudoElement = children.filter(function(c$$1) {
        return c$$1.getAttribute(DATA_FA_PSEUDO_ELEMENT) === position;
      })[0];
      var styles2 = WINDOW.getComputedStyle(node, position);
      var fontFamily = styles2.getPropertyValue("font-family");
      var fontFamilyMatch = fontFamily.match(FONT_FAMILY_PATTERN);
      var fontWeight = styles2.getPropertyValue("font-weight");
      var content = styles2.getPropertyValue("content");
      if (alreadyProcessedPseudoElement && !fontFamilyMatch) {
        node.removeChild(alreadyProcessedPseudoElement);
        return resolve2();
      } else if (fontFamilyMatch && content !== "none" && content !== "") {
        var _content = styles2.getPropertyValue("content");
        var prefix = getPrefix(fontFamily, fontWeight);
        var hexValue = hexValueFromContent(_content);
        var isV4 = fontFamilyMatch[0].startsWith("FontAwesome");
        var isSecondary = isSecondaryLayer(styles2);
        var iconName = byUnicode(prefix, hexValue);
        var iconIdentifier = iconName;
        if (isV4) {
          var iconName4 = byOldUnicode(hexValue);
          if (iconName4.iconName && iconName4.prefix) {
            iconName = iconName4.iconName;
            prefix = iconName4.prefix;
          }
        }
        if (iconName && !isSecondary && (!alreadyProcessedPseudoElement || alreadyProcessedPseudoElement.getAttribute(DATA_PREFIX) !== prefix || alreadyProcessedPseudoElement.getAttribute(DATA_ICON) !== iconIdentifier)) {
          node.setAttribute(pendingAttribute, iconIdentifier);
          if (alreadyProcessedPseudoElement) {
            node.removeChild(alreadyProcessedPseudoElement);
          }
          var meta = blankMeta();
          var extra = meta.extra;
          extra.attributes[DATA_FA_PSEUDO_ELEMENT] = position;
          findIcon(iconName, prefix).then(function(main) {
            var abstract = makeInlineSvgAbstract(_objectSpread2(_objectSpread2({}, meta), {}, {
              icons: {
                main,
                mask: emptyCanonicalIcon()
              },
              prefix,
              iconName: iconIdentifier,
              extra,
              watchable: true
            }));
            var element = DOCUMENT.createElementNS("http://www.w3.org/2000/svg", "svg");
            if (position === "::before") {
              node.insertBefore(element, node.firstChild);
            } else {
              node.appendChild(element);
            }
            element.outerHTML = abstract.map(function(a$$1) {
              return toHtml(a$$1);
            }).join("\n");
            node.removeAttribute(pendingAttribute);
            resolve2();
          }).catch(reject);
        } else {
          resolve2();
        }
      } else {
        resolve2();
      }
    });
  }
  function replace2(node) {
    return Promise.all([replaceForPosition(node, "::before"), replaceForPosition(node, "::after")]);
  }
  function processable(node) {
    return node.parentNode !== document.head && !~TAGNAMES_TO_SKIP_FOR_PSEUDOELEMENTS.indexOf(node.tagName.toUpperCase()) && !node.getAttribute(DATA_FA_PSEUDO_ELEMENT) && (!node.parentNode || node.parentNode.tagName !== "svg");
  }
  var hasPseudoElement = function hasPseudoElement2(selector) {
    return !!selector && PSEUDO_ELEMENTS.some(function(pseudoSelector) {
      return selector.includes(pseudoSelector);
    });
  };
  var parseCSSRuleForPseudos = function parseCSSRuleForPseudos2(selectorText) {
    if (!selectorText) return [];
    var selectorSet = /* @__PURE__ */ new Set();
    var selectors = selectorText.split(/,(?![^()]*\))/).map(function(s$$1) {
      return s$$1.trim();
    });
    selectors = selectors.flatMap(function(selector2) {
      return selector2.includes("(") ? selector2 : selector2.split(",").map(function(s$$1) {
        return s$$1.trim();
      });
    });
    var _iterator = _createForOfIteratorHelper(selectors), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var selector = _step.value;
        if (hasPseudoElement(selector)) {
          var selectorWithoutPseudo = PSEUDO_ELEMENTS.reduce(function(acc, pseudoSelector) {
            return acc.replace(pseudoSelector, "");
          }, selector);
          if (selectorWithoutPseudo !== "" && selectorWithoutPseudo !== "*") {
            selectorSet.add(selectorWithoutPseudo);
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return selectorSet;
  };
  function searchPseudoElements(root2) {
    var useAsNodeList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!IS_DOM) return;
    var nodeList;
    if (useAsNodeList) {
      nodeList = root2;
    } else if (config.searchPseudoElementsFullScan) {
      nodeList = root2.querySelectorAll("*");
    } else {
      var selectorSet = /* @__PURE__ */ new Set();
      var _iterator2 = _createForOfIteratorHelper(document.styleSheets), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var stylesheet = _step2.value;
          try {
            var _iterator3 = _createForOfIteratorHelper(stylesheet.cssRules), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var rule = _step3.value;
                var parsedSelectors = parseCSSRuleForPseudos(rule.selectorText);
                var _iterator4 = _createForOfIteratorHelper(parsedSelectors), _step4;
                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                    var selector = _step4.value;
                    selectorSet.add(selector);
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } catch (e$$1) {
            if (config.searchPseudoElementsWarnings) {
              console.warn("Font Awesome: cannot parse stylesheet: ".concat(stylesheet.href, " (").concat(e$$1.message, ')\nIf it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.'));
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      if (!selectorSet.size) return;
      var cleanSelectors = Array.from(selectorSet).join(", ");
      try {
        nodeList = root2.querySelectorAll(cleanSelectors);
      } catch (_unused) {
      }
    }
    return new Promise(function(resolve2, reject) {
      var operations = toArray(nodeList).filter(processable).map(replace2);
      var end3 = perf.begin("searchPseudoElements");
      disableObservation();
      Promise.all(operations).then(function() {
        end3();
        enableObservation();
        resolve2();
      }).catch(function() {
        end3();
        enableObservation();
        reject();
      });
    });
  }
  var PseudoElements = {
    hooks: function hooks3() {
      return {
        mutationObserverCallbacks: function mutationObserverCallbacks(accumulator) {
          accumulator.pseudoElementsCallback = searchPseudoElements;
          return accumulator;
        }
      };
    },
    provides: function provides3(providers2) {
      providers2.pseudoElements2svg = function(params) {
        var _params$node = params.node, node = _params$node === void 0 ? DOCUMENT : _params$node;
        if (config.searchPseudoElements) {
          searchPseudoElements(node);
        }
      };
    }
  };
  var _unwatched = false;
  var MutationObserver$1 = {
    mixout: function mixout6() {
      return {
        dom: {
          unwatch: function unwatch() {
            disableObservation();
            _unwatched = true;
          }
        }
      };
    },
    hooks: function hooks4() {
      return {
        bootstrap: function bootstrap() {
          observe(chainHooks("mutationObserverCallbacks", {}));
        },
        noAuto: function noAuto3() {
          disconnect();
        },
        watch: function watch2(params) {
          var observeMutationsRoot = params.observeMutationsRoot;
          if (_unwatched) {
            enableObservation();
          } else {
            observe(chainHooks("mutationObserverCallbacks", {
              observeMutationsRoot
            }));
          }
        }
      };
    }
  };
  var parseTransformString = function parseTransformString2(transformString) {
    var transform = {
      size: 16,
      x: 0,
      y: 0,
      flipX: false,
      flipY: false,
      rotate: 0
    };
    return transformString.toLowerCase().split(" ").reduce(function(acc, n2) {
      var parts = n2.toLowerCase().split("-");
      var first = parts[0];
      var rest = parts.slice(1).join("-");
      if (first && rest === "h") {
        acc.flipX = true;
        return acc;
      }
      if (first && rest === "v") {
        acc.flipY = true;
        return acc;
      }
      rest = parseFloat(rest);
      if (isNaN(rest)) {
        return acc;
      }
      switch (first) {
        case "grow":
          acc.size = acc.size + rest;
          break;
        case "shrink":
          acc.size = acc.size - rest;
          break;
        case "left":
          acc.x = acc.x - rest;
          break;
        case "right":
          acc.x = acc.x + rest;
          break;
        case "up":
          acc.y = acc.y - rest;
          break;
        case "down":
          acc.y = acc.y + rest;
          break;
        case "rotate":
          acc.rotate = acc.rotate + rest;
          break;
      }
      return acc;
    }, transform);
  };
  var PowerTransforms = {
    mixout: function mixout7() {
      return {
        parse: {
          transform: function transform(transformString) {
            return parseTransformString(transformString);
          }
        }
      };
    },
    hooks: function hooks5() {
      return {
        parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
          var transformString = node.getAttribute("data-fa-transform");
          if (transformString) {
            accumulator.transform = parseTransformString(transformString);
          }
          return accumulator;
        }
      };
    },
    provides: function provides4(providers2) {
      providers2.generateAbstractTransformGrouping = function(_ref2) {
        var main = _ref2.main, transform = _ref2.transform, containerWidth = _ref2.containerWidth, iconWidth = _ref2.iconWidth;
        var outer = {
          transform: "translate(".concat(containerWidth / 2, " 256)")
        };
        var innerTranslate = "translate(".concat(transform.x * 32, ", ").concat(transform.y * 32, ") ");
        var innerScale = "scale(".concat(transform.size / 16 * (transform.flipX ? -1 : 1), ", ").concat(transform.size / 16 * (transform.flipY ? -1 : 1), ") ");
        var innerRotate = "rotate(".concat(transform.rotate, " 0 0)");
        var inner = {
          transform: "".concat(innerTranslate, " ").concat(innerScale, " ").concat(innerRotate)
        };
        var path = {
          transform: "translate(".concat(iconWidth / 2 * -1, " -256)")
        };
        var operations = {
          outer,
          inner,
          path
        };
        return {
          tag: "g",
          attributes: _objectSpread2({}, operations.outer),
          children: [{
            tag: "g",
            attributes: _objectSpread2({}, operations.inner),
            children: [{
              tag: main.icon.tag,
              children: main.icon.children,
              attributes: _objectSpread2(_objectSpread2({}, main.icon.attributes), operations.path)
            }]
          }]
        };
      };
    }
  };
  var ALL_SPACE = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
  };
  function fillBlack(abstract) {
    var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (abstract.attributes && (abstract.attributes.fill || force)) {
      abstract.attributes.fill = "black";
    }
    return abstract;
  }
  function deGroup(abstract) {
    if (abstract.tag === "g") {
      return abstract.children;
    } else {
      return [abstract];
    }
  }
  var Masks = {
    hooks: function hooks6() {
      return {
        parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
          var maskData = node.getAttribute("data-fa-mask");
          var mask = !maskData ? emptyCanonicalIcon() : getCanonicalIcon(maskData.split(" ").map(function(i2) {
            return i2.trim();
          }));
          if (!mask.prefix) {
            mask.prefix = getDefaultUsablePrefix();
          }
          accumulator.mask = mask;
          accumulator.maskId = node.getAttribute("data-fa-mask-id");
          return accumulator;
        }
      };
    },
    provides: function provides5(providers2) {
      providers2.generateAbstractMask = function(_ref2) {
        var children = _ref2.children, attributes = _ref2.attributes, main = _ref2.main, mask = _ref2.mask, explicitMaskId = _ref2.maskId, transform = _ref2.transform;
        var mainWidth = main.width, mainPath = main.icon;
        var maskWidth = mask.width, maskPath = mask.icon;
        var trans = transformForSvg({
          transform,
          containerWidth: maskWidth,
          iconWidth: mainWidth
        });
        var maskRect = {
          tag: "rect",
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            fill: "white"
          })
        };
        var maskInnerGroupChildrenMixin = mainPath.children ? {
          children: mainPath.children.map(fillBlack)
        } : {};
        var maskInnerGroup = {
          tag: "g",
          attributes: _objectSpread2({}, trans.inner),
          children: [fillBlack(_objectSpread2({
            tag: mainPath.tag,
            attributes: _objectSpread2(_objectSpread2({}, mainPath.attributes), trans.path)
          }, maskInnerGroupChildrenMixin))]
        };
        var maskOuterGroup = {
          tag: "g",
          attributes: _objectSpread2({}, trans.outer),
          children: [maskInnerGroup]
        };
        var maskId = "mask-".concat(explicitMaskId || nextUniqueId());
        var clipId = "clip-".concat(explicitMaskId || nextUniqueId());
        var maskTag = {
          tag: "mask",
          attributes: _objectSpread2(_objectSpread2({}, ALL_SPACE), {}, {
            id: maskId,
            maskUnits: "userSpaceOnUse",
            maskContentUnits: "userSpaceOnUse"
          }),
          children: [maskRect, maskOuterGroup]
        };
        var defs = {
          tag: "defs",
          children: [{
            tag: "clipPath",
            attributes: {
              id: clipId
            },
            children: deGroup(maskPath)
          }, maskTag]
        };
        children.push(defs, {
          tag: "rect",
          attributes: _objectSpread2({
            "fill": "currentColor",
            "clip-path": "url(#".concat(clipId, ")"),
            "mask": "url(#".concat(maskId, ")")
          }, ALL_SPACE)
        });
        return {
          children,
          attributes
        };
      };
    }
  };
  var MissingIconIndicator = {
    provides: function provides6(providers2) {
      var reduceMotion = false;
      if (WINDOW.matchMedia) {
        reduceMotion = WINDOW.matchMedia("(prefers-reduced-motion: reduce)").matches;
      }
      providers2.missingIconAbstract = function() {
        var gChildren = [];
        var FILL = {
          fill: "currentColor"
        };
        var ANIMATION_BASE = {
          attributeType: "XML",
          repeatCount: "indefinite",
          dur: "2s"
        };
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
          })
        });
        var OPACITY_ANIMATE = _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
          attributeName: "opacity"
        });
        var dot = {
          tag: "circle",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            cx: "256",
            cy: "364",
            r: "28"
          }),
          children: []
        };
        if (!reduceMotion) {
          dot.children.push({
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, ANIMATION_BASE), {}, {
              attributeName: "r",
              values: "28;14;28;28;14;28;"
            })
          }, {
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "1;0;1;1;0;1;"
            })
          });
        }
        gChildren.push(dot);
        gChildren.push({
          tag: "path",
          attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
            opacity: "1",
            d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
          }),
          children: reduceMotion ? [] : [{
            tag: "animate",
            attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
              values: "1;0;0;0;0;1;"
            })
          }]
        });
        if (!reduceMotion) {
          gChildren.push({
            tag: "path",
            attributes: _objectSpread2(_objectSpread2({}, FILL), {}, {
              opacity: "0",
              d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
            }),
            children: [{
              tag: "animate",
              attributes: _objectSpread2(_objectSpread2({}, OPACITY_ANIMATE), {}, {
                values: "0;0;1;1;0;0;"
              })
            }]
          });
        }
        return {
          tag: "g",
          attributes: {
            class: "missing"
          },
          children: gChildren
        };
      };
    }
  };
  var SvgSymbols = {
    hooks: function hooks7() {
      return {
        parseNodeAttributes: function parseNodeAttributes(accumulator, node) {
          var symbolData = node.getAttribute("data-fa-symbol");
          var symbol = symbolData === null ? false : symbolData === "" ? true : symbolData;
          accumulator["symbol"] = symbol;
          return accumulator;
        }
      };
    }
  };
  var plugins = [InjectCSS, ReplaceElements, Layers, LayersCounter, LayersText, PseudoElements, MutationObserver$1, PowerTransforms, Masks, MissingIconIndicator, SvgSymbols];
  registerPlugins(plugins, {
    mixoutsTo: api
  });
  api.noAuto;
  var config$1 = api.config;
  var library$1 = api.library;
  var dom$1 = api.dom;
  api.parse;
  api.findIconDefinition;
  api.toHtml;
  api.icon;
  api.layer;
  api.text;
  api.counter;
  /*!
   * Font Awesome Pro 7.1.0 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license (Commercial License)
   * Copyright 2025 Fonticons, Inc.
   */
  var faFileArrowDown = {
    prefix: "far",
    iconName: "file-arrow-down",
    icon: [384, 512, ["file-download"], "f56d", "M64 48l112 0 0 88c0 39.8 32.2 72 72 72l88 0 0 240c0 8.8-7.2 16-16 16L64 464c-8.8 0-16-7.2-16-16L48 64c0-8.8 7.2-16 16-16zM224 67.9l92.1 92.1-68.1 0c-13.3 0-24-10.7-24-24l0-68.1zM64 0C28.7 0 0 28.7 0 64L0 448c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-261.5c0-17-6.7-33.3-18.7-45.3L242.7 18.7C230.7 6.7 214.5 0 197.5 0L64 0zM175 425c9.4 9.4 24.6 9.4 33.9 0l64-64c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-23 23 0-86.1c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 86.1-23-23c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l64 64z"]
  };
  var faMagnifyingGlass = {
    prefix: "far",
    iconName: "magnifying-glass",
    icon: [512, 512, [128269, "search"], "f002", "M368 208a160 160 0 1 0 -320 0 160 160 0 1 0 320 0zM337.1 371.1C301.7 399.2 256.8 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208c0 48.8-16.8 93.7-44.9 129.1L505 471c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0L337.1 371.1z"]
  };
  var faSearch = faMagnifyingGlass;
  var faCircleXmark = {
    prefix: "far",
    iconName: "circle-xmark",
    icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 48a208 208 0 1 1 0 416 208 208 0 1 1 0-416zm0 464a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c-9.4 9.4-9.4 24.6 0 33.9l55 55-55 55c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l55-55 55 55c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-55-55 55-55c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-55 55-55-55c-9.4-9.4-24.6-9.4-33.9 0z"]
  };
  var faTimesCircle = faCircleXmark;
  var faCircle = {
    prefix: "far",
    iconName: "circle",
    icon: [512, 512, [128308, 128309, 128992, 128993, 128994, 128995, 128996, 9679, 9898, 9899, 11044, 61708, 61915], "f111", "M464 256a208 208 0 1 0 -416 0 208 208 0 1 0 416 0zM0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0z"]
  };
  var faCircleArrowDown = {
    prefix: "far",
    iconName: "circle-arrow-down",
    icon: [512, 512, ["arrow-circle-down"], "f0ab", "M256 48a208 208 0 1 1 0 416 208 208 0 1 1 0-416zm0 464a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM239 353c9.4 9.4 24.6 9.4 33.9 0l72-72c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-31 31 0-102.1c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 102.1-31-31c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l72 72z"]
  };
  var faCheck = {
    prefix: "far",
    iconName: "check",
    icon: [448, 512, [10003, 10004], "f00c", "M438 68.5c10.8 7.7 13.2 22.7 5.5 33.5l-264 368c-4.1 5.7-10.5 9.4-17.5 9.9S148 478 143 473L7 337c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0L157 419 404.5 74c7.7-10.8 22.7-13.2 33.5-5.5z"]
  };
  var faSliders = {
    prefix: "far",
    iconName: "sliders",
    icon: [512, 512, ["sliders-h"], "f1de", "M24 72C10.7 72 0 82.7 0 96s10.7 24 24 24l91.7 0c10.2 32.5 40.5 56 76.3 56s66.1-23.5 76.3-56L488 120c13.3 0 24-10.7 24-24s-10.7-24-24-24L268.3 72C258.1 39.5 227.8 16 192 16s-66.1 23.5-76.3 56L24 72zm0 160c-13.3 0-24 10.7-24 24s10.7 24 24 24l251.7 0c10.2 32.5 40.5 56 76.3 56s66.1-23.5 76.3-56l59.7 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-59.7 0c-10.2-32.5-40.5-56-76.3-56s-66.1 23.5-76.3 56L24 232zm0 160c-13.3 0-24 10.7-24 24s10.7 24 24 24l59.7 0c10.2 32.5 40.5 56 76.3 56s66.1-23.5 76.3-56L488 440c13.3 0 24-10.7 24-24s-10.7-24-24-24l-251.7 0c-10.2-32.5-40.5-56-76.3-56s-66.1 23.5-76.3 56L24 392zm136 56a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM352 288a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM160 96a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"]
  };
  var faXmark = {
    prefix: "far",
    iconName: "xmark",
    icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M7.5 105c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l151 151 151-151c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-151 151 151 151c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-151-151-151 151c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l151-151-151-151z"]
  };
  var faTimes = faXmark;
  var faChevronDown = {
    prefix: "far",
    iconName: "chevron-down",
    icon: [448, 512, [], "f078", "M207.5 409c9.4 9.4 24.6 9.4 33.9 0l200-200c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-183 183-183-183c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l200 200z"]
  };
  var faSpinnerThird = {
    prefix: "far",
    iconName: "spinner-third",
    icon: [512, 512, [], "f3f4", "M457 372c11.5 6.6 26.3 2.7 31.8-9.3 14.9-32.5 23.2-68.6 23.2-106.7 0-133.3-101.9-242.8-232-254.9-13.2-1.2-24 9.6-24 22.9s10.8 23.9 24 25.4c103.6 11.9 184 99.9 184 206.6 0 29.3-6.1 57.3-17 82.6-5.3 12.2-1.5 26.8 10 33.5z"]
  };
  var faPlus = {
    prefix: "far",
    iconName: "plus",
    icon: [448, 512, [10133, 61543, "add"], "2b", "M248 56c0-13.3-10.7-24-24-24s-24 10.7-24 24l0 176-176 0c-13.3 0-24 10.7-24 24s10.7 24 24 24l176 0 0 176c0 13.3 10.7 24 24 24s24-10.7 24-24l0-176 176 0c13.3 0 24-10.7 24-24s-10.7-24-24-24l-176 0 0-176z"]
  };
  config$1.autoReplaceSvg = "nest";
  library$1.add(
    faSearch,
    faSliders,
    faTimesCircle,
    faSpinnerThird,
    faTimes,
    faCircleArrowDown,
    faChevronDown,
    faCheck,
    faCircle,
    faFileArrowDown,
    faPlus
  );
  dom$1.watch();
  const apps = {
    "#search-bar": { app: _sfc_main$f, state: true, query: true },
    "#main-app": {
      app: _sfc_main$4,
      state: true,
      router: true,
      query: true
    },
    "#single-country": {
      app: _sfc_main$3,
      state: true,
      query: true,
      props: {
        "data-country": "country"
      }
    },
    "#download-page": {
      app: _sfc_main,
      state: true,
      query: true
    }
  };
  const pinia = createPinia();
  const queryClient = VueQueryPlugin;
  document.addEventListener("DOMContentLoaded", async () => {
    for (const selector in apps) {
      if (document.querySelector(selector)) {
        if (apps[selector].state && !pinia) continue;
        const props = {};
        if (apps[selector].props) {
          const element = document.querySelector(selector);
          for (const appProp of Object.entries(apps[selector].props)) {
            const [attribute, propKey] = appProp;
            let value = element.getAttribute(attribute);
            if (value) {
              try {
                value = JSON.parse(value);
              } catch (e2) {
                console.error(e2);
              }
              props[`data${propKey}`] = value;
            }
          }
        }
        const app = createApp(apps[selector].app, props);
        app.use(autoAnimatePlugin);
        if (apps[selector].query) app.use(queryClient);
        if (apps[selector].state && pinia) app.use(pinia);
        app.mount(selector);
      }
    }
  });
})();
